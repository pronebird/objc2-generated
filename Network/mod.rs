// This file has been automatically generated by `objc2`'s `header-translator`.
// DO NOT EDIT

#![allow(unused_imports)]
#![allow(deprecated)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(missing_docs)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::type_complexity)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::identity_op)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::doc_lazy_continuation)]
#![allow(rustdoc::broken_intra_doc_links)]
#![allow(rustdoc::bare_urls)]
#![allow(rustdoc::invalid_html_tags)]

#[link(name = "Network", kind = "framework")]
extern "C" {}

#[cfg(feature = "FoundationExtension")]
#[path = "FoundationExtension.rs"]
mod __FoundationExtension;

#[cfg(all(feature = "FoundationExtension", feature = "objc2"))]
pub use self::__FoundationExtension::NSURLSessionConfigurationNetwork;
use core::ffi::*;
use core::ptr::NonNull;
use dispatch2::*;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;

use crate::*;

extern "C-unwind" {
    /// # Safety
    ///
    /// `obj` must be a valid pointer.
    pub fn nw_retain(obj: *mut c_void) -> *mut c_void;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// `obj` must be a valid pointer.
    pub fn nw_release(obj: *mut c_void);
}

/// An enumeration of possible find results when trying to find a key-value
/// pair in the TXT record object.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_txt_record_find_key_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_txt_record_find_key_t(pub c_uint);
impl nw_txt_record_find_key_t {
    /// to RFC 1464, a key is invalid if it is an empty string, contains
    /// non-ASCII characters, or has length greater than UINT8_MAX.
    #[doc(alias = "nw_txt_record_find_key_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_txt_record_find_key_not_present")]
    pub const not_present: Self = Self(1);
    #[doc(alias = "nw_txt_record_find_key_no_value")]
    pub const no_value: Self = Self(2);
    #[doc(alias = "nw_txt_record_find_key_empty_value")]
    pub const empty_value: Self = Self(3);
    #[doc(alias = "nw_txt_record_find_key_non_empty_value")]
    pub const non_empty_value: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_txt_record_find_key_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_txt_record_find_key_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Create a new TXT record object from a buffer of bytes. If the buffer
/// follows the key-value pair format as defined in RFC 1464, the TXT record
/// object will be created as a dictionary. Otherwise, it is created as a
/// TXT record buffer.
///
///
/// Parameter `txt_bytes`: The pointer to the buffer.
///
///
/// Parameter `txt_len`: The length of the buffer.
///
///
/// Returns: An instantiated TXT record object.
/// Callers are responsible for deallocating using nw_release(obj) or
/// [obj release]. These objects support ARC.
/// Returns NULL on failure. Fails if txt_bytes is NULL or if txt_len is 0.
///
/// # Safety
///
/// `txt_bytes` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_txt_record_create_with_bytes(
    txt_bytes: NonNull<u8>,
    txt_len: usize,
) -> NWRetained<nw_txt_record_t> {
    extern "C-unwind" {
        fn nw_txt_record_create_with_bytes(
            txt_bytes: NonNull<u8>,
            txt_len: usize,
        ) -> Option<NonNull<nw_txt_record_t>>;
    }
    let ret = unsafe { nw_txt_record_create_with_bytes(txt_bytes, txt_len) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Create an empty TXT record dictionary.
///
///
/// Returns: An empty TXT record dictionary.
/// Callers are responsible for deallocating using nw_release(obj) or
/// [obj release]. These objects support ARC.
#[inline]
pub extern "C-unwind" fn nw_txt_record_create_dictionary() -> NWRetained<nw_txt_record_t> {
    extern "C-unwind" {
        fn nw_txt_record_create_dictionary() -> Option<NonNull<nw_txt_record_t>>;
    }
    let ret = unsafe { nw_txt_record_create_dictionary() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Create a deep copy of an existing TXT record object.
///
///
/// Parameter `txt_record`: The TXT record object to be copied.
///
///
/// Returns: A deep copy of the TXT record object.
/// Callers are responsible for deallocating using nw_release(obj) or
/// [obj release]. These objects support ARC.
///
/// # Safety
///
/// `txt_record` must be a valid pointer or null.
#[inline]
pub unsafe extern "C-unwind" fn nw_txt_record_copy(
    txt_record: *mut nw_txt_record_t,
) -> Option<NWRetained<nw_txt_record_t>> {
    extern "C-unwind" {
        fn nw_txt_record_copy(txt_record: *mut nw_txt_record_t)
            -> Option<NonNull<nw_txt_record_t>>;
    }
    let ret = unsafe { nw_txt_record_copy(txt_record) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Find a key-value pair in the TXT record object.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object.
    ///
    ///
    /// Parameter `key`: The key of the key-value pair.
    ///
    ///
    /// Returns: An nw_txt_record_find_key_t representing the type of the key-value pair found.
    /// The key may be invalid, may not exist, have no associated value, have an
    /// empty associated value, or have a non-empty associated value.
    ///
    /// # Safety
    ///
    /// - `txt_record` must be a valid pointer.
    /// - `key` must be a valid pointer.
    pub fn nw_txt_record_find_key(
        txt_record: NonNull<nw_txt_record_t>,
        key: NonNull<c_char>,
    ) -> nw_txt_record_find_key_t;
}

/// Access a value in the TXT record object with its key. Attempts to access
/// or modify the TXT record object from within the block are prohibited.
///
///
/// Parameter `key`: The key of the value.
///
///
/// Parameter `found`: An nw_txt_record_find_key_t representing the type of the key-value pair found.
/// The key may be invalid, may not exist, have no associated value, have an
/// empty associated value, or have a non-empty associated value.
///
///
/// Parameter `value`: The value corresponding to the key. If the key does not exist or has no
/// associated value, value will be NULL. Note that the bytes pointed to by
/// value are only valid within the scope of the block.
///
///
/// Parameter `value_len`: The length of the value. If the key does not exist or has no associated
/// value, value_len will be 0.
///
///
/// Returns: An arbitrary return value defined by the user. For example, the user may
/// want to return true if the operation succeeds.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_txt_record_access_key_t?language=objc)
pub type nw_txt_record_access_key_t = *mut block2::DynBlock<
    dyn Fn(NonNull<c_char>, nw_txt_record_find_key_t, *const u8, usize) -> bool,
>;

extern "C-unwind" {
    /// Access a value in the TXT record object with its key. Attempts to access
    /// or modify the TXT record object from within the block are prohibited.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object.
    ///
    ///
    /// Parameter `access_value`: The block that will be used to access the value of the given key.
    ///
    ///
    /// Returns: The return value of the access_value block. This is an arbitrary return
    /// value defined by the user.
    ///
    /// # Safety
    ///
    /// - `txt_record` must be a valid pointer.
    /// - `key` must be a valid pointer.
    /// - `access_value` must be a valid pointer.
    pub fn nw_txt_record_access_key(
        txt_record: NonNull<nw_txt_record_t>,
        key: NonNull<c_char>,
        access_value: nw_txt_record_access_key_t,
    ) -> bool;
}

extern "C-unwind" {
    /// Set a key-value pair on the TXT record object.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object.
    ///
    ///
    /// Parameter `key`: The key that will be inserted. If the key already exists in the TXT
    /// record object, the existing key-value pair will be replaced.
    ///
    ///
    /// Parameter `value`: The value that will be inserted. If value is set to NULL, then the key
    /// will be inserted with no value.
    ///
    ///
    /// Parameter `value_len`: The length of the value will be inserted. If value is set to zero, then the
    /// key will be inserted with a zero-length value. Inserting a NULL value
    /// with a non-zero length will fail.
    ///
    ///
    /// Returns: A boolean indicating if the key-value pair was inserted successfully.
    /// Returns false if the key is invalid. A key is invalid if it is an empty
    /// string, contains non-ASCII characters, or has length greater than
    /// UINT8_MAX.
    ///
    /// # Safety
    ///
    /// - `txt_record` must be a valid pointer.
    /// - `key` must be a valid pointer.
    /// - `value` must be a valid pointer or null.
    pub fn nw_txt_record_set_key(
        txt_record: NonNull<nw_txt_record_t>,
        key: NonNull<c_char>,
        value: *const u8,
        value_len: usize,
    ) -> bool;
}

extern "C-unwind" {
    /// Removes a key-value pair in the TXT record object given its key.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object.
    ///
    ///
    /// Parameter `key`: The key corresponding to the key-value pair.
    ///
    ///
    /// Returns: A boolean indicating if the key-value pair specified by the given key
    /// was removed. Returns false if the key is invalid or not present in the
    /// TXT dictionary. A key is invalid if it is an empty string, contains
    /// non-ASCII characters, or has length greater than UINT8_MAX.
    ///
    /// # Safety
    ///
    /// - `txt_record` must be a valid pointer.
    /// - `key` must be a valid pointer.
    pub fn nw_txt_record_remove_key(
        txt_record: NonNull<nw_txt_record_t>,
        key: NonNull<c_char>,
    ) -> bool;
}

extern "C-unwind" {
    /// Count the number of keys in the TXT record object.
    ///
    ///
    /// Parameter `txt_record`: A TXT record object.
    ///
    ///
    /// Returns: The number of keys in the TXT record object.
    ///
    /// # Safety
    ///
    /// `txt_record` must be a valid pointer or null.
    pub fn nw_txt_record_get_key_count(txt_record: *mut nw_txt_record_t) -> usize;
}

/// A block to access the raw TXT record inside the TXT record object. For
/// example, the user can copy the raw TXT record into another buffer in the
/// block, or read its contents.
///
///
/// Parameter `raw_txt_record`: The raw TXT record inside the TXT record object. Note that the bytes
/// pointed to by raw_txt_record is only valid within the scope of the block.
///
///
/// Parameter `len`: The length of the raw TXT record.
///
///
/// Returns: A user-defined return value. For example, the user may want to return a
/// boolean indicating if the operation succeeds.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_txt_record_access_bytes_t?language=objc)
pub type nw_txt_record_access_bytes_t = *mut block2::DynBlock<dyn Fn(NonNull<u8>, usize) -> bool>;

extern "C-unwind" {
    /// Access the raw TXT record inside the TXT record object.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object.
    ///
    ///
    /// Parameter `access_bytes`: The block that will be used to access the raw TXT record inside the TXT
    /// record object.
    ///
    ///
    /// Returns: The return value of the access_bytes block, which is defined by the user.
    /// For example, the user may want to return a boolean indicating if the
    /// operation succeeds.
    ///
    /// # Safety
    ///
    /// - `txt_record` must be a valid pointer.
    /// - `access_bytes` must be a valid pointer.
    pub fn nw_txt_record_access_bytes(
        txt_record: NonNull<nw_txt_record_t>,
        access_bytes: nw_txt_record_access_bytes_t,
    ) -> bool;
}

/// A block that can be applied to every key-value pair in the TXT record
/// object.
///
///
/// Parameter `key`: The key of the current iterating key-value pair. Note that key is only
/// valid within the scope of the block.
///
///
/// Parameter `found`: An nw_txt_record_find_key_t representing the type of the key-value pair found.
/// The key may be invalid, may not exist, have no associated value, have an
/// empty associated value, or have a non-empty associated value.
///
///
/// Parameter `value`: The value of the current iterating key-value pair. Note that value is
/// only valid within the scope of the block.
///
///
/// Parameter `value_len`: The length of the value.
///
///
/// Returns: A boolean indicating whether iteration should continue.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_txt_record_applier_t?language=objc)
pub type nw_txt_record_applier_t = *mut block2::DynBlock<
    dyn Fn(NonNull<c_char>, nw_txt_record_find_key_t, NonNull<u8>, usize) -> bool,
>;

extern "C-unwind" {
    /// Apply the block to every key-value pair in the TXT record object.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object.
    ///
    ///
    /// Parameter `applier`: The block that will be applied to the entire TXT record object.
    ///
    ///
    /// Returns: A boolean indicating whether iteration of the TXT record object
    /// completed successfully. Iteration will only fail if the applier block
    /// returns false.
    ///
    /// # Safety
    ///
    /// - `txt_record` must be a valid pointer.
    /// - `applier` must be a valid pointer.
    pub fn nw_txt_record_apply(
        txt_record: NonNull<nw_txt_record_t>,
        applier: nw_txt_record_applier_t,
    ) -> bool;
}

extern "C-unwind" {
    /// Check if the two TXT record objects are equal.
    ///
    ///
    /// Parameter `left`: The first TXT record object to be compared.
    ///
    ///
    /// Parameter `right`: The second TXT record object to be compared.
    ///
    ///
    /// Returns: A boolean indicating if the two TXT record objects are equal. Two TXT
    /// record objects are equal if they contain the same set of key-value pairs,
    /// where keys are compared case-insensitively. For example, "ABC=1" and
    /// "abc=1" are identical key-value pairs. The ordering of the key-value
    /// pairs does not matter.
    ///
    /// # Safety
    ///
    /// - `left` must be a valid pointer or null.
    /// - `right` must be a valid pointer or null.
    pub fn nw_txt_record_is_equal(left: *mut nw_txt_record_t, right: *mut nw_txt_record_t) -> bool;
}

extern "C-unwind" {
    /// Check whether the TXT record is a dictionary or a buffer.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object.
    ///
    ///
    /// Returns: A boolean indicating whether the TXT record is a dictionary or a buffer.
    /// If true, the TXT record is a dictionary. If false, the TXT record is a
    /// buffer.
    ///
    /// # Safety
    ///
    /// `txt_record` must be a valid pointer.
    pub fn nw_txt_record_is_dictionary(txt_record: NonNull<nw_txt_record_t>) -> bool;
}

/// Creates a new advertise descriptor object based on a Bonjour service type
/// and optional domain. This object can be used with listener objects to
/// specify the service the listener should advertise.
///
/// If the name is unspecified, the default name for the device will be used.
/// If the domain is unspecified, the default domains for registration will be
/// used. If the listener is local only, the domain 'local.' will be used
/// regardless of the parameter passed to domain.
///
///
/// Parameter `name`: An optional Bonjour service name.
///
///
/// Parameter `type`: A Bonjour service type.
///
///
/// Parameter `domain`: An optional Bonjour service domain.
///
///
/// Returns: An instantiated browse descriptor object.
///
/// # Safety
///
/// - `name` must be a valid pointer or null.
/// - `type` must be a valid pointer.
/// - `domain` must be a valid pointer or null.
#[inline]
pub unsafe extern "C-unwind" fn nw_advertise_descriptor_create_bonjour_service(
    name: *const c_char,
    r#type: NonNull<c_char>,
    domain: *const c_char,
) -> Option<NWRetained<nw_advertise_descriptor_t>> {
    extern "C-unwind" {
        fn nw_advertise_descriptor_create_bonjour_service(
            name: *const c_char,
            r#type: NonNull<c_char>,
            domain: *const c_char,
        ) -> Option<NonNull<nw_advertise_descriptor_t>>;
    }
    let ret = unsafe { nw_advertise_descriptor_create_bonjour_service(name, r#type, domain) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Set the TXT record for the advertise descriptor's service. You must call
    /// nw_listener_set_advertise_descriptor to update the listener's advertising
    /// afterwards in order for these changes to take effect.
    ///
    ///
    /// Parameter `advertise_descriptor`: The advertise descriptor to modify.
    ///
    ///
    /// Parameter `txt_record`: A pointer to the TXT record.
    ///
    ///
    /// Parameter `txt_length`: The length of the TXT record. The total size of a typical DNS-SD TXT record
    /// is intended to be small - 200 bytes or less. Using TXT records larger than
    /// 1300 bytes is not recommended at this time.
    ///
    /// # Safety
    ///
    /// - `advertise_descriptor` must be a valid pointer.
    /// - `txt_record` must be a valid pointer or null.
    pub fn nw_advertise_descriptor_set_txt_record(
        advertise_descriptor: NonNull<nw_advertise_descriptor_t>,
        txt_record: *const c_void,
        txt_length: usize,
    );
}

extern "C-unwind" {
    /// Disable auto-rename for the Bonjour service registration.
    /// Auto-rename is enabled by default.
    ///
    ///
    /// Parameter `advertise_descriptor`: The advertise descriptor to modify.
    ///
    ///
    /// Parameter `no_auto_rename`: A boolean indicating if auto-rename should be disabled.
    ///
    /// # Safety
    ///
    /// `advertise_descriptor` must be a valid pointer.
    pub fn nw_advertise_descriptor_set_no_auto_rename(
        advertise_descriptor: NonNull<nw_advertise_descriptor_t>,
        no_auto_rename: bool,
    );
}

extern "C-unwind" {
    /// Check if auto-rename has been disabled for the Bonjour service
    /// registration.
    ///
    ///
    /// Parameter `advertise_descriptor`: The advertise descriptor object.
    ///
    ///
    /// Returns: A boolean indicating if auto-rename is disabled.
    ///
    /// # Safety
    ///
    /// `advertise_descriptor` must be a valid pointer.
    pub fn nw_advertise_descriptor_get_no_auto_rename(
        advertise_descriptor: NonNull<nw_advertise_descriptor_t>,
    ) -> bool;
}

extern "C-unwind" {
    /// Set the TXT record object on the advertise descriptor.
    ///
    ///
    /// Parameter `advertise_descriptor`: The advertise descriptor object.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object. If txt_record is NULL, the advertise_descriptor's
    /// current TXT record object will be removed.
    ///
    /// # Safety
    ///
    /// - `advertise_descriptor` must be a valid pointer.
    /// - `txt_record` must be a valid pointer or null.
    pub fn nw_advertise_descriptor_set_txt_record_object(
        advertise_descriptor: NonNull<nw_advertise_descriptor_t>,
        txt_record: *mut nw_txt_record_t,
    );
}

/// Copies the TXT record object from the advertise descriptor.
///
///
/// Parameter `advertise_descriptor`: The advertise descriptor object.
///
///
/// Returns: A copy of the TXT record object, or NULL if the advertise descriptor
/// does not have an associated TXT record.
///
/// # Safety
///
/// `advertise_descriptor` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_advertise_descriptor_copy_txt_record_object(
    advertise_descriptor: NonNull<nw_advertise_descriptor_t>,
) -> Option<NWRetained<nw_txt_record_t>> {
    extern "C-unwind" {
        fn nw_advertise_descriptor_copy_txt_record_object(
            advertise_descriptor: NonNull<nw_advertise_descriptor_t>,
        ) -> Option<NonNull<nw_txt_record_t>>;
    }
    let ret = unsafe { nw_advertise_descriptor_copy_txt_record_object(advertise_descriptor) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

/// Creates an advertise descriptor for application service discovery.
///
///
/// Parameter `application_service_name`: The service name to advertise.
///
///
/// Returns: An instantiated advertise descriptor object.
///
/// # Safety
///
/// `application_service_name` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_advertise_descriptor_create_application_service(
    application_service_name: NonNull<c_char>,
) -> NWRetained<nw_advertise_descriptor_t> {
    extern "C-unwind" {
        fn nw_advertise_descriptor_create_application_service(
            application_service_name: NonNull<c_char>,
        ) -> Option<NonNull<nw_advertise_descriptor_t>>;
    }
    let ret =
        unsafe { nw_advertise_descriptor_create_application_service(application_service_name) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Returns the service name of an application service advertise descriptor.
    ///
    ///
    /// Parameter `advertise_descriptor`: An advertise descriptor object.
    ///
    ///
    /// Returns: The service name or NULL if the advertise descriptor is not of the correct type.
    ///
    /// # Safety
    ///
    /// `advertise_descriptor` must be a valid pointer.
    pub fn nw_advertise_descriptor_get_application_service_name(
        advertise_descriptor: NonNull<nw_advertise_descriptor_t>,
    ) -> *const c_char;
}

extern "C-unwind" {
    /// Compare two protocol definitions to check if they represent the same protocol.
    ///
    ///
    /// Parameter `definition1`: The first definition to compare
    ///
    ///
    /// Parameter `definition2`: The second definition to compare
    ///
    ///
    /// Returns: Returns true if the definitions represent the same protocol, false otherwise.
    ///
    /// # Safety
    ///
    /// - `definition1` must be a valid pointer.
    /// - `definition2` must be a valid pointer.
    pub fn nw_protocol_definition_is_equal(
        definition1: NonNull<nw_protocol_definition_t>,
        definition2: NonNull<nw_protocol_definition_t>,
    ) -> bool;
}

/// Retrieve the protocol definition for a given options object.
///
///
/// Parameter `options`: The protocol options to check
///
///
/// Returns: Returns a reference-counted protocol definition object.
///
/// # Safety
///
/// `options` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_protocol_options_copy_definition(
    options: NonNull<nw_protocol_options_t>,
) -> NWRetained<nw_protocol_definition_t> {
    extern "C-unwind" {
        fn nw_protocol_options_copy_definition(
            options: NonNull<nw_protocol_options_t>,
        ) -> Option<NonNull<nw_protocol_definition_t>>;
    }
    let ret = unsafe { nw_protocol_options_copy_definition(options) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Retrieve the protocol definition for a given metadata object.
///
///
/// Parameter `metadata`: The protocol metadata to check
///
///
/// Returns: Returns a reference-counted protocol definition object.
///
/// # Safety
///
/// `metadata` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_protocol_metadata_copy_definition(
    metadata: NonNull<nw_protocol_metadata_t>,
) -> NWRetained<nw_protocol_definition_t> {
    extern "C-unwind" {
        fn nw_protocol_metadata_copy_definition(
            metadata: NonNull<nw_protocol_metadata_t>,
        ) -> Option<NonNull<nw_protocol_definition_t>>;
    }
    let ret = unsafe { nw_protocol_metadata_copy_definition(metadata) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Interface types represent the underlying media for a network link, such as Wi-Fi or
/// Cellular.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_interface_type_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_interface_type_t(pub c_uint);
impl nw_interface_type_t {
    #[doc(alias = "nw_interface_type_other")]
    pub const other: Self = Self(0);
    #[doc(alias = "nw_interface_type_wifi")]
    pub const wifi: Self = Self(1);
    #[doc(alias = "nw_interface_type_cellular")]
    pub const cellular: Self = Self(2);
    #[doc(alias = "nw_interface_type_wired")]
    pub const wired: Self = Self(3);
    #[doc(alias = "nw_interface_type_loopback")]
    pub const loopback: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_interface_type_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_interface_type_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Retrieves the type of an interface. This only accesses the type of the specific
    /// interface being queried, and will not take into account types used by interfaces
    /// that traffic will eventually be routed through. That is, if the interface is a virtual
    /// interface (such as a VPN) that eventually forwards traffic through Wi-Fi, the type
    /// will be nw_interface_type_other, not nw_interface_type_wifi.
    ///
    ///
    /// Parameter `interface`: The interface object to check.
    ///
    ///
    /// Returns: Returns the type of the interface.
    ///
    /// # Safety
    ///
    /// `interface` must be a valid pointer.
    pub fn nw_interface_get_type(interface: NonNull<nw_interface_t>) -> nw_interface_type_t;
}

/// Interface radio types represent the radio technology for a network link.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_interface_radio_type_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_interface_radio_type_t(pub c_uint);
impl nw_interface_radio_type_t {
    #[doc(alias = "nw_interface_radio_type_unknown")]
    pub const unknown: Self = Self(0);
    #[doc(alias = "nw_interface_radio_type_wifi_b")]
    pub const wifi_b: Self = Self(1);
    #[doc(alias = "nw_interface_radio_type_wifi_a")]
    pub const wifi_a: Self = Self(2);
    #[doc(alias = "nw_interface_radio_type_wifi_g")]
    pub const wifi_g: Self = Self(3);
    #[doc(alias = "nw_interface_radio_type_wifi_n")]
    pub const wifi_n: Self = Self(4);
    #[doc(alias = "nw_interface_radio_type_wifi_ac")]
    pub const wifi_ac: Self = Self(5);
    #[doc(alias = "nw_interface_radio_type_wifi_ax")]
    pub const wifi_ax: Self = Self(6);
    #[doc(alias = "nw_interface_radio_type_cell_lte")]
    pub const cell_lte: Self = Self(0x80);
    #[doc(alias = "nw_interface_radio_type_cell_endc_sub6")]
    pub const cell_endc_sub6: Self = Self(0x81);
    #[doc(alias = "nw_interface_radio_type_cell_endc_mmw")]
    pub const cell_endc_mmw: Self = Self(0x82);
    #[doc(alias = "nw_interface_radio_type_cell_nr_sa_sub6")]
    pub const cell_nr_sa_sub6: Self = Self(0x83);
    #[doc(alias = "nw_interface_radio_type_cell_nr_sa_mmw")]
    pub const cell_nr_sa_mmw: Self = Self(0x84);
    #[doc(alias = "nw_interface_radio_type_cell_wcdma")]
    pub const cell_wcdma: Self = Self(0x85);
    #[doc(alias = "nw_interface_radio_type_cell_gsm")]
    pub const cell_gsm: Self = Self(0x86);
    #[doc(alias = "nw_interface_radio_type_cell_cdma")]
    pub const cell_cdma: Self = Self(0x87);
    #[doc(alias = "nw_interface_radio_type_cell_evdo")]
    pub const cell_evdo: Self = Self(0x88);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_interface_radio_type_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_interface_radio_type_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Retrieves the name of an interface, to be used for reference or logging
/// purposes.
///
///
/// Parameter `interface`: The interface object to check.
///
///
/// Returns: Returns the name of the interface as a NULL-terminated C string,
/// or NULL if the interface is NULL.
///
/// # Safety
///
/// `interface` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_interface_get_name(
    interface: NonNull<nw_interface_t>,
) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_interface_get_name(interface: NonNull<nw_interface_t>) -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_interface_get_name(interface) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

extern "C-unwind" {
    /// Retrieves the index of an interface, to be used for reference or logging
    /// purposes. This is the same value as provided by if_nametoindex.
    ///
    ///
    /// Parameter `interface`: The interface object to check.
    ///
    ///
    /// Returns: Returns the index of the interface, or 0 if the interface is NULL.
    ///
    /// # Safety
    ///
    /// `interface` must be a valid pointer.
    pub fn nw_interface_get_index(interface: NonNull<nw_interface_t>) -> u32;
}

/// Endpoint types represent a well-known form of endpoint. Values may be
/// added to this enumeration, and some custom endpoint types may use
/// values not defined in this enumeration.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_endpoint_type_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_endpoint_type_t(pub c_uint);
impl nw_endpoint_type_t {
    #[doc(alias = "nw_endpoint_type_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_endpoint_type_address")]
    pub const address: Self = Self(1);
    #[doc(alias = "nw_endpoint_type_host")]
    pub const host: Self = Self(2);
    #[doc(alias = "nw_endpoint_type_bonjour_service")]
    pub const bonjour_service: Self = Self(3);
    #[doc(alias = "nw_endpoint_type_url")]
    pub const url: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_endpoint_type_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_endpoint_type_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Retrieves the type of a network endpoint.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object for which to get the type.
    ///
    ///
    /// Returns: Returns the type of the network endpoint.
    ///
    /// # Safety
    ///
    /// `endpoint` must be a valid pointer.
    pub fn nw_endpoint_get_type(endpoint: NonNull<nw_endpoint_t>) -> nw_endpoint_type_t;
}

/// Creates a network endpoint with a hostname and port. The hostname
/// may be a string-encoding of an IP address, in which case the
/// the endpoint will be treated as an endpoint with the type
/// nw_endpoint_type_address. Otherwise, the endpoint will have the
/// type nw_endpoint_type_host.
///
///
/// Parameter `hostname`: A hostname, such as "www.example.com", or "2607:ffff::1234:abcd".
///
///
/// Parameter `port`: A port number as a C string, such as "443", or a service
/// name, such as "https".
///
///
/// Returns: Returns an allocated nw_endpoint_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
/// Returns NULL on failure. Fails due to invalid parameters.
///
/// # Safety
///
/// - `hostname` must be a valid pointer.
/// - `port` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_endpoint_create_host(
    hostname: NonNull<c_char>,
    port: NonNull<c_char>,
) -> NWRetained<nw_endpoint_t> {
    extern "C-unwind" {
        fn nw_endpoint_create_host(
            hostname: NonNull<c_char>,
            port: NonNull<c_char>,
        ) -> Option<NonNull<nw_endpoint_t>>;
    }
    let ret = unsafe { nw_endpoint_create_host(hostname, port) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Retrieves the hostname string for a network endpoint with
/// the type nw_endpoint_type_host or nw_endpoint_type_url.
///
///
/// Parameter `endpoint`: The endpoint object.
///
///
/// Returns: Returns the hostname string for the endpoint, or NULL
/// if the endpoint is not of type nw_endpoint_type_host.
///
/// # Safety
///
/// `endpoint` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_endpoint_get_hostname(
    endpoint: NonNull<nw_endpoint_t>,
) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_endpoint_get_hostname(endpoint: NonNull<nw_endpoint_t>) -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_endpoint_get_hostname(endpoint) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

/// Returns an allocated port string for a network endpoint with
/// the type nw_endpoint_type_host or nw_endpoint_type_address.
///
///
/// Parameter `endpoint`: The endpoint object.
///
///
/// Returns: Returns the port string for the endpoint, or NULL
/// if the endpoint is not of type nw_endpoint_type_host or
/// nw_endpoint_type_address. This string must be freed with free().
///
/// # Safety
///
/// `endpoint` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_endpoint_copy_port_string(
    endpoint: NonNull<nw_endpoint_t>,
) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_endpoint_copy_port_string(
            endpoint: NonNull<nw_endpoint_t>,
        ) -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_endpoint_copy_port_string(endpoint) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

extern "C-unwind" {
    /// Retrieves the port for a network endpoint with the type
    /// nw_endpoint_type_url, nw_endpoint_type_host, or nw_endpoint_type_address.
    /// The port will be returned in Host Byte Order.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object.
    ///
    ///
    /// Returns: Returns the port for the endpoint, or 0 if the endpoint is not
    /// of type nw_endpoint_type_host or nw_endpoint_type_address.
    /// The port will be returned in Host Byte Order.
    ///
    /// # Safety
    ///
    /// `endpoint` must be a valid pointer.
    pub fn nw_endpoint_get_port(endpoint: NonNull<nw_endpoint_t>) -> u16;
}

/// Creates a network endpoint with a sockaddr struct. The endpoint
/// will have the type nw_endpoint_type_address.
///
///
/// Parameter `address`: An address stored as a sockaddr.
///
///
/// Returns: Returns an allocated nw_endpoint_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
/// Returns NULL on failure. Fails due to invalid parameters.
///
/// # Safety
///
/// `address` must be a valid pointer.
#[cfg(feature = "libc")]
#[inline]
pub unsafe extern "C-unwind" fn nw_endpoint_create_address(
    address: NonNull<libc::sockaddr>,
) -> NWRetained<nw_endpoint_t> {
    extern "C-unwind" {
        fn nw_endpoint_create_address(
            address: NonNull<libc::sockaddr>,
        ) -> Option<NonNull<nw_endpoint_t>>;
    }
    let ret = unsafe { nw_endpoint_create_address(address) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Returns an allocated IP address string for a network endpoint with
/// the type nw_endpoint_type_address.
///
///
/// Parameter `endpoint`: The endpoint object.
///
///
/// Returns: Returns the IP address string for the endpoint, or NULL
/// if the endpoint is not of type nw_endpoint_type_address.
/// This string must be freed with free().
///
/// # Safety
///
/// `endpoint` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_endpoint_copy_address_string(
    endpoint: NonNull<nw_endpoint_t>,
) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_endpoint_copy_address_string(
            endpoint: NonNull<nw_endpoint_t>,
        ) -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_endpoint_copy_address_string(endpoint) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

/// Retrieves the sockaddr struct for a network endpoint with
/// the type nw_endpoint_type_address.
///
///
/// Parameter `endpoint`: The endpoint object.
///
///
/// Returns: Returns the sockaddr struct for the endpoint, or NULL
/// if the endpoint is not of type nw_endpoint_type_address.
///
/// # Safety
///
/// `endpoint` must be a valid pointer.
#[cfg(feature = "libc")]
#[inline]
pub unsafe extern "C-unwind" fn nw_endpoint_get_address(
    endpoint: NonNull<nw_endpoint_t>,
) -> NonNull<libc::sockaddr> {
    extern "C-unwind" {
        fn nw_endpoint_get_address(
            endpoint: NonNull<nw_endpoint_t>,
        ) -> Option<NonNull<libc::sockaddr>>;
    }
    let ret = unsafe { nw_endpoint_get_address(endpoint) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

/// Creates a network endpoint for a Bonjour Service name, type, and
/// domain. The endpoint will have the type nw_endpoint_type_bonjour_service.
///
///
/// Parameter `name`: The Bonjour Service name, such as "example".
///
///
/// Parameter `type`: The Bonjour Service type, such as "_http._tcp".
///
///
/// Parameter `domain`: The Bonjour Service domain, such as "local".
///
///
/// Returns: Returns an allocated nw_endpoint_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
/// Returns NULL on failure. Fails due to invalid parameters.
///
/// # Safety
///
/// - `name` must be a valid pointer.
/// - `type` must be a valid pointer.
/// - `domain` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_endpoint_create_bonjour_service(
    name: NonNull<c_char>,
    r#type: NonNull<c_char>,
    domain: NonNull<c_char>,
) -> NWRetained<nw_endpoint_t> {
    extern "C-unwind" {
        fn nw_endpoint_create_bonjour_service(
            name: NonNull<c_char>,
            r#type: NonNull<c_char>,
            domain: NonNull<c_char>,
        ) -> Option<NonNull<nw_endpoint_t>>;
    }
    let ret = unsafe { nw_endpoint_create_bonjour_service(name, r#type, domain) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Retrieves the Bonjour Service name string for a network
/// endpoint with the type nw_endpoint_type_bonjour_service.
///
///
/// Parameter `endpoint`: The endpoint object.
///
///
/// Returns: Returns the Bonjour Service name string for the endpoint, or NULL
/// if the endpoint is not of type nw_endpoint_type_bonjour_service.
///
/// # Safety
///
/// `endpoint` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_endpoint_get_bonjour_service_name(
    endpoint: NonNull<nw_endpoint_t>,
) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_endpoint_get_bonjour_service_name(
            endpoint: NonNull<nw_endpoint_t>,
        ) -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_endpoint_get_bonjour_service_name(endpoint) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

/// Retrieves the Bonjour Service type string for a network
/// endpoint with the type nw_endpoint_type_bonjour_service.
///
///
/// Parameter `endpoint`: The endpoint object.
///
///
/// Returns: Returns the Bonjour Service type string for the endpoint, or NULL
/// if the endpoint is not of type nw_endpoint_type_bonjour_service.
///
/// # Safety
///
/// `endpoint` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_endpoint_get_bonjour_service_type(
    endpoint: NonNull<nw_endpoint_t>,
) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_endpoint_get_bonjour_service_type(
            endpoint: NonNull<nw_endpoint_t>,
        ) -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_endpoint_get_bonjour_service_type(endpoint) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

/// Retrieves the Bonjour Service domain string for a network
/// endpoint with the type nw_endpoint_type_bonjour_service.
///
///
/// Parameter `endpoint`: The endpoint object.
///
///
/// Returns: Returns the Bonjour Service domain string for the endpoint, or NULL
/// if the endpoint is not of type nw_endpoint_type_bonjour_service.
///
/// # Safety
///
/// `endpoint` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_endpoint_get_bonjour_service_domain(
    endpoint: NonNull<nw_endpoint_t>,
) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_endpoint_get_bonjour_service_domain(
            endpoint: NonNull<nw_endpoint_t>,
        ) -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_endpoint_get_bonjour_service_domain(endpoint) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

/// Creates a network endpoint with a URL. The endpoint will have the type
/// nw_endpoint_type_url.
///
///
/// Parameter `url`: The URL string.
///
///
/// Returns: Returns an allocated nw_endpoint_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
/// Returns NULL on failure. Fails due to invalid parameters, or due to URL parsing failure.
///
/// # Safety
///
/// `url` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_endpoint_create_url(
    url: NonNull<c_char>,
) -> NWRetained<nw_endpoint_t> {
    extern "C-unwind" {
        fn nw_endpoint_create_url(url: NonNull<c_char>) -> Option<NonNull<nw_endpoint_t>>;
    }
    let ret = unsafe { nw_endpoint_create_url(url) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Retrieves the URL string from a network endpoint of type
/// nw_endpoint_type_url.
///
///
/// Parameter `endpoint`: The endpoint object.
///
///
/// Returns: The URL string, or NULL if the endpoint is not of type
/// nw_endpoint_type_url.
///
/// # Safety
///
/// `endpoint` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_endpoint_get_url(
    endpoint: NonNull<nw_endpoint_t>,
) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_endpoint_get_url(endpoint: NonNull<nw_endpoint_t>) -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_endpoint_get_url(endpoint) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

/// Retrieves the TXT record associated with the endpoint, if present.
/// TXT records can be populated during browsing and connection
/// establishment.
///
///
/// Parameter `endpoint`: The endpoint object.
///
///
/// Returns: Returns a retained nw_txt_record_t object if a TXT record
/// is associated with this endpoint, or NULL otherwise.
///
/// # Safety
///
/// `endpoint` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_endpoint_copy_txt_record(
    endpoint: NonNull<nw_endpoint_t>,
) -> Option<NWRetained<nw_txt_record_t>> {
    extern "C-unwind" {
        fn nw_endpoint_copy_txt_record(
            endpoint: NonNull<nw_endpoint_t>,
        ) -> Option<NonNull<nw_txt_record_t>>;
    }
    let ret = unsafe { nw_endpoint_copy_txt_record(endpoint) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Retrieves a signed data blob associated with an endpoint.
    ///
    ///
    /// Parameter `endpoint`: The endpoint to modify.
    ///
    ///
    /// Parameter `out_signature_length`: A pointer to a size_t that will take the length of the signature.
    ///
    ///
    /// Returns: Returns a pointer to a buffer of bytes containing a signature,
    /// or NULL if the endpoint is not signed.
    ///
    /// # Safety
    ///
    /// - `endpoint` must be a valid pointer.
    /// - `out_signature_length` must be a valid pointer.
    pub fn nw_endpoint_get_signature(
        endpoint: NonNull<nw_endpoint_t>,
        out_signature_length: NonNull<usize>,
    ) -> *const u8;
}

/// Creates a DNS-over-HTTPS (DoH) resolver configuration. The provided
/// URL describes the location of the DNS server, such as
/// "https://dnsserver.example.net/dns-query". See RFC 8484.
///
///
/// Parameter `url_endpoint`: The URL template of the DoH server as an endpoint.
///
///
/// Returns: Returns an allocated nw_resolver_config_t object on success.
///
/// # Safety
///
/// `url_endpoint` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_resolver_config_create_https(
    url_endpoint: NonNull<nw_endpoint_t>,
) -> NWRetained<nw_resolver_config_t> {
    extern "C-unwind" {
        fn nw_resolver_config_create_https(
            url_endpoint: NonNull<nw_endpoint_t>,
        ) -> Option<NonNull<nw_resolver_config_t>>;
    }
    let ret = unsafe { nw_resolver_config_create_https(url_endpoint) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Creates a DNS-over-TLS (DoT) resolver configuration. The hostname
/// of the provided endpoint will be used to validate the TLS certificate of the server.
/// See RFC 7858.
///
///
/// Parameter `server_endpoint`: A host endpoint identifying the DoT server.
///
///
/// Returns: Returns an allocated nw_resolver_config_t object on success.
///
/// # Safety
///
/// `server_endpoint` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_resolver_config_create_tls(
    server_endpoint: NonNull<nw_endpoint_t>,
) -> NWRetained<nw_resolver_config_t> {
    extern "C-unwind" {
        fn nw_resolver_config_create_tls(
            server_endpoint: NonNull<nw_endpoint_t>,
        ) -> Option<NonNull<nw_resolver_config_t>>;
    }
    let ret = unsafe { nw_resolver_config_create_tls(server_endpoint) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Modifies the resolver configuration by adding a DNS server address as an endpoint.
    ///
    ///
    /// Parameter `config`: A resolver config object.
    ///
    ///
    /// Parameter `server_address`: A server address to assign to the configuration, as an endpoint.
    ///
    /// # Safety
    ///
    /// - `config` must be a valid pointer.
    /// - `server_address` must be a valid pointer.
    pub fn nw_resolver_config_add_server_address(
        config: NonNull<nw_resolver_config_t>,
        server_address: NonNull<nw_endpoint_t>,
    );
}

/// Creates a configuration for a secure relay. A relay is a proxy that is accessible using
/// HTTP/3, HTTP/2, or both, and uses the CONNECT method to proxy TCP or UDP
/// connections. At least one of `http3_relay_endpoint` and
/// `http2_relay_endpoint` must be non-null.
///
///
/// Parameter `http3_relay_endpoint`: A URL or host endpoint identifying the relay server accessible using HTTP/3.
///
///
/// Parameter `http2_relay_endpoint`: A URL or host endpoint identifying the relay server accessible using HTTP/2.
///
///
/// Parameter `relay_tls_options`: Optional TLS options to use for the TLS handshake to the relay. If this is null, default
/// TLS options will be used.
///
///
/// Returns: Returns an allocated `nw_relay_hop_t` object on success.
///
/// # Safety
///
/// - `http3_relay_endpoint` must be a valid pointer or null.
/// - `http2_relay_endpoint` must be a valid pointer or null.
/// - `relay_tls_options` must be a valid pointer or null.
#[inline]
pub unsafe extern "C-unwind" fn nw_relay_hop_create(
    http3_relay_endpoint: *mut nw_endpoint_t,
    http2_relay_endpoint: *mut nw_endpoint_t,
    relay_tls_options: *mut nw_protocol_options_t,
) -> NWRetained<nw_relay_hop_t> {
    extern "C-unwind" {
        fn nw_relay_hop_create(
            http3_relay_endpoint: *mut nw_endpoint_t,
            http2_relay_endpoint: *mut nw_endpoint_t,
            relay_tls_options: *mut nw_protocol_options_t,
        ) -> Option<NonNull<nw_relay_hop_t>>;
    }
    let ret = unsafe {
        nw_relay_hop_create(
            http3_relay_endpoint,
            http2_relay_endpoint,
            relay_tls_options,
        )
    };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Adds additional HTTP headers to send as part of CONNECT requests to the
    /// relay.
    ///
    ///
    /// Parameter `relay_hop`: The proxy hop object.
    ///
    ///
    /// Parameter `field_name`: The HTTP header field name.
    ///
    ///
    /// Parameter `field_value`: The HTTP header field value.
    ///
    /// # Safety
    ///
    /// - `relay_hop` must be a valid pointer.
    /// - `field_name` must be a valid pointer.
    /// - `field_value` must be a valid pointer.
    pub fn nw_relay_hop_add_additional_http_header_field(
        relay_hop: NonNull<nw_relay_hop_t>,
        field_name: NonNull<c_char>,
        field_value: NonNull<c_char>,
    );
}

/// Creates a proxy configuration with one or two secure relay hops.
///
///
/// Parameter `first_hop`: The first or only relay hop.
///
///
/// Parameter `second_hop`: An optional second relay hop.
///
///
/// Returns: Returns an allocated `nw_proxy_config_t` object on success.
///
/// # Safety
///
/// - `first_hop` must be a valid pointer.
/// - `second_hop` must be a valid pointer or null.
#[inline]
pub unsafe extern "C-unwind" fn nw_proxy_config_create_relay(
    first_hop: NonNull<nw_relay_hop_t>,
    second_hop: *mut nw_relay_hop_t,
) -> NWRetained<nw_proxy_config_t> {
    extern "C-unwind" {
        fn nw_proxy_config_create_relay(
            first_hop: NonNull<nw_relay_hop_t>,
            second_hop: *mut nw_relay_hop_t,
        ) -> Option<NonNull<nw_proxy_config_t>>;
    }
    let ret = unsafe { nw_proxy_config_create_relay(first_hop, second_hop) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Creates a proxy configuration for an Oblivious HTTP relay and gateway. Note that
/// Oblivious HTTP proxy configurations must also have specific match domains specified
/// using `nw_proxy_config_add_match_domain`.
///
///
/// Parameter `relay`: The Oblivious HTTP relay hop.
///
///
/// Parameter `relay_resource_path`: The HTTP path to use for requests to the Oblivious HTTP relay that will forward requests to the gateway.
///
///
/// Parameter `gateway_key_config`: The key configuration for the Oblivious HTTP gateway, or a list of key configurations where each configuration
/// is prefixed with a two-byte length in network byte order.
///
///
/// Parameter `gateway_key_config_length`: The length of the buffer in `gateway_key_config`.
///
///
/// Returns: Returns an allocated `nw_proxy_config_t` object on success.
///
/// # Safety
///
/// - `relay` must be a valid pointer.
/// - `relay_resource_path` must be a valid pointer.
/// - `gateway_key_config` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_proxy_config_create_oblivious_http(
    relay: NonNull<nw_relay_hop_t>,
    relay_resource_path: NonNull<c_char>,
    gateway_key_config: NonNull<u8>,
    gateway_key_config_length: usize,
) -> NWRetained<nw_proxy_config_t> {
    extern "C-unwind" {
        fn nw_proxy_config_create_oblivious_http(
            relay: NonNull<nw_relay_hop_t>,
            relay_resource_path: NonNull<c_char>,
            gateway_key_config: NonNull<u8>,
            gateway_key_config_length: usize,
        ) -> Option<NonNull<nw_proxy_config_t>>;
    }
    let ret = unsafe {
        nw_proxy_config_create_oblivious_http(
            relay,
            relay_resource_path,
            gateway_key_config,
            gateway_key_config_length,
        )
    };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Creates a legacy HTTP CONNECT proxy configuration for a proxy server accessible
/// using HTTP/1.1. This proxy will only relay TCP connections.
///
///
/// Parameter `proxy_endpoint`: A host endpoint identifying the proxy server accessible using HTTP/1.1.
///
///
/// Parameter `proxy_tls_options`: Optional TLS options to use for a TLS handshake to the relay. If no options are provided,
/// the proxy will be accessed using cleartext HTTP.
///
///
/// Returns: Returns an allocated `nw_proxy_config_t` object on success.
///
/// # Safety
///
/// - `proxy_endpoint` must be a valid pointer.
/// - `proxy_tls_options` must be a valid pointer or null.
#[inline]
pub unsafe extern "C-unwind" fn nw_proxy_config_create_http_connect(
    proxy_endpoint: NonNull<nw_endpoint_t>,
    proxy_tls_options: *mut nw_protocol_options_t,
) -> NWRetained<nw_proxy_config_t> {
    extern "C-unwind" {
        fn nw_proxy_config_create_http_connect(
            proxy_endpoint: NonNull<nw_endpoint_t>,
            proxy_tls_options: *mut nw_protocol_options_t,
        ) -> Option<NonNull<nw_proxy_config_t>>;
    }
    let ret = unsafe { nw_proxy_config_create_http_connect(proxy_endpoint, proxy_tls_options) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Creates a SOCKSv5 proxy configuration.
///
///
/// Parameter `proxy_endpoint`: A host endpoint identifying the SOCKS proxy server.
///
///
/// Returns: Returns an allocated `nw_proxy_config_t` object on success.
///
/// # Safety
///
/// `proxy_endpoint` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_proxy_config_create_socksv5(
    proxy_endpoint: NonNull<nw_endpoint_t>,
) -> NWRetained<nw_proxy_config_t> {
    extern "C-unwind" {
        fn nw_proxy_config_create_socksv5(
            proxy_endpoint: NonNull<nw_endpoint_t>,
        ) -> Option<NonNull<nw_proxy_config_t>>;
    }
    let ret = unsafe { nw_proxy_config_create_socksv5(proxy_endpoint) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Configures a username and password to use with a proxy configuration.
    ///
    ///
    /// Parameter `proxy_config`: The proxy configuration object.
    ///
    ///
    /// Parameter `username`: A proxy authentication username.
    ///
    ///
    /// Parameter `password`: A proxy authentication password.
    ///
    /// # Safety
    ///
    /// - `proxy_config` must be a valid pointer.
    /// - `username` must be a valid pointer.
    /// - `password` must be a valid pointer or null.
    pub fn nw_proxy_config_set_username_and_password(
        proxy_config: NonNull<nw_proxy_config_t>,
        username: NonNull<c_char>,
        password: *const c_char,
    );
}

extern "C-unwind" {
    /// Set whether or not a proxy configuration allows failover to non-proxied connections.
    /// Failover is not allowed by default.
    ///
    ///
    /// Parameter `proxy_config`: The proxy configuration object.
    ///
    ///
    /// Parameter `failover_allowed`: A Boolean indicating if failover is allowed.
    ///
    /// # Safety
    ///
    /// `proxy_config` must be a valid pointer.
    pub fn nw_proxy_config_set_failover_allowed(
        proxy_config: NonNull<nw_proxy_config_t>,
        failover_allowed: bool,
    );
}

extern "C-unwind" {
    /// Check whether or not a proxy configuration allows failover to non-proxied connections.
    ///
    ///
    /// Parameter `proxy_config`: The proxy configuration object.
    ///
    ///
    /// Returns: A Boolean indicating if failover is allowed.
    ///
    /// # Safety
    ///
    /// `proxy_config` must be a valid pointer.
    pub fn nw_proxy_config_get_failover_allowed(proxy_config: NonNull<nw_proxy_config_t>) -> bool;
}

extern "C-unwind" {
    /// Adds a domain to define which hosts should use the proxy.
    ///
    ///
    /// Parameter `config`: The proxy configuration object.
    ///
    ///
    /// Parameter `match_domain`: The domain suffix to match hostnames against, as a string.
    ///
    /// # Safety
    ///
    /// - `config` must be a valid pointer.
    /// - `match_domain` must be a valid pointer.
    pub fn nw_proxy_config_add_match_domain(
        config: NonNull<nw_proxy_config_t>,
        match_domain: NonNull<c_char>,
    );
}

extern "C-unwind" {
    /// Clears all match domains defined for the proxy.
    ///
    ///
    /// Parameter `config`: The proxy configuration object.
    ///
    /// # Safety
    ///
    /// `config` must be a valid pointer.
    pub fn nw_proxy_config_clear_match_domains(config: NonNull<nw_proxy_config_t>);
}

extern "C-unwind" {
    /// Adds a domain to define which hosts should not use the proxy.
    ///
    ///
    /// Parameter `config`: The proxy configuration object.
    ///
    ///
    /// Parameter `excluded_domain`: The domain suffix to match hostnames against, as a string.
    ///
    /// # Safety
    ///
    /// - `config` must be a valid pointer.
    /// - `excluded_domain` must be a valid pointer.
    pub fn nw_proxy_config_add_excluded_domain(
        config: NonNull<nw_proxy_config_t>,
        excluded_domain: NonNull<c_char>,
    );
}

extern "C-unwind" {
    /// Clears all excluded domains defined for the proxy.
    ///
    ///
    /// Parameter `config`: The proxy configuration object.
    ///
    /// # Safety
    ///
    /// `config` must be a valid pointer.
    pub fn nw_proxy_config_clear_excluded_domains(config: NonNull<nw_proxy_config_t>);
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_proxy_domain_enumerator_t?language=objc)
pub type nw_proxy_domain_enumerator_t = *mut block2::DynBlock<dyn Fn(NonNull<c_char>)>;

extern "C-unwind" {
    /// Enumerate all match domains set on the proxy configuration.
    ///
    ///
    /// Parameter `config`: The proxy configuration object.
    ///
    ///
    /// Parameter `enumerator`: A block that will get invoked for every domain that was added to the proxy configuration.
    ///
    /// # Safety
    ///
    /// - `config` must be a valid pointer.
    /// - `enumerator` must be a valid pointer.
    pub fn nw_proxy_config_enumerate_match_domains(
        config: NonNull<nw_proxy_config_t>,
        enumerator: nw_proxy_domain_enumerator_t,
    );
}

extern "C-unwind" {
    /// Enumerate all excluded domains set on the proxy configuration.
    ///
    ///
    /// Parameter `config`: The proxy configuration object.
    ///
    ///
    /// Parameter `enumerator`: A block that will get invoked for every domain that was added to the proxy configuration.
    ///
    /// # Safety
    ///
    /// - `config` must be a valid pointer.
    /// - `enumerator` must be a valid pointer.
    pub fn nw_proxy_config_enumerate_excluded_domains(
        config: NonNull<nw_proxy_config_t>,
        enumerator: nw_proxy_domain_enumerator_t,
    );
}

/// Create a new privacy context. This object can be added to connections and listeners
/// by setting the privacy context on the nw_parameters_t. Each privacy context can have
/// unique settings for logging and resolution, and implicitly has an isolated cache for
/// items like TLS sessions.
///
///
/// Parameter `description`: A string description used for logging.
///
///
/// Returns: Returns an allocated nw_privacy_context_t object on success.
///
/// # Safety
///
/// `description` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_privacy_context_create(
    description: NonNull<c_char>,
) -> NWRetained<nw_privacy_context_t> {
    extern "C-unwind" {
        fn nw_privacy_context_create(
            description: NonNull<c_char>,
        ) -> Option<NonNull<nw_privacy_context_t>>;
    }
    let ret = unsafe { nw_privacy_context_create(description) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/network/_nw_privacy_context_default_context?language=objc)
    pub static _nw_privacy_context_default_context: NonNull<nw_privacy_context_t>;
}

extern "C-unwind" {
    /// Flush any cached state stored in this privacy context. The act of flushing the
    /// cache may be asynchronous, which means that it will take effect shortly after the
    /// function is invoked.
    ///
    ///
    /// Parameter `privacy_context`: A privacy context to flush.
    ///
    /// # Safety
    ///
    /// `privacy_context` must be a valid pointer.
    pub fn nw_privacy_context_flush_cache(privacy_context: NonNull<nw_privacy_context_t>);
}

extern "C-unwind" {
    /// Disable logging for connections and listeners associated with this context. Logging
    /// may not be disabled on the default privacy context.
    ///
    ///
    /// Parameter `privacy_context`: A privacy context on which to disable logging.
    ///
    /// # Safety
    ///
    /// `privacy_context` must be a valid pointer.
    pub fn nw_privacy_context_disable_logging(privacy_context: NonNull<nw_privacy_context_t>);
}

extern "C-unwind" {
    /// Require that any DNS name resolution occurring for connections
    /// associated with this context use encrypted transports, such as TLS or HTTPS.
    /// Any unencrypted queries will be blocked if require_encrypted_name_resolution
    /// is set to true. Optionally, a fallback resolver config can be provided to use
    /// instead of blocking queries when require_encrypted_name_resolution is set to
    /// true.
    ///
    ///
    /// Parameter `privacy_context`: A privacy context to modify. This can include the default privacy context.
    ///
    ///
    /// Parameter `require_encrypted_name_resolution`: If true, require that any name resolution using DNS is performed
    /// with encryption. If false, allow cleartext resolution. Defaults to false.
    ///
    ///
    /// Parameter `fallback_resolver_config`: An optional resolver configuration to use if no other encrypted DNS resolver
    /// is already configured for the query. This will only take effect if
    /// require_encrypted_name_resolution is set to true. If this configuration is
    /// NULL and require_encrypted_name_resolution is set to true, all cleartext
    /// name resolution will be blocked.
    ///
    /// # Safety
    ///
    /// - `privacy_context` must be a valid pointer.
    /// - `fallback_resolver_config` must be a valid pointer or null.
    pub fn nw_privacy_context_require_encrypted_name_resolution(
        privacy_context: NonNull<nw_privacy_context_t>,
        require_encrypted_name_resolution: bool,
        fallback_resolver_config: *mut nw_resolver_config_t,
    );
}

extern "C-unwind" {
    /// Add a proxy configuration to apply to all connections that participate in this
    /// context. If set on `NW_DEFAULT_PRIVACY_CONTEXT`, this will additionally
    /// apply to other networking APIs used by the calling process.
    ///
    ///
    /// Parameter `privacy_context`: A privacy context to modify. This can include the default privacy context.
    ///
    ///
    /// Parameter `proxy_config`: A proxy configuration object to apply to all connections that use this context.
    ///
    /// # Safety
    ///
    /// - `privacy_context` must be a valid pointer.
    /// - `proxy_config` must be a valid pointer.
    pub fn nw_privacy_context_add_proxy(
        privacy_context: NonNull<nw_privacy_context_t>,
        proxy_config: NonNull<nw_proxy_config_t>,
    );
}

extern "C-unwind" {
    /// Clear out any proxies added using `nw_privacy_context_add_proxy`.
    ///
    ///
    /// Parameter `privacy_context`: A privacy context to modify. This can include the default privacy context.
    ///
    /// # Safety
    ///
    /// `privacy_context` must be a valid pointer.
    pub fn nw_privacy_context_clear_proxies(privacy_context: NonNull<nw_privacy_context_t>);
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_parameters_configure_protocol_block_t?language=objc)
pub type nw_parameters_configure_protocol_block_t =
    *mut block2::DynBlock<dyn Fn(NonNull<nw_protocol_options_t>)>;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/network/_nw_parameters_configure_protocol_default_configuration?language=objc)
    pub static _nw_parameters_configure_protocol_default_configuration:
        nw_parameters_configure_protocol_block_t;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/network/_nw_parameters_configure_protocol_disable?language=objc)
    pub static _nw_parameters_configure_protocol_disable: nw_parameters_configure_protocol_block_t;
}

/// Creates a parameters object that is configured for TLS and TCP. The caller can use
/// the default configuration for TLS and TCP, or set specific options for each protocol,
/// or disable TLS.
///
///
/// Parameter `configure_tls`: A block to configure TLS. To use the default TLS configuration, pass
/// NW_PARAMETERS_DEFAULT_CONFIGURATION. To configure specific options, pass a custom
/// block and operate on the nw_protocol_options_t object. To disable TLS, pass
/// NW_PARAMETERS_DISABLE_PROTOCOL.
///
///
/// Parameter `configure_tcp`: A block to configure TCP. To use the default TCP configuration, pass
/// NW_PARAMETERS_DEFAULT_CONFIGURATION. To configure specific options, pass a custom
/// block and operate on the nw_protocol_options_t object. It is invalid to try
/// to disable TCP using NW_PARAMETERS_DISABLE_PROTOCOL.
///
///
/// Returns: Returns an allocated nw_parameters_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
/// Returns NULL on failure. Fails due to invalid parameters.
///
/// # Safety
///
/// - `configure_tls` must be a valid pointer.
/// - `configure_tcp` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_parameters_create_secure_tcp(
    configure_tls: nw_parameters_configure_protocol_block_t,
    configure_tcp: nw_parameters_configure_protocol_block_t,
) -> NWRetained<nw_parameters_t> {
    extern "C-unwind" {
        fn nw_parameters_create_secure_tcp(
            configure_tls: nw_parameters_configure_protocol_block_t,
            configure_tcp: nw_parameters_configure_protocol_block_t,
        ) -> Option<NonNull<nw_parameters_t>>;
    }
    let ret = unsafe { nw_parameters_create_secure_tcp(configure_tls, configure_tcp) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Creates a parameters object that is configured for DTLS and UDP. The caller can use
/// the default configuration for DTLS and UDP, or set specific options for each protocol,
/// or disable DTLS.
///
///
/// Parameter `configure_dtls`: A block to configure DTLS. To use the default DTLS configuration, pass
/// NW_PARAMETERS_DEFAULT_CONFIGURATION. To configure specific options, pass a custom
/// block and operate on the nw_protocol_options_t object. To disable DTLS, pass
/// NW_PARAMETERS_DISABLE_PROTOCOL.
///
///
/// Parameter `configure_udp`: A block to configure UDP. To use the default UDP configuration, pass
/// NW_PARAMETERS_DEFAULT_CONFIGURATION. To configure specific options, pass a custom
/// block and operate on the nw_protocol_options_t object. It is invalid to try
/// to disable UDP using NW_PARAMETERS_DISABLE_PROTOCOL.
///
///
/// Returns: Returns an allocated nw_parameters_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
/// Returns NULL on failure. Fails due to invalid parameters.
///
/// # Safety
///
/// - `configure_dtls` must be a valid pointer.
/// - `configure_udp` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_parameters_create_secure_udp(
    configure_dtls: nw_parameters_configure_protocol_block_t,
    configure_udp: nw_parameters_configure_protocol_block_t,
) -> NWRetained<nw_parameters_t> {
    extern "C-unwind" {
        fn nw_parameters_create_secure_udp(
            configure_dtls: nw_parameters_configure_protocol_block_t,
            configure_udp: nw_parameters_configure_protocol_block_t,
        ) -> Option<NonNull<nw_parameters_t>>;
    }
    let ret = unsafe { nw_parameters_create_secure_udp(configure_dtls, configure_udp) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Creates a parameters object that is configured for a custom IP protocol.
/// This allows the caller to create connections and listeners that send
/// and receive IP datagrams where the protocol header contained by the IP
/// datagram is identified by the provided protocol number. Protocols already
/// registered by the system, such as TCP and UDP, will not be allowed.
///
/// Calling processes must hold the "com.apple.developer.networking.custom-protocol"
/// entitlement.
///
///
/// Parameter `custom_ip_protocol_number`: The protocol number identifying a protocol carried by IP, as defined
/// in RFC 5237.
///
///
/// Parameter `configure_ip`: A block to configure IP. To use the default IP configuration, pass
/// NW_PARAMETERS_DEFAULT_CONFIGURATION. To configure specific options, pass a custom
/// block and operate on the nw_protocol_options_t object. It is invalid to try
/// to disable IP using NW_PARAMETERS_DISABLE_PROTOCOL.
///
///
/// Returns: Returns an allocated nw_parameters_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
/// Returns NULL on failure. Fails due to invalid parameters.
///
/// # Safety
///
/// `configure_ip` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_parameters_create_custom_ip(
    custom_ip_protocol_number: u8,
    configure_ip: nw_parameters_configure_protocol_block_t,
) -> NWRetained<nw_parameters_t> {
    extern "C-unwind" {
        fn nw_parameters_create_custom_ip(
            custom_ip_protocol_number: u8,
            configure_ip: nw_parameters_configure_protocol_block_t,
        ) -> Option<NonNull<nw_parameters_t>>;
    }
    let ret = unsafe { nw_parameters_create_custom_ip(custom_ip_protocol_number, configure_ip) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Creates a parameters object that is configured for QUIC. The caller must
/// pass in a block to configure options.
///
///
/// Parameter `configure_quic`: A block to configure QUIC. The caller must pass a custom
/// block to configure the QUIC options.
///
///
/// Returns: Returns an allocated nw_parameters_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
/// Returns NULL on failure. Fails due to invalid parameters.
///
/// # Safety
///
/// `configure_quic` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_parameters_create_quic(
    configure_quic: nw_parameters_configure_protocol_block_t,
) -> NWRetained<nw_parameters_t> {
    extern "C-unwind" {
        fn nw_parameters_create_quic(
            configure_quic: nw_parameters_configure_protocol_block_t,
        ) -> Option<NonNull<nw_parameters_t>>;
    }
    let ret = unsafe { nw_parameters_create_quic(configure_quic) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Creates default parameters for use with application services.
///
///
/// Returns: Returns an allocated nw_parameters_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
#[inline]
pub extern "C-unwind" fn nw_parameters_create_application_service() -> NWRetained<nw_parameters_t> {
    extern "C-unwind" {
        fn nw_parameters_create_application_service() -> Option<NonNull<nw_parameters_t>>;
    }
    let ret = unsafe { nw_parameters_create_application_service() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Creates a generic parameters object. Note that in order to use parameters
/// with an nw_connection_t or an nw_listener_t, the parameters must have protocols
/// added into the default nw_protocol_stack_t. Clients using standard protocol
/// configurations should use nw_parameters_create_secure_tcp() or
/// nw_parameters_create_secure_udp().
///
///
/// Returns: Returns an allocated nw_parameters_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
#[inline]
pub extern "C-unwind" fn nw_parameters_create() -> NWRetained<nw_parameters_t> {
    extern "C-unwind" {
        fn nw_parameters_create() -> Option<NonNull<nw_parameters_t>>;
    }
    let ret = unsafe { nw_parameters_create() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Creates a deep copy of a parameters object that can be modified.
///
///
/// Parameter `parameters`: The existing parameters object to copy
///
///
/// Returns: Returns a newly allocated nw_parameters_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
/// Returns NULL on failure. Fails due to invalid parameters.
///
/// # Safety
///
/// `parameters` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_parameters_copy(
    parameters: NonNull<nw_parameters_t>,
) -> NWRetained<nw_parameters_t> {
    extern "C-unwind" {
        fn nw_parameters_copy(
            parameters: NonNull<nw_parameters_t>,
        ) -> Option<NonNull<nw_parameters_t>>;
    }
    let ret = unsafe { nw_parameters_copy(parameters) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Set a privacy context on the parameters, which will be associated
    /// with connections and listeners. The privacy context allows
    /// using separate caches for different sets of connections, as well as
    /// restricting how connection-specific information is logged and shared
    /// on the network.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `privacy_context`: The privacy context to associate with connections and listeners that use
    /// these parameters.
    ///
    /// # Safety
    ///
    /// - `parameters` must be a valid pointer.
    /// - `privacy_context` must be a valid pointer.
    pub fn nw_parameters_set_privacy_context(
        parameters: NonNull<nw_parameters_t>,
        privacy_context: NonNull<nw_privacy_context_t>,
    );
}

/// Attribution values can be used to indicate who determined the network content being accessed.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_parameters_attribution_t?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_parameters_attribution_t(pub u8);
impl nw_parameters_attribution_t {
    #[doc(alias = "nw_parameters_attribution_developer")]
    pub const developer: Self = Self(1);
    #[doc(alias = "nw_parameters_attribution_user")]
    pub const user: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_parameters_attribution_t {
    const ENCODING: Encoding = u8::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_parameters_attribution_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// In order to help differentiate communication with domains requested by the user from those requested by the
    /// developer, attribution may be used. Attribution defaults to nw_parameters_attribution_developer. Setting
    /// attribution to nw_parameters_attribution_user indicates that the networking performed using these parameters
    /// is directed to content specified by the user, not the developer.
    ///
    ///
    /// Parameter `parameters`: The parameters to modify.
    ///
    ///
    /// Parameter `attribution`: The entity to attribute the network operations to.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_set_attribution(
        parameters: NonNull<nw_parameters_t>,
        attribution: nw_parameters_attribution_t,
    );
}

extern "C-unwind" {
    /// Returns the attribution set on the parameters.
    ///
    ///
    /// Parameter `parameters`: The parameters to check.
    ///
    ///
    /// Returns: Returns the attribution property of the parameters.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_get_attribution(
        parameters: NonNull<nw_parameters_t>,
    ) -> nw_parameters_attribution_t;
}

extern "C-unwind" {
    /// Require any connections or listeners using these parameters to use
    /// the provided network interface, or none if NULL is passed.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `interface`: The interface to require for connections or listeners, or NULL to
    /// allow any interface.
    ///
    /// # Safety
    ///
    /// - `parameters` must be a valid pointer.
    /// - `interface` must be a valid pointer or null.
    pub fn nw_parameters_require_interface(
        parameters: NonNull<nw_parameters_t>,
        interface: *mut nw_interface_t,
    );
}

/// Access the required network interface set on the parameters.
///
///
/// Parameter `parameters`: The parameters object to check
///
///
/// Returns: Returns the interface that is required by the parameters, or
/// NULL if no interface is required.
///
/// # Safety
///
/// `parameters` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_parameters_copy_required_interface(
    parameters: NonNull<nw_parameters_t>,
) -> Option<NWRetained<nw_interface_t>> {
    extern "C-unwind" {
        fn nw_parameters_copy_required_interface(
            parameters: NonNull<nw_parameters_t>,
        ) -> Option<NonNull<nw_interface_t>>;
    }
    let ret = unsafe { nw_parameters_copy_required_interface(parameters) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Prohibit any connections or listeners using these parameters from using
    /// the provided network interface.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `interface`: The interface to prohibit for connections or listeners.
    ///
    /// # Safety
    ///
    /// - `parameters` must be a valid pointer.
    /// - `interface` must be a valid pointer.
    pub fn nw_parameters_prohibit_interface(
        parameters: NonNull<nw_parameters_t>,
        interface: NonNull<nw_interface_t>,
    );
}

extern "C-unwind" {
    /// Clear any interfaces that had been prohibited.
    ///
    ///
    /// Parameter `parameters`: The parameters object to modify
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_clear_prohibited_interfaces(parameters: NonNull<nw_parameters_t>);
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_parameters_iterate_interfaces_block_t?language=objc)
pub type nw_parameters_iterate_interfaces_block_t =
    *mut block2::DynBlock<dyn Fn(NonNull<nw_interface_t>) -> bool>;

extern "C-unwind" {
    /// List all prohibited network interfaces.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Parameter `iterate_block`: A block that will return the interfaces prohibited by the parameters. Returning
    /// true from the block will continue to iterate, and returning false will stop
    /// iterating.
    ///
    /// # Safety
    ///
    /// - `parameters` must be a valid pointer.
    /// - `iterate_block` must be a valid pointer.
    pub fn nw_parameters_iterate_prohibited_interfaces(
        parameters: NonNull<nw_parameters_t>,
        iterate_block: nw_parameters_iterate_interfaces_block_t,
    );
}

extern "C-unwind" {
    /// Require any connections or listeners using these parameters to use
    /// the provided network interface type.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `interface_type`: The interface type to require for connections or listeners.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_set_required_interface_type(
        parameters: NonNull<nw_parameters_t>,
        interface_type: nw_interface_type_t,
    );
}

extern "C-unwind" {
    /// Access the required network interface type set on the parameters.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns the interface type that is required by the parameters, or
    /// nw_interface_type_other_t if no interface type is required.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_get_required_interface_type(
        parameters: NonNull<nw_parameters_t>,
    ) -> nw_interface_type_t;
}

extern "C-unwind" {
    /// Prohibit any connections or listeners using these parameters from using
    /// the provided network interface type.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `interface_type`: The interface type to prohibit for connections or listeners.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_prohibit_interface_type(
        parameters: NonNull<nw_parameters_t>,
        interface_type: nw_interface_type_t,
    );
}

extern "C-unwind" {
    /// Clear any interface types that had been prohibited.
    ///
    ///
    /// Parameter `parameters`: The parameters object to modify
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_clear_prohibited_interface_types(parameters: NonNull<nw_parameters_t>);
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_parameters_iterate_interface_types_block_t?language=objc)
pub type nw_parameters_iterate_interface_types_block_t =
    *mut block2::DynBlock<dyn Fn(nw_interface_type_t) -> bool>;

extern "C-unwind" {
    /// List all prohibited network interface types.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Parameter `iterate_block`: A block that will return the interface types prohibited by the parameters. Returning
    /// true from the block will continue to iterate, and returning false will stop
    /// iterating.
    ///
    /// # Safety
    ///
    /// - `parameters` must be a valid pointer.
    /// - `iterate_block` must be a valid pointer.
    pub fn nw_parameters_iterate_prohibited_interface_types(
        parameters: NonNull<nw_parameters_t>,
        iterate_block: nw_parameters_iterate_interface_types_block_t,
    );
}

extern "C-unwind" {
    /// Prohibit any connections or listeners using these parameters from using
    /// a network interface that is considered expensive by the system.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `prohibit_expensive`: If true, prohibit the use of any expensive interfaces. If false,
    /// allow expensive interfaces. Defaults to false.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_set_prohibit_expensive(
        parameters: NonNull<nw_parameters_t>,
        prohibit_expensive: bool,
    );
}

extern "C-unwind" {
    /// Check if the parameters prohibit expensive interfaces.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns true if expensive interfaces are prohibited, or
    /// false otherwise.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_get_prohibit_expensive(parameters: NonNull<nw_parameters_t>) -> bool;
}

extern "C-unwind" {
    /// Prohibit any connections or listeners using these parameters from using
    /// a network interface that is considered constrained by the system.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `prohibit_constrained`: If true, prohibit the use of any constrained interfaces. If false,
    /// allow constrained interfaces. Defaults to false.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_set_prohibit_constrained(
        parameters: NonNull<nw_parameters_t>,
        prohibit_constrained: bool,
    );
}

extern "C-unwind" {
    /// Check if the parameters prohibit constrained interfaces.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns true if constrained interfaces are prohibited, or
    /// false otherwise.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_get_prohibit_constrained(parameters: NonNull<nw_parameters_t>) -> bool;
}

extern "C-unwind" {
    /// Allow any connections using these parameters to reuse
    /// local addresses already in use by other connections.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `reuse_local_address`: If true, allow the reuse of local addresses. If false,
    /// disallow the reuse of local addresses. Defaults to false.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_set_reuse_local_address(
        parameters: NonNull<nw_parameters_t>,
        reuse_local_address: bool,
    );
}

extern "C-unwind" {
    /// Check if the parameters allow local address reuse.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns true if local address reuse is allowed, or
    /// false otherwise.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_get_reuse_local_address(parameters: NonNull<nw_parameters_t>) -> bool;
}

extern "C-unwind" {
    /// Specify a specific endpoint to use as the local endpoint.
    /// For connections, this will be used to initiate traffic;
    /// for listeners, this will be used for receiving incoming
    /// connections.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `local_endpoint`: The endpoint to set as the local endpoint. Pass NULL to
    /// clear the local endpoint.
    ///
    /// # Safety
    ///
    /// - `parameters` must be a valid pointer.
    /// - `local_endpoint` must be a valid pointer or null.
    pub fn nw_parameters_set_local_endpoint(
        parameters: NonNull<nw_parameters_t>,
        local_endpoint: *mut nw_endpoint_t,
    );
}

/// Extract the local endpoint set on the connection.
///
///
/// Parameter `parameters`: The parameters object to configure
///
///
/// Returns: Returns the endpoint that is set in the parameters, or
/// NULL if no local endpoint is set.
///
/// # Safety
///
/// `parameters` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_parameters_copy_local_endpoint(
    parameters: NonNull<nw_parameters_t>,
) -> Option<NWRetained<nw_endpoint_t>> {
    extern "C-unwind" {
        fn nw_parameters_copy_local_endpoint(
            parameters: NonNull<nw_parameters_t>,
        ) -> Option<NonNull<nw_endpoint_t>>;
    }
    let ret = unsafe { nw_parameters_copy_local_endpoint(parameters) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Allow the inclusion of peer-to-peer interfaces when
    /// listening or establishing outbound connections. This parameter
    /// will not take effect if a specific interface is required.
    /// This parameter is applicable when advertising a Bonjour service
    /// on a listener, or connecting to a Bonjour service.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `include_peer_to_peer`: If true, allow advertising, resolving, and connecting over
    /// peer-to-peer interfaces. Defaults to false.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_set_include_peer_to_peer(
        parameters: NonNull<nw_parameters_t>,
        include_peer_to_peer: bool,
    );
}

extern "C-unwind" {
    /// Check if the parameters allow the inclusion of
    /// peer-to-peer interfaces.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns true if peer-to-peer interfaces are allowed,
    /// or false otherwise.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_get_include_peer_to_peer(parameters: NonNull<nw_parameters_t>) -> bool;
}

extern "C-unwind" {
    /// Use fast open for an outbound connection, which may be done at any
    /// protocol level. Use of fast open requires that the caller send
    /// idempotent data on the connection before the connection may move
    /// into the ready state. As a side effect, this may implicitly enable
    /// fast open or early data for protocols in the stack, even if they did not
    /// have fast open explicitly enabled on them (such as the option to enable
    /// TCP Fast Open).
    ///
    /// NOTE: Use of this API may have security implications for application data.
    /// In particular, TLS early data is replayable by a network attacker. Callers must
    /// account for this when sending data before the handshake is confirmed. See
    /// RFC 8446 for more information. Callers MUST NOT enable fast open without
    /// a specific application profile that defines its use.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `fast_open_enabled`: If true, indicate that fast open is requested and that idempotent data
    /// MUST be sent by the caller on the connection. If false,
    /// disallow the fast open at the top level protocol. Defaults to false.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_set_fast_open_enabled(
        parameters: NonNull<nw_parameters_t>,
        fast_open_enabled: bool,
    );
}

extern "C-unwind" {
    /// Check if the parameters allow the use of fast open for the top level
    /// protocol.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns true if fast open is allowed for the top level protocol, or
    /// false otherwise.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_get_fast_open_enabled(parameters: NonNull<nw_parameters_t>) -> bool;
}

/// The network service class represents the network queuing priority to use
/// for traffic generated by a connection.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_service_class_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_service_class_t(pub c_uint);
impl nw_service_class_t {
    #[doc(alias = "nw_service_class_best_effort")]
    pub const best_effort: Self = Self(0);
    #[doc(alias = "nw_service_class_background")]
    pub const background: Self = Self(1);
    #[doc(alias = "nw_service_class_interactive_video")]
    pub const interactive_video: Self = Self(2);
    #[doc(alias = "nw_service_class_interactive_voice")]
    pub const interactive_voice: Self = Self(3);
    #[doc(alias = "nw_service_class_responsive_data")]
    pub const responsive_data: Self = Self(4);
    #[doc(alias = "nw_service_class_signaling")]
    pub const signaling: Self = Self(5);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_service_class_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_service_class_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Set the data service class to use for connections.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `service_class`: The service class value to use for connections. Defaults to nw_service_class_best_effort.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_set_service_class(
        parameters: NonNull<nw_parameters_t>,
        service_class: nw_service_class_t,
    );
}

extern "C-unwind" {
    /// Check the service class configured on the parameters.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns the effective service class configured on the parameters.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_get_service_class(
        parameters: NonNull<nw_parameters_t>,
    ) -> nw_service_class_t;
}

/// Multipath services represent the modes of multipath usage that are
/// allowed for connections.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_multipath_service_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_multipath_service_t(pub c_uint);
impl nw_multipath_service_t {
    #[doc(alias = "nw_multipath_service_disabled")]
    pub const disabled: Self = Self(0);
    #[doc(alias = "nw_multipath_service_handover")]
    pub const handover: Self = Self(1);
    #[doc(alias = "nw_multipath_service_interactive")]
    pub const interactive: Self = Self(2);
    #[doc(alias = "nw_multipath_service_aggregate")]
    pub const aggregate: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_multipath_service_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_multipath_service_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Set the multipath service to use for connections.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `multipath_service`: The multipath service value to use for connections. Defaults to nw_multipath_service_disabled.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_set_multipath_service(
        parameters: NonNull<nw_parameters_t>,
        multipath_service: nw_multipath_service_t,
    );
}

extern "C-unwind" {
    /// Check the multipath service mode configured on the parameters.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns the multipath service configured on the parameters.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_get_multipath_service(
        parameters: NonNull<nw_parameters_t>,
    ) -> nw_multipath_service_t;
}

/// Retrieve the default protocol stack from a parameters object.
/// Every parameters object will have a default protocol stack. For
/// parameters created with a convenience initializer, this protocol
/// stack will be pre-populated. For parameters created with the generic
/// initializers, the stack will be empty.
///
///
/// Parameter `parameters`: The parameters object to check
///
///
/// Returns: Returns an nw_protocol_stack_t object that can be inspected and modified.
///
/// # Safety
///
/// `parameters` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_parameters_copy_default_protocol_stack(
    parameters: NonNull<nw_parameters_t>,
) -> NWRetained<nw_protocol_stack_t> {
    extern "C-unwind" {
        fn nw_parameters_copy_default_protocol_stack(
            parameters: NonNull<nw_parameters_t>,
        ) -> Option<NonNull<nw_protocol_stack_t>>;
    }
    let ret = unsafe { nw_parameters_copy_default_protocol_stack(parameters) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Prepend an application-layer protocol onto the top of a protocol stack.
    ///
    ///
    /// Parameter `stack`: The protocol stack to modify
    ///
    ///
    /// Parameter `protocol`: The protocol options to add to the stack, which contain the definition of the
    /// protocol to add.
    ///
    /// # Safety
    ///
    /// - `stack` must be a valid pointer.
    /// - `protocol` must be a valid pointer.
    pub fn nw_protocol_stack_prepend_application_protocol(
        stack: NonNull<nw_protocol_stack_t>,
        protocol: NonNull<nw_protocol_options_t>,
    );
}

extern "C-unwind" {
    /// Remove all application-layer protocols from a protocol stack.
    ///
    ///
    /// Parameter `stack`: The protocol stack to modify
    ///
    /// # Safety
    ///
    /// `stack` must be a valid pointer.
    pub fn nw_protocol_stack_clear_application_protocols(stack: NonNull<nw_protocol_stack_t>);
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_protocol_stack_iterate_protocols_block_t?language=objc)
pub type nw_protocol_stack_iterate_protocols_block_t =
    *mut block2::DynBlock<dyn Fn(NonNull<nw_protocol_options_t>)>;

extern "C-unwind" {
    /// List all application protocols attached to a protocol stack.
    ///
    ///
    /// Parameter `stack`: The protocol stack to check
    ///
    ///
    /// Parameter `iterate_block`: A block that will return the protocols attached to the stack.
    ///
    /// # Safety
    ///
    /// - `stack` must be a valid pointer.
    /// - `iterate_block` must be a valid pointer.
    pub fn nw_protocol_stack_iterate_application_protocols(
        stack: NonNull<nw_protocol_stack_t>,
        iterate_block: nw_protocol_stack_iterate_protocols_block_t,
    );
}

/// Access the transport-layer protocol used in a protocol stack.
///
///
/// Parameter `stack`: The protocol stack to check
///
///
/// Returns: Returns the transport protocol currently set in the protocol stack,
/// or NULL if no transport protocol is set.
///
/// # Safety
///
/// `stack` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_protocol_stack_copy_transport_protocol(
    stack: NonNull<nw_protocol_stack_t>,
) -> Option<NWRetained<nw_protocol_options_t>> {
    extern "C-unwind" {
        fn nw_protocol_stack_copy_transport_protocol(
            stack: NonNull<nw_protocol_stack_t>,
        ) -> Option<NonNull<nw_protocol_options_t>>;
    }
    let ret = unsafe { nw_protocol_stack_copy_transport_protocol(stack) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Set the transport-layer protocol to use for a protocol stack.
    ///
    ///
    /// Parameter `stack`: The protocol stack to modify
    ///
    ///
    /// Parameter `protocol`: The protocol options to set into the stack, which contain the definition of the
    /// protocol.
    ///
    /// # Safety
    ///
    /// - `stack` must be a valid pointer.
    /// - `protocol` must be a valid pointer.
    pub fn nw_protocol_stack_set_transport_protocol(
        stack: NonNull<nw_protocol_stack_t>,
        protocol: NonNull<nw_protocol_options_t>,
    );
}

/// Access the internet-layer protocol used in a protocol stack.
///
///
/// Parameter `stack`: The protocol stack to check
///
///
/// Returns: Returns the internet protocol currently set in the protocol stack,
/// or NULL if no internet protocol is set. Note that this will generally
/// be NULL, unless a specific IP family is being selected.
///
/// # Safety
///
/// `stack` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_protocol_stack_copy_internet_protocol(
    stack: NonNull<nw_protocol_stack_t>,
) -> Option<NWRetained<nw_protocol_options_t>> {
    extern "C-unwind" {
        fn nw_protocol_stack_copy_internet_protocol(
            stack: NonNull<nw_protocol_stack_t>,
        ) -> Option<NonNull<nw_protocol_options_t>>;
    }
    let ret = unsafe { nw_protocol_stack_copy_internet_protocol(stack) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Set to true to limit inbound connections to peers attached to the
    /// local link only. Defaults to false.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `local_only`: True to limit connections to the local link only.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_set_local_only(parameters: NonNull<nw_parameters_t>, local_only: bool);
}

extern "C-unwind" {
    /// Indicates whether or not the parameters limit connections to the local
    /// link only.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns true if the parameters limit inbound connections to the local link.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_get_local_only(parameters: NonNull<nw_parameters_t>) -> bool;
}

extern "C-unwind" {
    /// Set to true to attempt connections without using proxies, only using any configured proxies if the connections
    /// cannot otherwise be completed. Defaults to false.
    ///
    ///
    /// Parameter `parameters`: The parameters to modify.
    ///
    ///
    /// Parameter `prefer_no_proxy`: True to cause connections to be attempted without proxies.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_set_prefer_no_proxy(
        parameters: NonNull<nw_parameters_t>,
        prefer_no_proxy: bool,
    );
}

extern "C-unwind" {
    /// Indicates whether or not the parameters cause connections to be attempted without proxies, only using proxies
    /// if connections cannot otherwise be completed.
    ///
    ///
    /// Parameter `parameters`: The parameters to get the property from.
    ///
    ///
    /// Returns: Returns true if the parameters cause connections to be attempted without proxies, only using proxies if
    /// connections cannot otherwise be completed.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_get_prefer_no_proxy(parameters: NonNull<nw_parameters_t>) -> bool;
}

/// Expired DNS behavior defines whether or not a connection will allow the use
/// of expired DNS answers during connection establishment.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_parameters_expired_dns_behavior_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_parameters_expired_dns_behavior_t(pub c_uint);
impl nw_parameters_expired_dns_behavior_t {
    #[doc(alias = "nw_parameters_expired_dns_behavior_default")]
    pub const default: Self = Self(0);
    #[doc(alias = "nw_parameters_expired_dns_behavior_allow")]
    pub const allow: Self = Self(1);
    #[doc(alias = "nw_parameters_expired_dns_behavior_prohibit")]
    pub const prohibit: Self = Self(2);
    /// This should only be set for hostnames whose resolutions are not expected to change across networks.
    #[doc(alias = "nw_parameters_expired_dns_behavior_persistent")]
    pub const persistent: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_parameters_expired_dns_behavior_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_parameters_expired_dns_behavior_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Allow or prohibit the use of expired DNS answers during connection establishment.
    /// If allowed, a DNS answer that was previously returned may be re-used for new
    /// connections even after the answers are considered expired. A query for fresh answers
    /// will be sent in parallel, and the fresh answers will be used as alternate addresses
    /// in case the expired answers do not result in successful connections.
    ///
    /// By default, this value is nw_parameters_expired_dns_behavior_default, which allows
    /// the system to determine if it is appropriate to use expired answers.
    ///
    ///
    /// Parameter `parameters`: The parameters to modify.
    ///
    ///
    /// Parameter `expired_dns_behavior`: Allow, prohibit, or use system default behavior for expired DNS answers.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_set_expired_dns_behavior(
        parameters: NonNull<nw_parameters_t>,
        expired_dns_behavior: nw_parameters_expired_dns_behavior_t,
    );
}

extern "C-unwind" {
    /// Check the effective expired DNS behavior of a connection.
    /// See nw_parameters_set_expired_dns_behavior() for a discussion on the use of expired
    /// DNS answers.
    ///
    ///
    /// Parameter `parameters`: The parameters to check.
    ///
    ///
    /// Returns: Returns the current effective expired DNS answer behavior.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_get_expired_dns_behavior(
        parameters: NonNull<nw_parameters_t>,
    ) -> nw_parameters_expired_dns_behavior_t;
}

extern "C-unwind" {
    /// Require to do or not to do DNSSEC validation when resolving the endpoint, before
    /// making a connection.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure.
    ///
    ///
    /// Parameter `requires_dnssec_validation`: A boolean value that indicates if DNSSEC validation should be required
    /// when doing DNS resolution for the endpoint.
    ///
    ///
    /// DNSSEC validation only takes effect if making a connection to an
    /// endpoint that requires domain name resolution, such as:
    /// <code>
    /// nw_endpoint_type_host
    /// </code>
    /// <code>
    /// nw_endpoint_type_url
    /// </code>
    ///
    /// 1. If this property is not set or is set to false on the parameters, DNSSEC
    /// validation will not be required.
    ///
    /// 2. If this property is set to true and no additional DNSSEC
    /// configuration is set on the parameters, the default behavior will be
    /// followed: Only DNSSEC secure and DNSSEC insecure resolved result will be
    /// used to establish a connection.
    ///
    /// 3. If this property is set to true and additional DNSSEC configuration
    /// is set on the parameters, the behavior specified by that configuration
    /// will be followed.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_set_requires_dnssec_validation(
        parameters: NonNull<nw_parameters_t>,
        requires_dnssec_validation: bool,
    );
}

extern "C-unwind" {
    /// Check if DNSSEC validation is required.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check.
    ///
    ///
    /// Returns: Returns true if DNSSEC validation is required, false otherwise.
    ///
    /// # Safety
    ///
    /// `parameters` must be a valid pointer.
    pub fn nw_parameters_requires_dnssec_validation(parameters: NonNull<nw_parameters_t>) -> bool;
}

/// Creates a new browse descriptor object on a Bonjour service type and
/// domain.
///
///
/// Parameter `type`: A Bonjour service type.
///
///
/// Parameter `domain`: An optional Bonjour service domain. If the domain is unspecified, the
/// default domains for browsing will be used.
///
///
/// Returns: An instantiated browse descriptor object.
///
/// # Safety
///
/// - `type` must be a valid pointer.
/// - `domain` must be a valid pointer or null.
#[inline]
pub unsafe extern "C-unwind" fn nw_browse_descriptor_create_bonjour_service(
    r#type: NonNull<c_char>,
    domain: *const c_char,
) -> NWRetained<nw_browse_descriptor_t> {
    extern "C-unwind" {
        fn nw_browse_descriptor_create_bonjour_service(
            r#type: NonNull<c_char>,
            domain: *const c_char,
        ) -> Option<NonNull<nw_browse_descriptor_t>>;
    }
    let ret = unsafe { nw_browse_descriptor_create_bonjour_service(r#type, domain) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Returns the service type of a browse descriptor.
///
///
/// Parameter `descriptor`: A browse descriptor object.
///
///
/// Returns: The service type.
///
/// # Safety
///
/// `descriptor` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_browse_descriptor_get_bonjour_service_type(
    descriptor: NonNull<nw_browse_descriptor_t>,
) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_browse_descriptor_get_bonjour_service_type(
            descriptor: NonNull<nw_browse_descriptor_t>,
        ) -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_browse_descriptor_get_bonjour_service_type(descriptor) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

extern "C-unwind" {
    /// Returns the service domain of a browse descriptor, or NULL if NULL was
    /// provided while creating the descriptor.
    ///
    ///
    /// Parameter `descriptor`: A browse descriptor object.
    ///
    ///
    /// Returns: The service domain.
    ///
    /// # Safety
    ///
    /// `descriptor` must be a valid pointer.
    pub fn nw_browse_descriptor_get_bonjour_service_domain(
        descriptor: NonNull<nw_browse_descriptor_t>,
    ) -> *const c_char;
}

extern "C-unwind" {
    /// Set a flag to allow or prohibit the browser from querying for TXT records
    /// while browsing. This flag should only be set if the client needs information
    /// from the TXT record during browsing, and may increase network traffic. By
    /// default, the browser will not automatically query for TXT records.
    ///
    ///
    /// Parameter `descriptor`: The browse descriptor object.
    ///
    ///
    /// Parameter `include_txt_record`: A flag indicating whether results should include a TXT record. If true,
    /// the browser will query for TXT records. If false, the browser will not
    /// query for TXT records.
    ///
    /// # Safety
    ///
    /// `descriptor` must be a valid pointer.
    pub fn nw_browse_descriptor_set_include_txt_record(
        descriptor: NonNull<nw_browse_descriptor_t>,
        include_txt_record: bool,
    );
}

extern "C-unwind" {
    /// Check whether the browser is allowed to query for TXT records.
    ///
    ///
    /// Parameter `descriptor`: The browse descriptor to check.
    ///
    ///
    /// Returns: Whether the browser is allowed to query for TXT records.
    ///
    /// # Safety
    ///
    /// `descriptor` must be a valid pointer.
    pub fn nw_browse_descriptor_get_include_txt_record(
        descriptor: NonNull<nw_browse_descriptor_t>,
    ) -> bool;
}

/// Creates a browse descriptor for application service discovery.
///
///
/// Parameter `application_service_name`: The service name to browse for.
///
///
/// Returns: An instantiated browse descriptor object.
///
/// # Safety
///
/// `application_service_name` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_browse_descriptor_create_application_service(
    application_service_name: NonNull<c_char>,
) -> NWRetained<nw_browse_descriptor_t> {
    extern "C-unwind" {
        fn nw_browse_descriptor_create_application_service(
            application_service_name: NonNull<c_char>,
        ) -> Option<NonNull<nw_browse_descriptor_t>>;
    }
    let ret = unsafe { nw_browse_descriptor_create_application_service(application_service_name) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Returns the service name of an application service browse descriptor.
    ///
    ///
    /// Parameter `descriptor`: A browse descriptor object.
    ///
    ///
    /// Returns: The service name.
    ///
    /// # Safety
    ///
    /// `descriptor` must be a valid pointer.
    pub fn nw_browse_descriptor_get_application_service_name(
        descriptor: NonNull<nw_browse_descriptor_t>,
    ) -> *const c_char;
}

/// A nw_browse_result_change_t describes all changes that occurred between
/// two browse results. Call nw_browse_result_get_changes() to get the
/// changes between an old and a new browse result.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_t?language=objc)
pub type nw_browse_result_change_t = u64;

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_invalid?language=objc)
pub const nw_browse_result_change_invalid: c_uint = 0x00;
/// are identical.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_identical?language=objc)
pub const nw_browse_result_change_identical: c_uint = 0x01;
/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_result_added?language=objc)
pub const nw_browse_result_change_result_added: c_uint = 0x02;
/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_result_removed?language=objc)
pub const nw_browse_result_change_result_removed: c_uint = 0x04;
/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_interface_added?language=objc)
pub const nw_browse_result_change_interface_added: c_uint = 0x08;
/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_interface_removed?language=objc)
pub const nw_browse_result_change_interface_removed: c_uint = 0x10;
/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_txt_record_changed?language=objc)
pub const nw_browse_result_change_txt_record_changed: c_uint = 0x20;

/// Copies the endpoint associated with the browse result object.
///
///
/// Parameter `result`: The browse result object.
///
///
/// Returns: The associated endpoint.
///
/// # Safety
///
/// `result` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_browse_result_copy_endpoint(
    result: NonNull<nw_browse_result_t>,
) -> NWRetained<nw_endpoint_t> {
    extern "C-unwind" {
        fn nw_browse_result_copy_endpoint(
            result: NonNull<nw_browse_result_t>,
        ) -> Option<NonNull<nw_endpoint_t>>;
    }
    let ret = unsafe { nw_browse_result_copy_endpoint(result) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Determines the set of all changes that occurred between an old and a new
    /// browse result. For example, if the return value of this function matches
    /// with nw_browse_result_change_interface_added and nw_browse_result_change_txt_record_changed,
    /// the caller can expect new_result to include a new interface and an updated
    /// txt record that was not present in old_result.
    ///
    ///
    /// Parameter `old_result`: The old result.
    ///
    ///
    /// Parameter `new_result`: The new result.
    ///
    ///
    /// Returns: A nw_browse_result_change_t describing all changes that occurred.
    ///
    /// # Safety
    ///
    /// - `old_result` must be a valid pointer or null.
    /// - `new_result` must be a valid pointer or null.
    pub fn nw_browse_result_get_changes(
        old_result: *mut nw_browse_result_t,
        new_result: *mut nw_browse_result_t,
    ) -> nw_browse_result_change_t;
}

extern "C-unwind" {
    /// Returns the number of interfaces on this browse result.
    ///
    ///
    /// Parameter `result`: The browse result object.
    ///
    ///
    /// Returns: The number of interfaces available.
    ///
    /// # Safety
    ///
    /// `result` must be a valid pointer.
    pub fn nw_browse_result_get_interfaces_count(result: NonNull<nw_browse_result_t>) -> usize;
}

/// Copies the TXT record object from the browse result.
///
///
/// Parameter `result`: The browse result object.
///
///
/// Returns: A copy of the TXT record object, or NULL if the browse result does not
/// have an associated TXT record.
///
/// # Safety
///
/// `result` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_browse_result_copy_txt_record_object(
    result: NonNull<nw_browse_result_t>,
) -> Option<NWRetained<nw_txt_record_t>> {
    extern "C-unwind" {
        fn nw_browse_result_copy_txt_record_object(
            result: NonNull<nw_browse_result_t>,
        ) -> Option<NonNull<nw_txt_record_t>>;
    }
    let ret = unsafe { nw_browse_result_copy_txt_record_object(result) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

/// A block that can be applied to every interface in the browse result.
///
///
/// Parameter `interface`: The interface object.
///
///
/// Returns: A boolean value that indicating if enumeration should continue.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_enumerate_interface_t?language=objc)
pub type nw_browse_result_enumerate_interface_t =
    *mut block2::DynBlock<dyn Fn(NonNull<nw_interface_t>) -> bool>;

extern "C-unwind" {
    /// Enumerates the list of interfaces on this browse result.
    ///
    ///
    /// Parameter `result`: The browse result object.
    ///
    ///
    /// Parameter `enumerator`: The enumerator block.
    ///
    /// # Safety
    ///
    /// - `result` must be a valid pointer.
    /// - `enumerator` must be a valid pointer.
    pub fn nw_browse_result_enumerate_interfaces(
        result: NonNull<nw_browse_result_t>,
        enumerator: nw_browse_result_enumerate_interface_t,
    );
}

/// The enumeration of network error domains.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_error_domain_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_error_domain_t(pub c_uint);
impl nw_error_domain_t {
    #[doc(alias = "nw_error_domain_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_error_domain_posix")]
    pub const posix: Self = Self(1);
    #[doc(alias = "nw_error_domain_dns")]
    pub const dns: Self = Self(2);
    #[doc(alias = "nw_error_domain_tls")]
    pub const tls: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_error_domain_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_error_domain_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Given a reference to a nw_error, returns the error domain.
    ///
    ///
    /// Parameter `error`: A reference to the nw_error.
    ///
    ///
    /// Returns: The error domain.
    ///
    /// # Safety
    ///
    /// `error` must be a valid pointer.
    pub fn nw_error_get_error_domain(error: NonNull<nw_error_t>) -> nw_error_domain_t;
}

extern "C-unwind" {
    /// Given a reference to a nw_error, returns the error code.
    ///
    ///
    /// Parameter `error`: A reference to the nw_error.
    ///
    ///
    /// Returns: The error code.
    ///
    /// # Safety
    ///
    /// `error` must be a valid pointer.
    pub fn nw_error_get_error_code(error: NonNull<nw_error_t>) -> c_int;
}

extern "C" {
    /// CFErrorRef domain corresponding to nw_error_domain_posix.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/network/knwerrordomainposix?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kNWErrorDomainPOSIX: &'static CFString;
}

extern "C" {
    /// CFErrorRef domain corresponding to nw_error_domain_posix.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/network/knwerrordomaindns?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kNWErrorDomainDNS: &'static CFString;
}

extern "C" {
    /// CFErrorRef domain corresponding to nw_error_domain_tls.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/network/knwerrordomaintls?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kNWErrorDomainTLS: &'static CFString;
}

/// Given a reference to nw_error, returns a CFErrorRef representing the same error.
///
///
/// Parameter `error`: A reference to the nw_error.
///
///
/// Returns: The CFErrorRef. The caller is responsible for calling CFRelease on the returned value.
///
/// # Safety
///
/// `error` must be a valid pointer.
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub unsafe extern "C-unwind" fn nw_error_copy_cf_error(
    error: NonNull<nw_error_t>,
) -> CFRetained<CFError> {
    extern "C-unwind" {
        fn nw_error_copy_cf_error(error: NonNull<nw_error_t>) -> Option<NonNull<CFError>>;
    }
    let ret = unsafe { nw_error_copy_cf_error(error) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

/// Browser states sent by nw_browser_set_state_changed_handler.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_browser_state_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_browser_state_t(pub c_uint);
impl nw_browser_state_t {
    /// This state will never be delivered in the browser's state update
    /// handler and can be treated as an unexpected value.
    #[doc(alias = "nw_browser_state_invalid")]
    pub const invalid: Self = Self(0);
    /// endpoint updates. All callbacks from the browse_results_changed_handler
    /// occur when the browser is in this state.
    #[doc(alias = "nw_browser_state_ready")]
    pub const ready: Self = Self(1);
    /// You should not try to call nw_browser_start() on the browser to restart
    /// it. Instead, cancel the browser and create a new browser object.
    #[doc(alias = "nw_browser_state_failed")]
    pub const failed: Self = Self(2);
    /// the caller. You should not try to call nw_browser_start() on the
    /// browser to restart it. Instead, create a new browser object.
    #[doc(alias = "nw_browser_state_cancelled")]
    pub const cancelled: Self = Self(3);
    /// Results will not be delivered until the browser moves into the ready
    /// state. A browser can move from the ready state into the waiting state.
    /// The associated error indicates why the browser is unable to browse.
    #[doc(alias = "nw_browser_state_waiting")]
    pub const waiting: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_browser_state_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_browser_state_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Creates a new browser object, which can be used to browse for results
/// matching a browse descriptor.
///
///
/// Parameter `descriptor`: A browse descriptor object that describes the type of service for which
/// to browse.
///
///
/// Parameter `parameters`: Optional parameters to use for the new browser. If NULL, an empty parameters
/// object is created internally.
///
///
/// Returns: An instantiated browser object.
///
/// # Safety
///
/// - `descriptor` must be a valid pointer.
/// - `parameters` must be a valid pointer or null.
#[inline]
pub unsafe extern "C-unwind" fn nw_browser_create(
    descriptor: NonNull<nw_browse_descriptor_t>,
    parameters: *mut nw_parameters_t,
) -> NWRetained<nw_browser_t> {
    extern "C-unwind" {
        fn nw_browser_create(
            descriptor: NonNull<nw_browse_descriptor_t>,
            parameters: *mut nw_parameters_t,
        ) -> Option<NonNull<nw_browser_t>>;
    }
    let ret = unsafe { nw_browser_create(descriptor, parameters) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Sets the client callback queue, on which blocks for events will
    /// be scheduled. This must be done before calling nw_browser_start().
    ///
    ///
    /// Parameter `browser`: The browser object.
    ///
    ///
    /// Parameter `queue`: The client's callback queue.
    ///
    /// # Safety
    ///
    /// `browser` must be a valid pointer.
    pub fn nw_browser_set_queue(browser: NonNull<nw_browser_t>, queue: &DispatchQueue);
}

/// A block called to notify the user of any browse results that changed. To get
/// the specific list of changes that occurred, call nw_browse_result_get_changes()
/// with the old and new result.
///
///
/// Parameter `old_result`: The old value of the browse result. This value was previously provided to
/// an invocation of the browse_results_changed_handler().
///
///
/// Parameter `new_result`: The new value of the browse result. This is a new instance of the result
/// and replaces old_result.
///
///
/// Parameter `batch_complete`: A flag indicating if this is the last change in this batch. If
/// batch_complete is true, the browser has no more immediate changes to
/// report to the user, who should perform any pending UI updates. If
/// batch_complete is false, the browser has more updates queued, which will
/// be delivered in subsequent invocations of the browse_results_changed_handler().
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_browser_browse_results_changed_handler_t?language=objc)
pub type nw_browser_browse_results_changed_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<nw_browse_result_t>, NonNull<nw_browse_result_t>, bool)>;

extern "C-unwind" {
    /// Sets a callback handler to be invoked when the browser gets an update
    /// for changed browse results. This function must be called before starting
    /// the browser and must not be called after starting the browser.
    ///
    ///
    /// Parameter `browser`: The browser object.
    ///
    ///
    /// Parameter `handler`: The callback handler that fires when the browser gets an update for a
    /// changed browse result.
    ///
    /// # Safety
    ///
    /// - `browser` must be a valid pointer.
    /// - `handler` must be a valid pointer or null.
    pub fn nw_browser_set_browse_results_changed_handler(
        browser: NonNull<nw_browser_t>,
        handler: nw_browser_browse_results_changed_handler_t,
    );
}

/// A block called when the browser changes state.
///
///
/// Parameter `state`: The new state of the browser.
///
///
/// Parameter `error`: An optional error that is associated with the new state. For example, if the
/// browser encounters a DNS error, the callback will pass nw_browser_state_failed
/// as the new state and the DNS error as the error.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_browser_state_changed_handler_t?language=objc)
pub type nw_browser_state_changed_handler_t =
    *mut block2::DynBlock<dyn Fn(nw_browser_state_t, *mut nw_error_t)>;

extern "C-unwind" {
    /// Sets the state changed handler. For clients that need to perform cleanup
    /// when the browser has been cancelled, the nw_browser_state_cancelled state
    /// will be delivered last. This function must be called before starting the
    /// browser and must not be called after starting the browser.
    ///
    ///
    /// Parameter `browser`: The browser object.
    ///
    ///
    /// Parameter `state_changed_handler`: The state changed handler to call when the browser state changes.
    /// Pass NULL to remove the event handler.
    ///
    /// # Safety
    ///
    /// - `browser` must be a valid pointer.
    /// - `state_changed_handler` must be a valid pointer or null.
    pub fn nw_browser_set_state_changed_handler(
        browser: NonNull<nw_browser_t>,
        state_changed_handler: nw_browser_state_changed_handler_t,
    );
}

extern "C-unwind" {
    /// Starts the browser, which begins browsing for available endpoints.
    /// You must call nw_browser_set_queue() before starting the browser.
    ///
    ///
    /// Parameter `browser`: The browser object.
    ///
    /// # Safety
    ///
    /// `browser` must be a valid pointer.
    pub fn nw_browser_start(browser: NonNull<nw_browser_t>);
}

extern "C-unwind" {
    /// Cancels the browser. The process of cancellation will be completed
    /// asynchronously, and the final callback event delivered to the caller
    /// will be a state update with a value of nw_browser_state_cancelled.
    /// Once this update is delivered, the caller may clean up any associated
    /// memory or objects.
    ///
    ///
    /// Parameter `browser`: The browser object.
    ///
    /// # Safety
    ///
    /// `browser` must be a valid pointer.
    pub fn nw_browser_cancel(browser: NonNull<nw_browser_t>);
}

/// Returns a copy of the parameters passed to nw_browser_create().
///
///
/// Parameter `browser`: The browser object.
///
///
/// Returns: Returns an nw_parameters_t object.
///
/// # Safety
///
/// `browser` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_browser_copy_parameters(
    browser: NonNull<nw_browser_t>,
) -> NWRetained<nw_parameters_t> {
    extern "C-unwind" {
        fn nw_browser_copy_parameters(
            browser: NonNull<nw_browser_t>,
        ) -> Option<NonNull<nw_parameters_t>>;
    }
    let ret = unsafe { nw_browser_copy_parameters(browser) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Returns a copy of the browse_descriptor passed to nw_browser_create().
///
///
/// Parameter `browser`: The browser object.
///
///
/// Returns: Returns a copy of the browse_descriptor passed to nw_browser_create().
///
/// # Safety
///
/// `browser` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_browser_copy_browse_descriptor(
    browser: NonNull<nw_browser_t>,
) -> NWRetained<nw_browse_descriptor_t> {
    extern "C-unwind" {
        fn nw_browser_copy_browse_descriptor(
            browser: NonNull<nw_browser_t>,
        ) -> Option<NonNull<nw_browse_descriptor_t>>;
    }
    let ret = unsafe { nw_browser_copy_browse_descriptor(browser) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// A network path status indicates if there is a usable route available upon which to
/// send and receive data.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_path_status_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_path_status_t(pub c_uint);
impl nw_path_status_t {
    #[doc(alias = "nw_path_status_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_path_status_satisfied")]
    pub const satisfied: Self = Self(1);
    #[doc(alias = "nw_path_status_unsatisfied")]
    pub const unsatisfied: Self = Self(2);
    #[doc(alias = "nw_path_status_satisfiable")]
    pub const satisfiable: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_path_status_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_path_status_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Retrieves the status of a path. The status of a specific path object will never
    /// change, as the path object itself is static. If there is a network change, the
    /// object that generated the path object will generate a new path object.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns the status of the path, or nw_path_status_invalid if the object is NULL.
    ///
    /// # Safety
    ///
    /// `path` must be a valid pointer.
    pub fn nw_path_get_status(path: NonNull<nw_path_t>) -> nw_path_status_t;
}

/// A network path unsatisfied reason may indicate the reason the path is currently unsatisfied for some conditions.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_path_unsatisfied_reason_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_path_unsatisfied_reason_t(pub c_uint);
impl nw_path_unsatisfied_reason_t {
    #[doc(alias = "nw_path_unsatisfied_reason_not_available")]
    pub const not_available: Self = Self(0);
    #[doc(alias = "nw_path_unsatisfied_reason_cellular_denied")]
    pub const cellular_denied: Self = Self(1);
    #[doc(alias = "nw_path_unsatisfied_reason_wifi_denied")]
    pub const wifi_denied: Self = Self(2);
    #[doc(alias = "nw_path_unsatisfied_reason_local_network_denied")]
    pub const local_network_denied: Self = Self(3);
    #[doc(alias = "nw_path_unsatisfied_reason_vpn_inactive")]
    pub const vpn_inactive: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_path_unsatisfied_reason_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_path_unsatisfied_reason_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Retrieves a reason the path is not satisfied. In some cases, the reason helps to
    /// determine why the path is not satisfied. While the path may be unsatisfied for more
    /// than one reason, only the first reason will be given. In many cases, the path may be
    /// unsatisfied with no reason available.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns a reason the path is unsatisfied or nw_path_unsatisfied_reason_not_available if a reason is not available.
    ///
    /// # Safety
    ///
    /// `path` must be a valid pointer.
    pub fn nw_path_get_unsatisfied_reason(path: NonNull<nw_path_t>)
        -> nw_path_unsatisfied_reason_t;
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_path_enumerate_interfaces_block_t?language=objc)
pub type nw_path_enumerate_interfaces_block_t =
    *mut block2::DynBlock<dyn Fn(NonNull<nw_interface_t>) -> bool>;

extern "C-unwind" {
    /// List all interfaces associated with the path.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Parameter `enumerate_block`: A block that will return the interfaces associated with the path. Returning
    /// true from the block will continue to enumerate, and returning false will stop
    /// enumerating.
    ///
    /// # Safety
    ///
    /// - `path` must be a valid pointer.
    /// - `enumerate_block` must be a valid pointer.
    pub fn nw_path_enumerate_interfaces(
        path: NonNull<nw_path_t>,
        enumerate_block: nw_path_enumerate_interfaces_block_t,
    );
}

extern "C-unwind" {
    /// Compares two network path objects and checks if their content is equal.
    /// If they are not equal, they represent two different network states.
    ///
    ///
    /// Parameter `path`: The first path object to compare.
    ///
    ///
    /// Parameter `other_path`: The second path object to compare.
    ///
    ///
    /// Returns: Returns true if the paths are equivalent, or false if there is any difference
    /// between the paths.
    ///
    /// # Safety
    ///
    /// - `path` must be a valid pointer.
    /// - `other_path` must be a valid pointer.
    pub fn nw_path_is_equal(path: NonNull<nw_path_t>, other_path: NonNull<nw_path_t>) -> bool;
}

extern "C-unwind" {
    /// Checks if the path uses any network interfaces that are considered expensive
    /// to the user, such as, but not limited to, a cellular network.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns true if the path uses any network interface that is considered expensive,
    /// false otherwise.
    ///
    /// # Safety
    ///
    /// `path` must be a valid pointer.
    pub fn nw_path_is_expensive(path: NonNull<nw_path_t>) -> bool;
}

extern "C-unwind" {
    /// Checks if the path uses any network interfaces that are considered constrained
    /// to the user.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns true if the path uses any network interface that is considered constrained,
    /// false otherwise.
    ///
    /// # Safety
    ///
    /// `path` must be a valid pointer.
    pub fn nw_path_is_constrained(path: NonNull<nw_path_t>) -> bool;
}

extern "C-unwind" {
    /// Checks if the path uses a network interface that supports IPv4 connectivity.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns true if the path uses a network interface that supports IPv4,
    /// false otherwise.
    ///
    /// # Safety
    ///
    /// `path` must be a valid pointer.
    pub fn nw_path_has_ipv4(path: NonNull<nw_path_t>) -> bool;
}

extern "C-unwind" {
    /// Checks if the path uses a network interface that supports IPv6 connectivity.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns true if the path uses a network interface that supports IPv6,
    /// false otherwise.
    ///
    /// # Safety
    ///
    /// `path` must be a valid pointer.
    pub fn nw_path_has_ipv6(path: NonNull<nw_path_t>) -> bool;
}

extern "C-unwind" {
    /// Checks if the path has a DNS server configuration set.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns true if the path has a DNS server configuration set,
    /// false otherwise.
    ///
    /// # Safety
    ///
    /// `path` must be a valid pointer.
    pub fn nw_path_has_dns(path: NonNull<nw_path_t>) -> bool;
}

extern "C-unwind" {
    /// Checks if the path uses a network interface with the specified type.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns true if the path uses any network interface with the specified type,
    /// false otherwise.
    ///
    /// # Safety
    ///
    /// `path` must be a valid pointer.
    pub fn nw_path_uses_interface_type(
        path: NonNull<nw_path_t>,
        interface_type: nw_interface_type_t,
    ) -> bool;
}

/// Retrieve the local endpoint that is being used, if present. If this path
/// is the path from an nw_connection_t, it represents the address that data
/// is sent from.
///
///
/// Parameter `path`: The path object to check.
///
///
/// Returns: Returns an endpoint that is assigned as the local endpoint for this path,
/// or NULL if the path does not have a fixed local endpoint.
///
/// # Safety
///
/// `path` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_path_copy_effective_local_endpoint(
    path: NonNull<nw_path_t>,
) -> Option<NWRetained<nw_endpoint_t>> {
    extern "C-unwind" {
        fn nw_path_copy_effective_local_endpoint(
            path: NonNull<nw_path_t>,
        ) -> Option<NonNull<nw_endpoint_t>>;
    }
    let ret = unsafe { nw_path_copy_effective_local_endpoint(path) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

/// Retrieve the remote endpoint that is being used, if present. If this path
/// is the path from an nw_connection_t, it represents the address that data
/// is sent to.
///
///
/// Parameter `path`: The path object to check.
///
///
/// Returns: Returns an endpoint that is assigned as the remote endpoint for this path,
/// or NULL if the path does not have a fixed remote endpoint.
///
/// # Safety
///
/// `path` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_path_copy_effective_remote_endpoint(
    path: NonNull<nw_path_t>,
) -> Option<NWRetained<nw_endpoint_t>> {
    extern "C-unwind" {
        fn nw_path_copy_effective_remote_endpoint(
            path: NonNull<nw_path_t>,
        ) -> Option<NonNull<nw_endpoint_t>>;
    }
    let ret = unsafe { nw_path_copy_effective_remote_endpoint(path) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_path_enumerate_gateways_block_t?language=objc)
pub type nw_path_enumerate_gateways_block_t =
    *mut block2::DynBlock<dyn Fn(NonNull<nw_endpoint_t>) -> bool>;

extern "C-unwind" {
    /// List the IP addresses of the routers acting as the gateways for the path.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Parameter `enumerate_block`: A block that will return the gateways associated with the path. Returning
    /// true from the block will continue to enumerate, and returning false will stop
    /// enumerating.
    ///
    /// # Safety
    ///
    /// - `path` must be a valid pointer.
    /// - `enumerate_block` must be a valid pointer.
    pub fn nw_path_enumerate_gateways(
        path: NonNull<nw_path_t>,
        enumerate_block: nw_path_enumerate_gateways_block_t,
    );
}

/// Create a context object to represent properties associated with
/// networking content. If the same context object is associated with multiple
/// content blobs, then those pieces of content will be considered to be continuations
/// of the same message.
///
/// Parameter `context_identifier`: A string description of the context
///
/// Returns: Returns a new context context object
///
/// # Safety
///
/// `context_identifier` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_content_context_create(
    context_identifier: NonNull<c_char>,
) -> NWRetained<nw_content_context_t> {
    extern "C-unwind" {
        fn nw_content_context_create(
            context_identifier: NonNull<c_char>,
        ) -> Option<NonNull<nw_content_context_t>>;
    }
    let ret = unsafe { nw_content_context_create(context_identifier) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Access the identifier description.
///
/// Returns: Returns the context's identifier string.
///
/// # Safety
///
/// `context` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_content_context_get_identifier(
    context: NonNull<nw_content_context_t>,
) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_content_context_get_identifier(
            context: NonNull<nw_content_context_t>,
        ) -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_content_context_get_identifier(context) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

extern "C-unwind" {
    /// Check if this is the final context for a connection. When receiving,
    /// once a final context is complete, the connection is "read closed" and will not
    /// receive more content. See nw_content_context_set_is_final() for a description
    /// of how to set is_final for sending contexts.
    ///
    /// Parameter `context`: The context object
    ///
    /// Returns: Returns true if the context is the final context for a connection.
    ///
    /// # Safety
    ///
    /// `context` must be a valid pointer.
    pub fn nw_content_context_get_is_final(context: NonNull<nw_content_context_t>) -> bool;
}

extern "C-unwind" {
    /// Mark whether or not this context is the final context for a
    /// connection. When sending, marking a context as final will perform
    /// a "write close" once the context is complete, indicating that no more content
    /// will be sent. As a convenience for sending a final context, use
    /// NW_CONNECTION_FINAL_MESSAGE_CONTEXT.
    ///
    /// Parameter `context`: The context object
    ///
    /// Parameter `is_final`: If set to true, mark the context as the final context to send on a connection.
    ///
    /// # Safety
    ///
    /// `context` must be a valid pointer.
    pub fn nw_content_context_set_is_final(context: NonNull<nw_content_context_t>, is_final: bool);
}

extern "C-unwind" {
    /// Retrieve the number of milliseconds after which the content will expire.
    /// See nw_content_context_set_expiration_milliseconds for further discussion.
    ///
    /// Parameter `context`: The context object
    ///
    /// Returns: Returns content expiration, or 0 if not set.
    ///
    /// # Safety
    ///
    /// `context` must be a valid pointer.
    pub fn nw_content_context_get_expiration_milliseconds(
        context: NonNull<nw_content_context_t>,
    ) -> u64;
}

extern "C-unwind" {
    /// Set an expiration (in milliseconds) after which content may be dropped.
    /// If the expiration time is reached, the content may not be sent. If the value is
    /// 0, there is no expiration for the content. The expiration timer starts when the
    /// content is enqueued using nw_connection_send().
    ///
    /// Parameter `context`: The context object
    ///
    /// Parameter `expiration_milliseconds`: The number of milliseconds after which content will expire
    ///
    /// # Safety
    ///
    /// `context` must be a valid pointer.
    pub fn nw_content_context_set_expiration_milliseconds(
        context: NonNull<nw_content_context_t>,
        expiration_milliseconds: u64,
    );
}

extern "C-unwind" {
    /// Get the relative priority for the content. See
    /// nw_content_context_set_relative_priority for further discussion.
    ///
    /// Parameter `context`: The context object
    ///
    /// Returns: Returns the relative priority, between 0.0 (lowest priority)
    /// to 1.0 (highest priority). The default value is 0.5.
    ///
    /// # Safety
    ///
    /// `context` must be a valid pointer.
    pub fn nw_content_context_get_relative_priority(
        context: NonNull<nw_content_context_t>,
    ) -> c_double;
}

extern "C-unwind" {
    /// Set A relative priority of the content, compared to other
    /// content on the same connection. Priorities range from 0.0 (lowest
    /// priority) to 1.0 (highest priority), where content with higher
    /// priority will scheduled first if all else is equal.
    /// The default value is 0.5.
    ///
    /// Parameter `context`: The context object
    ///
    /// Parameter `relative_priority`: The relative priority of the content, between
    /// 0.0 (lowest priority) to 1.0 (highest priority).
    ///
    /// # Safety
    ///
    /// `context` must be a valid pointer.
    pub fn nw_content_context_set_relative_priority(
        context: NonNull<nw_content_context_t>,
        relative_priority: c_double,
    );
}

extern "C-unwind" {
    /// Set a context as an antecedent to this content context.
    /// The associated content will not be sent until all of its antecedents have been
    /// completed. If any of the antecedents fail with an error, this content will
    /// fail as well.
    ///
    /// Parameter `context`: The context object
    ///
    /// Parameter `antecedent_context`: A context associated with content that should precede
    /// this content.
    ///
    /// # Safety
    ///
    /// - `context` must be a valid pointer.
    /// - `antecedent_context` must be a valid pointer or null.
    pub fn nw_content_context_set_antecedent(
        context: NonNull<nw_content_context_t>,
        antecedent_context: *mut nw_content_context_t,
    );
}

/// Copy the optional content context that must be sent prior to this
/// content. See nw_content_context_set_antecedent for further discussion.
///
/// Parameter `context`: The context object
///
/// Returns: Returns a context object set as the antecedent, or NULL.
///
/// # Safety
///
/// `context` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_content_context_copy_antecedent(
    context: NonNull<nw_content_context_t>,
) -> Option<NWRetained<nw_content_context_t>> {
    extern "C-unwind" {
        fn nw_content_context_copy_antecedent(
            context: NonNull<nw_content_context_t>,
        ) -> Option<NonNull<nw_content_context_t>>;
    }
    let ret = unsafe { nw_content_context_copy_antecedent(context) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Set protocol-specific metadata to a parent content context. If
    /// metadata for the same protocol is set multiple times, the most recently
    /// set metadata will be applied.
    ///
    /// Parameter `context`: The context context parent object
    ///
    /// Parameter `protocol_metadata`: The per-protocol metadata context object to set
    ///
    /// # Safety
    ///
    /// - `context` must be a valid pointer.
    /// - `protocol_metadata` must be a valid pointer.
    pub fn nw_content_context_set_metadata_for_protocol(
        context: NonNull<nw_content_context_t>,
        protocol_metadata: NonNull<nw_protocol_metadata_t>,
    );
}

/// Copy the per-protocol metadata from a parent content context
///
/// Parameter `context`: The context context parent object
///
/// Parameter `protocol`: The definition identifier of the protocol to retrieve metadata for
///
/// Returns: Returns the metadata registered for the protocol, or NULL if there is none
///
/// # Safety
///
/// - `context` must be a valid pointer.
/// - `protocol` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_content_context_copy_protocol_metadata(
    context: NonNull<nw_content_context_t>,
    protocol: NonNull<nw_protocol_definition_t>,
) -> Option<NWRetained<nw_protocol_metadata_t>> {
    extern "C-unwind" {
        fn nw_content_context_copy_protocol_metadata(
            context: NonNull<nw_content_context_t>,
            protocol: NonNull<nw_protocol_definition_t>,
        ) -> Option<NonNull<nw_protocol_metadata_t>>;
    }
    let ret = unsafe { nw_content_context_copy_protocol_metadata(context, protocol) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Access all per-protocol metadata objects from a parent content context
    ///
    /// Parameter `context`: The context context parent object
    ///
    /// Parameter `foreach_block`: A block in which protocol definition and metadata will be sent
    ///
    /// # Safety
    ///
    /// `context` must be a valid pointer.
    pub fn nw_content_context_foreach_protocol_metadata(
        context: NonNull<nw_content_context_t>,
        foreach_block: &block2::DynBlock<
            dyn Fn(NonNull<nw_protocol_definition_t>, NonNull<nw_protocol_metadata_t>),
        >,
    );
}

/// Connection states sent by nw_connection_set_state_changed_handler.
/// States generally progress forward and do not move backwards, with the
/// exception of preparing and waiting, which may alternate before the connection
/// becomes ready or failed.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_state_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_connection_state_t(pub c_uint);
impl nw_connection_state_t {
    /// will never be delivered in the connection's state update handler, and can be treated as
    /// an unexpected value.
    #[doc(alias = "nw_connection_state_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_connection_state_waiting")]
    pub const waiting: Self = Self(1);
    #[doc(alias = "nw_connection_state_preparing")]
    pub const preparing: Self = Self(2);
    #[doc(alias = "nw_connection_state_ready")]
    pub const ready: Self = Self(3);
    #[doc(alias = "nw_connection_state_failed")]
    pub const failed: Self = Self(4);
    #[doc(alias = "nw_connection_state_cancelled")]
    pub const cancelled: Self = Self(5);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_connection_state_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_connection_state_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Creates a networking connection to an endpoint.
///
///
/// Parameter `endpoint`: The remote endpoint to connect to.
///
///
/// Parameter `parameters`: The parameters to use for the connection. The data mode,
/// either datagram or stream, must be set.
///
///
/// Returns: Returns an allocated nw_connection_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
/// Returns NULL on failure. Fails due to invalid parameters.
///
/// # Safety
///
/// - `endpoint` must be a valid pointer.
/// - `parameters` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_connection_create(
    endpoint: NonNull<nw_endpoint_t>,
    parameters: NonNull<nw_parameters_t>,
) -> NWRetained<nw_connection_t> {
    extern "C-unwind" {
        fn nw_connection_create(
            endpoint: NonNull<nw_endpoint_t>,
            parameters: NonNull<nw_parameters_t>,
        ) -> Option<NonNull<nw_connection_t>>;
    }
    let ret = unsafe { nw_connection_create(endpoint, parameters) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Retrieves the remote endpoint for a connection.
///
///
/// Parameter `connection`: The connection object.
///
///
/// Returns: Returns an nw_endpoint_t object on success.
/// Returns NULL on failure. Fails due to invalid parameters.
///
/// # Safety
///
/// `connection` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_connection_copy_endpoint(
    connection: NonNull<nw_connection_t>,
) -> NWRetained<nw_endpoint_t> {
    extern "C-unwind" {
        fn nw_connection_copy_endpoint(
            connection: NonNull<nw_connection_t>,
        ) -> Option<NonNull<nw_endpoint_t>>;
    }
    let ret = unsafe { nw_connection_copy_endpoint(connection) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Retrieves the parameters for a connection.
///
///
/// Parameter `connection`: The connection object.
///
///
/// Returns: Returns an nw_parameters_t object on success.
/// Returns NULL on failure. Fails due to invalid parameters.
///
/// # Safety
///
/// `connection` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_connection_copy_parameters(
    connection: NonNull<nw_connection_t>,
) -> NWRetained<nw_parameters_t> {
    extern "C-unwind" {
        fn nw_connection_copy_parameters(
            connection: NonNull<nw_connection_t>,
        ) -> Option<NonNull<nw_parameters_t>>;
    }
    let ret = unsafe { nw_connection_copy_parameters(connection) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_state_changed_handler_t?language=objc)
pub type nw_connection_state_changed_handler_t =
    *mut block2::DynBlock<dyn Fn(nw_connection_state_t, *mut nw_error_t)>;

extern "C-unwind" {
    /// Sets the state change handler. For clients that need to perform cleanup when the
    /// connection has been cancelled, the nw_connection_state_cancelled state will
    /// be delivered last.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Parameter `handler`: The state changed handler to call when the connection state changes.
    /// Pass NULL to remove the state changed handler.
    ///
    /// # Safety
    ///
    /// - `connection` must be a valid pointer.
    /// - `handler` must be a valid pointer or null.
    pub fn nw_connection_set_state_changed_handler(
        connection: NonNull<nw_connection_t>,
        handler: nw_connection_state_changed_handler_t,
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_boolean_event_handler_t?language=objc)
pub type nw_connection_boolean_event_handler_t = *mut block2::DynBlock<dyn Fn(bool)>;

extern "C-unwind" {
    /// Define a callback to be fired when the viability of the connection changes.
    /// This indicates whether or not read and write calls will succeed on a ready
    /// connection.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Parameter `handler`: The event handler to call when the connection viability changes. The value will
    /// be true when the connection is viable, and false otherwise.
    /// Pass NULL to remove the event handler.
    ///
    /// # Safety
    ///
    /// - `connection` must be a valid pointer.
    /// - `handler` must be a valid pointer or null.
    pub fn nw_connection_set_viability_changed_handler(
        connection: NonNull<nw_connection_t>,
        handler: nw_connection_boolean_event_handler_t,
    );
}

extern "C-unwind" {
    /// Define a callback to be fired when a better path is available or not.
    /// This indicates whether or not a preferred path is available for the
    /// connection.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Parameter `handler`: The event handler to call when the better path availability changes. The value
    /// will be true when a better path is available, and false otherwise.
    /// Pass NULL to remove the event handler.
    ///
    /// # Safety
    ///
    /// - `connection` must be a valid pointer.
    /// - `handler` must be a valid pointer or null.
    pub fn nw_connection_set_better_path_available_handler(
        connection: NonNull<nw_connection_t>,
        handler: nw_connection_boolean_event_handler_t,
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_path_event_handler_t?language=objc)
pub type nw_connection_path_event_handler_t = *mut block2::DynBlock<dyn Fn(NonNull<nw_path_t>)>;

extern "C-unwind" {
    /// Define a callback to be fired when the connection's path changes.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Parameter `handler`: The event handler to call when the connection's path changes.
    /// Pass NULL to remove the event handler.
    ///
    /// # Safety
    ///
    /// - `connection` must be a valid pointer.
    /// - `handler` must be a valid pointer or null.
    pub fn nw_connection_set_path_changed_handler(
        connection: NonNull<nw_connection_t>,
        handler: nw_connection_path_event_handler_t,
    );
}

extern "C-unwind" {
    /// Sets the client callback queue, on which blocks for events will
    /// be scheduled. This must be done before calling nw_connection_start().
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Parameter `queue`: The client's dispatch queue.
    ///
    /// # Safety
    ///
    /// `connection` must be a valid pointer.
    pub fn nw_connection_set_queue(connection: NonNull<nw_connection_t>, queue: &DispatchQueue);
}

extern "C-unwind" {
    /// Starts the connection, which will cause the connection
    /// to evaluate its path, do resolution, and try to become
    /// readable and writable. Once started, a connection
    /// must be cancelled using nw_connection_cancel() or
    /// nw_connection_force_cancel() when it is no longer needed.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    /// # Safety
    ///
    /// `connection` must be a valid pointer.
    pub fn nw_connection_start(connection: NonNull<nw_connection_t>);
}

extern "C-unwind" {
    /// Connections in the waiting state will normally re-attempt
    /// on network changes. Call nw_connection_restart() to force
    /// a connection in the waiting state to retry connection
    /// establishment even without a network change. Calls to restart
    /// for connections that are not in the waiting state will be
    /// ignored.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    /// # Safety
    ///
    /// `connection` must be a valid pointer.
    pub fn nw_connection_restart(connection: NonNull<nw_connection_t>);
}

extern "C-unwind" {
    /// Cancel the connection. This will close the connection, and negotiate over the network
    /// if applicable for the protocol. The process of cancellation will be completed
    /// asynchronously, and the final callback event delivered to the caller will be a state
    /// update with a value of nw_connection_state_cancelled. Once this update is delivered, the
    /// caller may clean up any associated memory or objects.
    ///
    /// Outstanding sends and receives will receive errors before the state changes to cancelled.
    /// There is no guarantee that any outstanding sends that have not yet delivered send completion handlers
    /// will send data before the connection is closed.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    /// # Safety
    ///
    /// `connection` must be a valid pointer.
    pub fn nw_connection_cancel(connection: NonNull<nw_connection_t>);
}

extern "C-unwind" {
    /// A variant of nw_connection_cancel() that indicates that the protocol stack should
    /// not close gracefully, but close as quickly as possible without negotiation. For example,
    /// a force close would lead to TCP RST packets being sent, as opposed to negotiating with
    /// FIN packets.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    /// # Safety
    ///
    /// `connection` must be a valid pointer.
    pub fn nw_connection_force_cancel(connection: NonNull<nw_connection_t>);
}

extern "C-unwind" {
    /// Cancel the currently connected endpoint, causing the connection
    /// to fall through to the next endpoint if available, or fail if no
    /// more endpoints are available. This is primarily useful for connections
    /// which do not have reliable handshakes, such as UDP. If data is sent
    /// on the connection with no response, canceling the current endpoint
    /// will allow another address or interface to be attempted.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    /// # Safety
    ///
    /// `connection` must be a valid pointer.
    pub fn nw_connection_cancel_current_endpoint(connection: NonNull<nw_connection_t>);
}

/// A receive completion is invoked exactly once for a call to nw_connection_receive().
/// The completion indicates that the requested content has been received (in which case
/// the content is delivered), or else an error has occurred.
///
///
/// Parameter `content`: The received content, which has a length constrained by the call to nw_connection_receive().
/// The content may be NULL in two cases: (1) the receive context (logical message) is now complete,
/// and the callback is only delivering the completed event; or, (2) the connection encountered
/// an error and there is no data to deliver. Note that the content may be non-NULL even in the
/// case of an error if there was some data received before the error was encountered. The caller
/// should process all content it receives, and not necessarily ignore data in case of errors.
///
///
/// Parameter `context`: The context (logical message) associated with the received content. This includes protocol metadata
/// that lets the caller introspect information about the received content (such as flags on an IP packet).
/// When the message has been completely received, the context will be delivered along with the
/// is_complete flag.
///
/// For datagram protocols such as UDP, the context represents the properties of a single received
/// datagram.
///
/// For protocols that only have a single context for the entire connection, such as stream protocols
/// like TCP, the context will be marked as "final", which can be accessed with
/// nw_content_context_get_is_final(). Once a final context is marked as complete, the recipient
/// may assume that the connection has been closed in the receiving direction (a "read close"). For
/// TCP, this represents receiving a FIN.
///
///
/// Parameter `is_complete`: An indication that this context (logical message) is now complete. Until this flag is
/// set, the recipient should assume that there may be more bytes to read for this context.
/// Note that even when reading datagrams, as from UDP, the context may be read in multiple
/// chunks if the maximum_length was smaller than the full length of the message.
///
/// If is_complete is marked and the received context is the final context for connection,
/// the caller may assume that the connection has been closed in the receiving direction.
///
///
/// Parameter `error`: An error will be sent if an error was encountered while trying to receive on the connection.
/// There may still be content delivered along with the error, but this content may be shorter
/// than the requested ranges. An error will be sent for any outstanding receive calls when the
/// connection is cancelled.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_receive_completion_t?language=objc)
pub type nw_connection_receive_completion_t = *mut block2::DynBlock<
    dyn Fn(*mut DispatchData, *mut nw_content_context_t, bool, *mut nw_error_t),
>;

extern "C-unwind" {
    /// Receive data from a connection. This may be called before the connection
    /// is ready, in which case the receive request will be queued until the
    /// connection is ready. The completion handler will be invoked exactly
    /// once for each call, so the client must call this function multiple
    /// times to receive multiple chunks of data. For protocols that
    /// support flow control, such as TCP, calling receive opens the receive
    /// window. If the client stops calling receive, the receive window will
    /// fill up and the remote peer will stop sending.
    ///
    ///
    /// Parameter `connection`: The connection object on which to receive data. The connection should
    /// be in the ready state.
    ///
    ///
    /// Parameter `minimum_incomplete_length`: The minimum length to receive from the connection, until the content
    /// is complete. Content will be delivered when at least the minimum is available,
    /// or the content is complete, whichever comes first.
    ///
    ///
    /// Parameter `maximum_length`: The maximum length to receive from the connection.
    ///
    ///
    /// Parameter `completion`: A callback to be called when content has been received.
    ///
    /// # Safety
    ///
    /// - `connection` must be a valid pointer.
    /// - `completion` must be a valid pointer.
    pub fn nw_connection_receive(
        connection: NonNull<nw_connection_t>,
        minimum_incomplete_length: u32,
        maximum_length: u32,
        completion: nw_connection_receive_completion_t,
    );
}

extern "C-unwind" {
    /// Receive a single atomic message from a connection. The completion
    /// handler will be invoked exactly once for each call, so the client
    /// must call this function multiple times to receive multiple messages.
    ///
    ///
    /// Parameter `connection`: The connection object on which to receive the message. The connection
    /// should be in the ready state.
    ///
    ///
    /// Parameter `completion`: A callback to be called when the message has been received, or an error
    /// has occurred.
    ///
    /// # Safety
    ///
    /// - `connection` must be a valid pointer.
    /// - `completion` must be a valid pointer.
    pub fn nw_connection_receive_message(
        connection: NonNull<nw_connection_t>,
        completion: nw_connection_receive_completion_t,
    );
}

/// A send completion is invoked exactly once for a call to nw_connection_send().
/// The completion indicates that the sent content has been processed by the stack
/// (not necessarily that it has left the host), or else an error has occurred during
/// sending.
///
///
/// Parameter `error`: An error will be sent if the associated content could not be fully sent before an
/// error occurred. An error will be sent for any outstanding sends when the connection
/// is cancelled.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_send_completion_t?language=objc)
pub type nw_connection_send_completion_t = *mut block2::DynBlock<dyn Fn(*mut nw_error_t)>;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/network/_nw_connection_send_idempotent_content?language=objc)
    pub static _nw_connection_send_idempotent_content: nw_connection_send_completion_t;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/network/_nw_content_context_default_message?language=objc)
    pub static _nw_content_context_default_message: NonNull<nw_content_context_t>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/network/_nw_content_context_final_send?language=objc)
    pub static _nw_content_context_final_send: NonNull<nw_content_context_t>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/network/_nw_content_context_default_stream?language=objc)
    pub static _nw_content_context_default_stream: NonNull<nw_content_context_t>;
}

extern "C-unwind" {
    /// Send data on a connection. This may be called before the connection is ready,
    /// in which case the send will be enqueued until the connection is ready to send.
    /// This is an asynchronous send and the completion block can be used to
    /// determine when the send is complete. There is nothing preventing a client
    /// from issuing an excessive number of outstanding sends. To minimize memory
    /// footprint and excessive latency as a consequence of buffer bloat, it is
    /// advisable to keep a low number of outstanding sends. The completion block
    /// can be used to pace subsequent sends.
    ///
    ///
    /// Parameter `connection`: The connection object on which to send data.
    ///
    ///
    /// Parameter `content`: A data object to send. This may be NULL only if this send is marking a context
    /// (a message or complete connection) as complete in the sending direction.
    ///
    ///
    /// Parameter `context`: The context associated with the content, which represents a logical message
    /// to be sent on the connection. All content sent within a single context will
    /// be sent as an in-order unit, up until the point that the context is marked
    /// complete (see is_complete). Once a context is marked complete, it may be re-used
    /// as a new logical message. Protocols like TCP that cannot send multiple
    /// independent messages at once (serial streams) will only start processing a new
    /// context once the prior context has been marked complete.
    ///
    /// The context can hold protocol metadata to define how to send content, such
    /// as flags for IP packets.
    ///
    /// The context also can define properties that allow a message to ordered relative
    /// to other messages if multiple messages are queued. These properties include
    /// relative priority, expiration, and antecedent relationships. Some protocols
    /// support re-ordering messages within a single connection. For other protocols
    /// that do not, like TCP, these properties still take effect when enqueuing data
    /// into the stream's send buffer. The ordering of messages applies to the first
    /// calls to send on a given context.
    ///
    /// In order to close a connection on the sending side (a "write close"), send
    /// a context that is marked as "final" and mark is_complete. The convenience definition
    /// NW_CONNECTION_FINAL_MESSAGE_CONTEXT may be used to define the default final context
    /// for a connection. If the caller wants to treat the entire connection as a single
    /// stream, with only one context, set NW_CONNECTION_FINAL_MESSAGE_CONTEXT for all
    /// sends; marking is_complete on the final send call will send a "write close".
    /// Using NW_CONNECTION_DEFAULT_STREAM_CONTEXT has the same behavior as sending
    /// NW_CONNECTION_FINAL_MESSAGE_CONTEXT.
    ///
    /// To send basic datagrams on a connection, use NW_CONNECTION_DEFAULT_MESSAGE_CONTEXT
    /// and pass is_complete as true for each datagram.
    ///
    /// To send data as a single stream on a connection, use NW_CONNECTION_DEFAULT_STREAM_CONTEXT
    /// and pass is_complete as true only to mark the end of the stream.
    ///
    ///
    /// Parameter `is_complete`: A flag indicating if the caller's sending context (logical message) is now complete.
    ///
    /// Until a context is marked complete, content sent for other contexts may not
    /// be sent immediately (if the protocol requires sending bytes serially, like TCP).
    ///
    /// For datagram protocols, like UDP, is_complete indicates that the content represents
    /// a complete datagram.
    ///
    /// When sending directly on streaming protocols like TCP, is_complete can be used to
    /// indicate that the connection should send a "write close" (a TCP FIN) if the sending
    /// context is the final context on the connection. Specifically, to send a "write close",
    /// pass NW_CONNECTION_FINAL_MESSAGE_CONTEXT or NW_CONNECTION_DEFAULT_STREAM_CONTEXT for the
    /// context (or create a custom context and set nw_content_context_set_is_final()), and pass
    /// true for is_complete.
    ///
    ///
    /// Parameter `completion`: A callback to be called when the data has been sent, or an error has occurred.
    /// This callback does not indicate that the remote side has acknowledged the data.
    /// This callback does indicate that the data has either been sent or it has been
    /// enqueued to be sent.
    ///
    /// # Safety
    ///
    /// - `connection` must be a valid pointer.
    /// - `context` must be a valid pointer.
    /// - `completion` must be a valid pointer.
    pub fn nw_connection_send(
        connection: NonNull<nw_connection_t>,
        content: Option<&DispatchData>,
        context: NonNull<nw_content_context_t>,
        is_complete: bool,
        completion: nw_connection_send_completion_t,
    );
}

extern "C-unwind" {
    /// Batch several send and/or receive operations together, to hint to
    /// the connection that multiple send or receive operations are expected
    /// in quick succession.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Parameter `batch_block`: The batch block will be invoked immediately upon calling this function.
    /// The client may call nw_connection_send() or nw_connection_receive()
    /// multiple times within the block, and the connection will attempt to
    /// batch these operations when the block returns.
    ///
    /// # Safety
    ///
    /// - `connection` must be a valid pointer.
    /// - `batch_block` must be a valid pointer.
    pub fn nw_connection_batch(connection: NonNull<nw_connection_t>, batch_block: dispatch_block_t);
}

/// Copy a human-readable description of the connection.
///
///
/// Parameter `connection`: The connection object.
///
///
/// Returns: Returns a human-readable string description of the connection.
/// The caller must call free() on the string.
///
/// # Safety
///
/// `connection` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_connection_copy_description(
    connection: NonNull<nw_connection_t>,
) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_connection_copy_description(
            connection: NonNull<nw_connection_t>,
        ) -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_connection_copy_description(connection) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

/// Copy the current path for a connection. If a connection is
/// established, this will reflect the connected path.
///
///
/// Parameter `connection`: The connection object.
///
///
/// Returns: Returns a retained path object, or NULL if the connection
/// has not been started or has been cancelled.
///
/// # Safety
///
/// `connection` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_connection_copy_current_path(
    connection: NonNull<nw_connection_t>,
) -> Option<NWRetained<nw_path_t>> {
    extern "C-unwind" {
        fn nw_connection_copy_current_path(
            connection: NonNull<nw_connection_t>,
        ) -> Option<NonNull<nw_path_t>>;
    }
    let ret = unsafe { nw_connection_copy_current_path(connection) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

/// Copy the connection-wide metadata for a specific protocol.
/// This allows the caller to introspect per-protocol state,
/// only once the connection has been established. This
/// metadata is also available when receiving data through
/// the content context.
///
///
/// Parameter `connection`: The connection object.
///
///
/// Parameter `definition`: The protocol definition for which metadata will be returned.
///
///
/// Returns: Returns a retained protocol metadata object, or NULL if the connection
/// has not been established yet or is cancelled.
///
/// # Safety
///
/// - `connection` must be a valid pointer.
/// - `definition` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_connection_copy_protocol_metadata(
    connection: NonNull<nw_connection_t>,
    definition: NonNull<nw_protocol_definition_t>,
) -> Option<NWRetained<nw_protocol_metadata_t>> {
    extern "C-unwind" {
        fn nw_connection_copy_protocol_metadata(
            connection: NonNull<nw_connection_t>,
            definition: NonNull<nw_protocol_definition_t>,
        ) -> Option<NonNull<nw_protocol_metadata_t>>;
    }
    let ret = unsafe { nw_connection_copy_protocol_metadata(connection, definition) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Check for the maximum datagram size that can be written
    /// on the connection. Any datagrams written should be less
    /// than or equal to this size.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Returns: Returns a datagram size based on the current MTU and the
    /// overhead of the protocols being used.
    ///
    /// # Safety
    ///
    /// `connection` must be a valid pointer.
    pub fn nw_connection_get_maximum_datagram_size(connection: NonNull<nw_connection_t>) -> u32;
}

/// Creates a new group descriptor object based on an endpoint
/// to which communication will be established using a multiplexing protocol,
/// represented as an nw_endpoint containing the remote endpoint
/// to use for communication.
///
///
/// Parameter `remote_endpoint`: An endpoint that can be used for communication over a multiplexing protocol.
///
///
/// Returns: An instantiated group descriptor object or nil if the specified
/// endpoint is not valid.
///
/// # Safety
///
/// `remote_endpoint` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_group_descriptor_create_multiplex(
    remote_endpoint: NonNull<nw_endpoint_t>,
) -> NWRetained<nw_group_descriptor_t> {
    extern "C-unwind" {
        fn nw_group_descriptor_create_multiplex(
            remote_endpoint: NonNull<nw_endpoint_t>,
        ) -> Option<NonNull<nw_group_descriptor_t>>;
    }
    let ret = unsafe { nw_group_descriptor_create_multiplex(remote_endpoint) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Creates a new group descriptor object based on a multicast group,
/// represented as an address endpoint.
///
///
/// Parameter `multicast_group`: An address endpoint that contains a multicast group to join.
///
///
/// Returns: An instantiated group descriptor object or nil if the specified
/// endpoint is not an address endpoint representing a valid multicast
/// group.
///
/// # Safety
///
/// `multicast_group` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_group_descriptor_create_multicast(
    multicast_group: NonNull<nw_endpoint_t>,
) -> NWRetained<nw_group_descriptor_t> {
    extern "C-unwind" {
        fn nw_group_descriptor_create_multicast(
            multicast_group: NonNull<nw_endpoint_t>,
        ) -> Option<NonNull<nw_group_descriptor_t>>;
    }
    let ret = unsafe { nw_group_descriptor_create_multicast(multicast_group) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Add an additional endpoint to a given group descriptor.
    ///
    ///
    /// Parameter `descriptor`: A group descriptor.
    ///
    ///
    /// Parameter `endpoint`: An endpoint to add to the group.
    ///
    ///
    /// Returns: Returns true if the endpoint was added, false if the endpoint was
    /// not of a valid type and therefore not added.
    ///
    /// # Safety
    ///
    /// - `descriptor` must be a valid pointer.
    /// - `endpoint` must be a valid pointer.
    pub fn nw_group_descriptor_add_endpoint(
        descriptor: NonNull<nw_group_descriptor_t>,
        endpoint: NonNull<nw_endpoint_t>,
    ) -> bool;
}

/// A block called to enumerate the endpoints that are members of a group.
///
///
/// Parameter `endpoint`: A member of a group.
///
///
/// Returns: Returning true from the block will continue enumeration, and returning
/// false will stop enumeration.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_group_descriptor_enumerate_endpoints_block_t?language=objc)
pub type nw_group_descriptor_enumerate_endpoints_block_t =
    *mut block2::DynBlock<dyn Fn(NonNull<nw_endpoint_t>) -> bool>;

extern "C-unwind" {
    /// List all endpoints associated with the group descriptor.
    ///
    ///
    /// Parameter `descriptor`: The group descriptor object to check.
    ///
    ///
    /// Parameter `enumerate_block`: A block to which the endpoints associated with the descriptor will be passed.
    /// Returning true from the block will continue to enumerate, and returning false will stop
    /// enumerating.
    ///
    /// # Safety
    ///
    /// - `descriptor` must be a valid pointer.
    /// - `enumerate_block` must be a valid pointer.
    pub fn nw_group_descriptor_enumerate_endpoints(
        descriptor: NonNull<nw_group_descriptor_t>,
        enumerate_block: nw_group_descriptor_enumerate_endpoints_block_t,
    );
}

extern "C-unwind" {
    /// Require a particular source for this multicast group descriptor.
    ///
    ///
    /// Parameter `multicast_descriptor`: The multicast group descriptor to modify.
    ///
    ///
    /// Parameter `source`: An endpoint describing the source for this descriptor.
    ///
    /// # Safety
    ///
    /// - `multicast_descriptor` must be a valid pointer.
    /// - `source` must be a valid pointer.
    pub fn nw_multicast_group_descriptor_set_specific_source(
        multicast_descriptor: NonNull<nw_group_descriptor_t>,
        source: NonNull<nw_endpoint_t>,
    );
}

extern "C-unwind" {
    /// Disable receiving unicast traffic for a connection group that is also receiving multicast traffic.
    ///
    ///
    /// Parameter `multicast_descriptor`: The multicast group descriptor to modify.
    ///
    ///
    /// Parameter `disable_unicast_traffic`: A boolean indicating if receiving unicast traffic should be disabled.
    ///
    /// # Safety
    ///
    /// `multicast_descriptor` must be a valid pointer.
    pub fn nw_multicast_group_descriptor_set_disable_unicast_traffic(
        multicast_descriptor: NonNull<nw_group_descriptor_t>,
        disable_unicast_traffic: bool,
    );
}

extern "C-unwind" {
    /// Check if receiving unicast traffic has been disabled for a multicast connection group.
    ///
    ///
    /// Parameter `multicast_descriptor`: The multicast group descriptor to check.
    ///
    ///
    /// Returns: A boolean indicating if receiving unicast traffic should be disabled.
    ///
    /// # Safety
    ///
    /// `multicast_descriptor` must be a valid pointer.
    pub fn nw_multicast_group_descriptor_get_disable_unicast_traffic(
        multicast_descriptor: NonNull<nw_group_descriptor_t>,
    ) -> bool;
}

/// Connection Group states sent by nw_connection_group_set_state_changed_handler.
/// States progress forward and do not move backwards.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_group_state_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_connection_group_state_t(pub c_uint);
impl nw_connection_group_state_t {
    /// This state will never be delivered in the connection group's state update
    /// handler and can be treated as an unexpected value.
    #[doc(alias = "nw_connection_group_state_invalid")]
    pub const invalid: Self = Self(0);
    /// before being able to receive and process incoming messages.
    #[doc(alias = "nw_connection_group_state_waiting")]
    pub const waiting: Self = Self(1);
    /// process incoming messages.
    #[doc(alias = "nw_connection_group_state_ready")]
    pub const ready: Self = Self(2);
    /// You should cancel the connection group and create a new connection group object
    /// if you wish to continue processing incoming messages.
    #[doc(alias = "nw_connection_group_state_failed")]
    pub const failed: Self = Self(3);
    /// the user. You should create a new connection group object if you wish to continue
    /// processing incoming messages.
    #[doc(alias = "nw_connection_group_state_cancelled")]
    pub const cancelled: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_connection_group_state_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_connection_group_state_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Creates a new connection group object to use for communication with
/// a group descriptor using protocols described by parameters.
///
///
/// Parameter `group_descriptor`: A group descriptor. For example, a descriptor of type nw_group_type_multicast
/// defines one or more multicast groups to automatically join.
///
///
/// Parameter `parameters`: Parameters to use for the new connection group. This includes the protocols that
/// will be used to delineate complete messages for processing. For multicast
/// joining, all available interfaces will be joined as prohibited or required.
///
///
/// Returns: Returns an allocated nw_connection_group_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
/// Returns NULL on failure. Fails due to invalid parameters.
///
/// # Safety
///
/// - `group_descriptor` must be a valid pointer.
/// - `parameters` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_connection_group_create(
    group_descriptor: NonNull<nw_group_descriptor_t>,
    parameters: NonNull<nw_parameters_t>,
) -> NWRetained<nw_connection_group_t> {
    extern "C-unwind" {
        fn nw_connection_group_create(
            group_descriptor: NonNull<nw_group_descriptor_t>,
            parameters: NonNull<nw_parameters_t>,
        ) -> Option<NonNull<nw_connection_group_t>>;
    }
    let ret = unsafe { nw_connection_group_create(group_descriptor, parameters) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Gets the group descriptor with which the connection group was created.
///
///
/// Parameter `group`: The connection group to check.
///
///
/// Returns: Returns the descriptor with which the connection group was created.
///
/// # Safety
///
/// `group` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_connection_group_copy_descriptor(
    group: NonNull<nw_connection_group_t>,
) -> NWRetained<nw_group_descriptor_t> {
    extern "C-unwind" {
        fn nw_connection_group_copy_descriptor(
            group: NonNull<nw_connection_group_t>,
        ) -> Option<NonNull<nw_group_descriptor_t>>;
    }
    let ret = unsafe { nw_connection_group_copy_descriptor(group) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Returns a copy of the parameters passed to nw_connection_group_create.
///
///
/// Parameter `group`: The connection group object.
///
///
/// Returns: Returns an nw_parameters_t object.
///
/// # Safety
///
/// `group` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_connection_group_copy_parameters(
    group: NonNull<nw_connection_group_t>,
) -> NWRetained<nw_parameters_t> {
    extern "C-unwind" {
        fn nw_connection_group_copy_parameters(
            group: NonNull<nw_connection_group_t>,
        ) -> Option<NonNull<nw_parameters_t>>;
    }
    let ret = unsafe { nw_connection_group_copy_parameters(group) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Sets the client callback queue, on which blocks for events will
    /// be scheduled. This must be done before calling nw_connection_group_start().
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `queue`: The client's callback queue.
    ///
    /// # Safety
    ///
    /// `group` must be a valid pointer.
    pub fn nw_connection_group_set_queue(
        group: NonNull<nw_connection_group_t>,
        queue: &DispatchQueue,
    );
}

/// A block called when the connection group changes state.
///
///
/// Parameter `state`: The new state of the connection group.
///
///
/// Parameter `error`: An optional error that is associated with the new state.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_group_state_changed_handler_t?language=objc)
pub type nw_connection_group_state_changed_handler_t =
    *mut block2::DynBlock<dyn Fn(nw_connection_group_state_t, *mut nw_error_t)>;

extern "C-unwind" {
    /// Sets the state changed handler. For clients that need to perform cleanup
    /// when the connection group has been cancelled, the nw_connection_group_state_cancelled state
    /// will be delivered last. This function must not be called after starting the connection group.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `state_changed_handler`: The state changed handler to call when the connection group state changes.
    /// Pass NULL to remove the event handler.
    ///
    /// # Safety
    ///
    /// - `group` must be a valid pointer.
    /// - `state_changed_handler` must be a valid pointer or null.
    pub fn nw_connection_group_set_state_changed_handler(
        group: NonNull<nw_connection_group_t>,
        state_changed_handler: nw_connection_group_state_changed_handler_t,
    );
}

/// A block called when a new inbound message arrives at the connection group. A client
/// may reply to this message within the handler or it may choose to save the
/// content context representing this message and provide a response
/// at a later time. If an inbound context is deallocated without providing a response,
/// the message is considered dropped and any internal state associated with the
/// endpoint that sent that message will be removed.
///
///
/// Parameter `content`: The content associated with the body of the inbound message. If there is no
/// body for this message `content` will be `nil`.
///
///
/// Parameter `context`: The content context representing this inbound message.
///
///
/// Parameter `is_complete`: True if the inbound message is complete and any content provided represents
/// the entirety of the inbound message's body. If false, the inbound message context
/// may be converted to a connection associated with this message and read
/// the remainder of the body, or an appropriate error may be selected and sent in
/// response.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_group_receive_handler_t?language=objc)
pub type nw_connection_group_receive_handler_t =
    *mut block2::DynBlock<dyn Fn(*mut DispatchData, NonNull<nw_content_context_t>, bool)>;

extern "C-unwind" {
    /// Sets the handler to be invoked whenever a new inbound message
    /// arrives at the connection group. This function must not be called after starting the connection group.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `maximum_message_size`: The maximum message size that should be delivered as a complete message. Any
    /// inbound messages larger than this size will be delivered as a partial message and
    /// an application may convert the inbound message to an `nw_connection` to read
    /// any remaining data for that message until it is complete.
    ///
    ///
    /// Parameter `reject_oversized_messages`: True if messages larger than maximum_message_size should be treated as errors
    /// and the connection group should automatically reply to such messages. False if the
    /// connection group should deliver such messages as incomplete and allow the application
    /// to inspect the message prior to accepting or rejecting it.
    ///
    ///
    /// Parameter `receive_handler`: The handler to call upon arrival of a new inbound message.
    /// Pass NULL to remove the handler.
    ///
    /// # Safety
    ///
    /// - `group` must be a valid pointer.
    /// - `receive_handler` must be a valid pointer or null.
    pub fn nw_connection_group_set_receive_handler(
        group: NonNull<nw_connection_group_t>,
        maximum_message_size: u32,
        reject_oversized_messages: bool,
        receive_handler: nw_connection_group_receive_handler_t,
    );
}

extern "C-unwind" {
    /// Starts the connection group, which begins listening for and processing incoming messages.
    /// You must call nw_connection_group_set_queue() and set a receive handler with
    /// nw_connection_group_set_receive_handler() before starting the connection group.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    /// # Safety
    ///
    /// `group` must be a valid pointer.
    pub fn nw_connection_group_start(group: NonNull<nw_connection_group_t>);
}

extern "C-unwind" {
    /// Cancels the connection group. The process of cancellation will be completed
    /// asynchronously, and the final callback event delivered to the caller
    /// will be a state update with a value of nw_connection_group_state_cancelled.
    /// Once this update is delivered, the caller may clean up any associated
    /// memory or objects.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    /// # Safety
    ///
    /// `group` must be a valid pointer.
    pub fn nw_connection_group_cancel(group: NonNull<nw_connection_group_t>);
}

/// Copy the remote endpoint corresponding to a given inbound connection group message.
///
///
/// Parameter `group`: The connection group object.
///
///
/// Parameter `context`: A content context representing an inbound message received from this connection group.
///
///
/// Returns: Returns the remote endpoint, or nil if the context is not a valid
/// inbound message received from this connection group.
///
/// # Safety
///
/// - `group` must be a valid pointer.
/// - `context` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_connection_group_copy_remote_endpoint_for_message(
    group: NonNull<nw_connection_group_t>,
    context: NonNull<nw_content_context_t>,
) -> Option<NWRetained<nw_endpoint_t>> {
    extern "C-unwind" {
        fn nw_connection_group_copy_remote_endpoint_for_message(
            group: NonNull<nw_connection_group_t>,
            context: NonNull<nw_content_context_t>,
        ) -> Option<NonNull<nw_endpoint_t>>;
    }
    let ret = unsafe { nw_connection_group_copy_remote_endpoint_for_message(group, context) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

/// Copy the local endpoint corresponding to a given inbound connection group message.
///
///
/// Parameter `group`: The connection group object.
///
///
/// Parameter `context`: A content context representing an inbound message received from this connection group.
///
///
/// Returns: Returns the local endpoint, or nil if the context is not a valid
/// inbound message received from this connection group.
///
/// # Safety
///
/// - `group` must be a valid pointer.
/// - `context` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_connection_group_copy_local_endpoint_for_message(
    group: NonNull<nw_connection_group_t>,
    context: NonNull<nw_content_context_t>,
) -> Option<NWRetained<nw_endpoint_t>> {
    extern "C-unwind" {
        fn nw_connection_group_copy_local_endpoint_for_message(
            group: NonNull<nw_connection_group_t>,
            context: NonNull<nw_content_context_t>,
        ) -> Option<NonNull<nw_endpoint_t>>;
    }
    let ret = unsafe { nw_connection_group_copy_local_endpoint_for_message(group, context) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

/// Copy the path associated with a given inbound connection group message.
///
///
/// Parameter `group`: The connection group object.
///
///
/// Parameter `context`: A content context representing an inbound message received from this connection group.
///
///
/// Returns: Returns the path associated with the provided message, or nil if the context
/// is not a valid inbound message received from this connection group.
///
/// # Safety
///
/// - `group` must be a valid pointer.
/// - `context` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_connection_group_copy_path_for_message(
    group: NonNull<nw_connection_group_t>,
    context: NonNull<nw_content_context_t>,
) -> Option<NWRetained<nw_path_t>> {
    extern "C-unwind" {
        fn nw_connection_group_copy_path_for_message(
            group: NonNull<nw_connection_group_t>,
            context: NonNull<nw_content_context_t>,
        ) -> Option<NonNull<nw_path_t>>;
    }
    let ret = unsafe { nw_connection_group_copy_path_for_message(group, context) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

/// Copy the metadata corresponding to a given inbound connection group message.
///
///
/// Parameter `group`: The connection group object.
///
///
/// Parameter `definition`: The protocol definition for which metadata will be returned.
///
///
/// Returns: Returns a retained protocol metadata object, or NULL if not found.
///
/// # Safety
///
/// - `group` must be a valid pointer.
/// - `context` must be a valid pointer.
/// - `definition` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_connection_group_copy_protocol_metadata_for_message(
    group: NonNull<nw_connection_group_t>,
    context: NonNull<nw_content_context_t>,
    definition: NonNull<nw_protocol_definition_t>,
) -> Option<NWRetained<nw_protocol_metadata_t>> {
    extern "C-unwind" {
        fn nw_connection_group_copy_protocol_metadata_for_message(
            group: NonNull<nw_connection_group_t>,
            context: NonNull<nw_content_context_t>,
            definition: NonNull<nw_protocol_definition_t>,
        ) -> Option<NonNull<nw_protocol_metadata_t>>;
    }
    let ret = unsafe {
        nw_connection_group_copy_protocol_metadata_for_message(group, context, definition)
    };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

/// Extract a connection corresponding to an inbound message from the
/// connection group. Once extracted, subsequent messages from this
/// remote endpoint on this connection will no longer be handled by the
/// connection group. The connection may be used to read the remainder
/// of a partial message or to send a large response with support for partial
/// messages and backpressure.
/// Any incoming messages from this remote endpoint which were saved from
/// the receive handler may no longer be valid after a connection is returned.
/// An extracted connection must have a queue set and be started before it can be used.
///
///
/// Parameter `group`: The connection group object from which the context was received. If the context was
/// not received from this connection group, the extraction will fail.
///
///
/// Parameter `context`: A content context representing an inbound message received from this connection group.
///
///
/// Returns: Returns the connection associated with the provided message, or nil if the extraction
/// fails. Extraction will fail if the provided message is not an inbound message from
/// this connection group.
///
/// # Safety
///
/// - `group` must be a valid pointer.
/// - `context` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_connection_group_extract_connection_for_message(
    group: NonNull<nw_connection_group_t>,
    context: NonNull<nw_content_context_t>,
) -> Option<NWRetained<nw_connection_t>> {
    extern "C-unwind" {
        fn nw_connection_group_extract_connection_for_message(
            group: NonNull<nw_connection_group_t>,
            context: NonNull<nw_content_context_t>,
        ) -> Option<NonNull<nw_connection_t>>;
    }
    let ret = unsafe { nw_connection_group_extract_connection_for_message(group, context) };
    ret.map(|ret| unsafe { NWRetained::retain(ret) })
}

extern "C-unwind" {
    /// Send data in response to an inbound message received by a connection group.
    ///
    ///
    /// Parameter `group`: The connection group object from which the reply_context was received.
    ///
    ///
    /// Parameter `inbound_message`: The inbound message received by the connection group for which this is a response.
    /// An inbound message may be replied to exactly once.
    ///
    ///
    /// Parameter `outbound_message`: The outbound message to send in response to the message received by the connection group.
    ///
    /// The response context can also hold protocol metadata to define how to
    /// send content, such as flags for IP packets.
    ///
    /// If the context is marked as "final", the  connection group will expect that no further communication is
    /// expected during this connection with the peer and may close the underlying transport.
    /// Subsequent connection attempts from the peer will continue to be delivered as incoming messages.
    ///
    ///
    /// Parameter `content`: A data object to send as the message body. This may be NULL if the outgoing
    /// context represents a metadata only message that contains no body data.
    ///
    /// # Safety
    ///
    /// - `group` must be a valid pointer.
    /// - `inbound_message` must be a valid pointer.
    /// - `outbound_message` must be a valid pointer.
    pub fn nw_connection_group_reply(
        group: NonNull<nw_connection_group_t>,
        inbound_message: NonNull<nw_content_context_t>,
        outbound_message: NonNull<nw_content_context_t>,
        content: Option<&DispatchData>,
    );
}

/// Extract a connection from the connection group. For a multiplex connection group, this means that
/// a new stream is opened and the corresponding nw_connection_t object is returned. For non-multiplex
/// connection groups, a connection to the specified endpoint will be returned if allowed by the group descriptor.
///
/// The connection can be re-inserted into the group later. Once reinserted, the connection group
/// will handle subsequent messages from this remote endpoint.
/// An extracted connection must have a queue set and be started before it can be used.
///
///
/// Parameter `group`: The connection group object from which to extract a connection.
///
///
/// Parameter `endpoint`: The endpoint to use as the remote endpoint for the extracted connection, if applicable.
/// For connection groups with multiplex group descriptors, this should be nil.
///
///
/// Parameter `protocol_options`: The protocol options to apply to the extracted connection. May be nil if not applicable.
///
///
/// Returns: Returns the connection from the connection group.
///
/// # Safety
///
/// - `group` must be a valid pointer.
/// - `endpoint` must be a valid pointer or null.
/// - `protocol_options` must be a valid pointer or null.
#[inline]
pub unsafe extern "C-unwind" fn nw_connection_group_extract_connection(
    group: NonNull<nw_connection_group_t>,
    endpoint: *mut nw_endpoint_t,
    protocol_options: *mut nw_protocol_options_t,
) -> Option<NWRetained<nw_connection_t>> {
    extern "C-unwind" {
        fn nw_connection_group_extract_connection(
            group: NonNull<nw_connection_group_t>,
            endpoint: *mut nw_endpoint_t,
            protocol_options: *mut nw_protocol_options_t,
        ) -> Option<NonNull<nw_connection_t>>;
    }
    let ret = unsafe { nw_connection_group_extract_connection(group, endpoint, protocol_options) };
    ret.map(|ret| unsafe { NWRetained::retain(ret) })
}

extern "C-unwind" {
    /// Reinsert a connection into a connection group. Once reinserted, the connection group
    /// will handle subsequent messages from this remote endpoint, and any outstanding reads on
    /// the connection will be cancelled.
    ///
    ///
    /// Parameter `group`: The connection group object from which the connection was extracted. If the connection was
    /// not extracted from this connection group, the reinsertion will fail.
    ///
    ///
    /// Parameter `connection`: A connection that was extracted from this connection group.
    ///
    ///
    /// Returns: Returns true if the reinsertion was successful. Reinsertion will fail if the provided connection was
    /// not extracted from this connection group.
    ///
    /// # Safety
    ///
    /// - `group` must be a valid pointer.
    /// - `connection` must be a valid pointer.
    pub fn nw_connection_group_reinsert_extracted_connection(
        group: NonNull<nw_connection_group_t>,
        connection: NonNull<nw_connection_t>,
    ) -> bool;
}

/// A send completion is invoked exactly once for a call to nw_connection_group_send_message().
/// The completion indicates that the sent content has been processed by the stack
/// (not necessarily that it has left the host), or else an error has occurred during
/// sending.
///
///
/// Parameter `error`: An error will be delivered if the associated content could not be fully sent before an
/// error occurred. An error will be sent for any outstanding sends when the connection
/// is cancelled.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_group_send_completion_t?language=objc)
pub type nw_connection_group_send_completion_t = *mut block2::DynBlock<dyn Fn(*mut nw_error_t)>;

extern "C-unwind" {
    /// Send data that is not in response to an inbound message. This outgoing
    /// message will be sent from the local endpoint on which the connection group is
    /// listening for incoming messages.
    ///
    /// This is an asynchronous send and the completion block can be used to
    /// determine when the send is complete. There is nothing preventing a client
    /// from issuing an excessive number of outstanding sends. To minimize memory
    /// footprint and excessive latency as a consequence of buffer bloat, it is
    /// advisable to keep a low number of outstanding sends. The completion block
    /// can be used to pace subsequent sends.
    ///
    ///
    /// Parameter `group`: The connection group object from which to send the outbound data.
    ///
    ///
    /// Parameter `content`: A data object to send as the message body. This may be NULL if the outgoing
    /// context represents a metadata only message that contains no body data.
    ///
    ///
    /// Parameter `endpoint`: The destination endpoint to which the outbound message should be sent. If the
    /// endpoint is NULL, the message will be sent to all members of the group.
    ///
    ///
    /// Parameter `context`: An outbound message to send from the connection group.
    ///
    /// The context can also hold protocol metadata to define how to send content,
    /// such as flags for IP packets.
    ///
    /// If the context is marked as "final", the  connection group will expect that no further communication is
    /// expected during this connection with the peer and may close the underlying transport.
    /// Subsequent connection attempts from the peer will be delivered as incoming messages.
    ///
    ///
    /// Parameter `completion`: A callback to be called when the message has been sent, or an error has occurred.
    /// This callback does not indicate that the remote side has acknowledged the data.
    /// This callback does indicate that the data has either been sent or it has been
    /// enqueued to be sent.
    ///
    /// # Safety
    ///
    /// - `group` must be a valid pointer.
    /// - `endpoint` must be a valid pointer or null.
    /// - `context` must be a valid pointer.
    /// - `completion` must be a valid pointer.
    pub fn nw_connection_group_send_message(
        group: NonNull<nw_connection_group_t>,
        content: Option<&DispatchData>,
        endpoint: *mut nw_endpoint_t,
        context: NonNull<nw_content_context_t>,
        completion: nw_connection_group_send_completion_t,
    );
}

/// A block called with a new connection when a multiplex group receives a new stream. If a new connection
/// handler is set the user must handle connections received by this handler. There are three possible
/// actions to take and one of these three actions must be taken.
/// 1) Take over the ownership of the connection. In this case, the connection is used by the client to
/// send and receive data as any other connection would be used. The client may insert this
/// connection back into the connection group at a later point if so desired.
/// The connection must have a queue set and be started before it can be used.
/// 2) If you want the connection group to handle this connection, simply insert this connection back into
/// the connection group right away.
/// 3) If you don't want to accept this connection, simply cancel the connection.
///
///
/// Parameter `connection`: The connection representing the new stream on this multiplexing protocol
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_group_new_connection_handler_t?language=objc)
pub type nw_connection_group_new_connection_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<nw_connection_t>)>;

extern "C-unwind" {
    /// Sets the new connection handler to be invoked whenever a new inbound connection
    /// is received by the connection group. This function must not be called
    /// after starting the connection group.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `new_connection_handler`: The new connection handler to call upon receipt of a new inbound connection.
    /// Pass NULL to remove the handler.
    ///
    /// # Safety
    ///
    /// - `group` must be a valid pointer.
    /// - `new_connection_handler` must be a valid pointer or null.
    pub fn nw_connection_group_set_new_connection_handler(
        group: NonNull<nw_connection_group_t>,
        new_connection_handler: nw_connection_group_new_connection_handler_t,
    );
}

/// Copy the metadata corresponding to a given inbound connection group message.
///
///
/// Parameter `group`: The connection group object.
///
///
/// Parameter `definition`: The protocol definition for which metadata will be returned.
///
///
/// Returns: Returns a retained protocol metadata object, or NULL if the connection
/// group has not been established yet or is cancelled.
///
/// # Safety
///
/// - `group` must be a valid pointer.
/// - `definition` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_connection_group_copy_protocol_metadata(
    group: NonNull<nw_connection_group_t>,
    definition: NonNull<nw_protocol_definition_t>,
) -> Option<NWRetained<nw_protocol_metadata_t>> {
    extern "C-unwind" {
        fn nw_connection_group_copy_protocol_metadata(
            group: NonNull<nw_connection_group_t>,
            definition: NonNull<nw_protocol_definition_t>,
        ) -> Option<NonNull<nw_protocol_metadata_t>>;
    }
    let ret = unsafe { nw_connection_group_copy_protocol_metadata(group, definition) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_establishment_report_access_block_t?language=objc)
pub type nw_establishment_report_access_block_t =
    *mut block2::DynBlock<dyn Fn(*mut nw_establishment_report_t)>;

extern "C-unwind" {
    /// Access the establishment report for a connection. The report will be
    /// NULL until the connection is in the "ready" state.
    ///
    /// The callback block will be invoked exactly once on the provided queue.
    ///
    ///
    /// Parameter `connection`: An established connection.
    ///
    ///
    /// Parameter `queue`: The dispatch queue on which to call the access_block.
    ///
    ///
    /// Parameter `access_block`: A block to invoke with the establishment report, which may be NULL if the
    /// connection not ready.
    ///
    /// # Safety
    ///
    /// - `connection` must be a valid pointer.
    /// - `access_block` must be a valid pointer.
    pub fn nw_connection_access_establishment_report(
        connection: NonNull<nw_connection_t>,
        queue: &DispatchQueue,
        access_block: nw_establishment_report_access_block_t,
    );
}

extern "C-unwind" {
    /// Retrieve the duration of the connection's establishment. This is
    /// the total time in milliseconds from when the connection attempt began
    /// until the connection becomes ready, including resolution, proxy
    /// evaluation, and protocol handshakes.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Returns: Returns the number of milliseconds the connection took to establish.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    pub fn nw_establishment_report_get_duration_milliseconds(
        report: NonNull<nw_establishment_report_t>,
    ) -> u64;
}

extern "C-unwind" {
    /// Retrieve the delay from calling start() after which the successful connection
    /// attempt began. For connections that succeed on the first attempt, this value
    /// will be 0. For connections that move into the "waiting" state, this
    /// value will be greater than 0.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Returns: Returns the number of milliseconds from connection start to the beginning
    /// of the successful connection attempt.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    pub fn nw_establishment_report_get_attempt_started_after_milliseconds(
        report: NonNull<nw_establishment_report_t>,
    ) -> u64;
}

extern "C-unwind" {
    /// Retrieve the number of connection attempts made before the successful
    /// attempt. For connections that succeed on the first attempt, this value
    /// will be 0. For connections that move into the "waiting" state, this
    /// value will be greater than 0.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Returns: Returns the number of connection attempts made before the successful attempt.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    pub fn nw_establishment_report_get_previous_attempt_count(
        report: NonNull<nw_establishment_report_t>,
    ) -> u32;
}

extern "C-unwind" {
    /// Check if the connection used a proxy during establishment.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Returns: Returns true if the connection used a proxy, false otherwise.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    pub fn nw_establishment_report_get_used_proxy(
        report: NonNull<nw_establishment_report_t>,
    ) -> bool;
}

extern "C-unwind" {
    /// Check if a proxy configuration applied to the connection,
    /// even if the connection did not end up using a proxy for the
    /// successful attempt.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Returns: Returns true if a proxy configuration applied to the connection,
    /// false otherwise.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    pub fn nw_establishment_report_get_proxy_configured(
        report: NonNull<nw_establishment_report_t>,
    ) -> bool;
}

/// Access the endpoint of the proxy used by a connection, if applicable.
///
///
/// Parameter `report`: An establishment report.
///
///
/// Returns: Returns an allocated endpoint object if a proxy was used by the connection,
/// or NULL if no proxy was used.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
///
/// # Safety
///
/// `report` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_establishment_report_copy_proxy_endpoint(
    report: NonNull<nw_establishment_report_t>,
) -> Option<NWRetained<nw_endpoint_t>> {
    extern "C-unwind" {
        fn nw_establishment_report_copy_proxy_endpoint(
            report: NonNull<nw_establishment_report_t>,
        ) -> Option<NonNull<nw_endpoint_t>>;
    }
    let ret = unsafe { nw_establishment_report_copy_proxy_endpoint(report) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

/// The source of a resolution indicates if the set of endpoints was resolved
/// locally using a cache, or sent a query over the network.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_report_resolution_source_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_report_resolution_source_t(pub c_uint);
impl nw_report_resolution_source_t {
    #[doc(alias = "nw_report_resolution_source_query")]
    pub const query: Self = Self(1);
    #[doc(alias = "nw_report_resolution_source_cache")]
    pub const cache: Self = Self(2);
    #[doc(alias = "nw_report_resolution_source_expired_cache")]
    pub const expired_cache: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_report_resolution_source_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_report_resolution_source_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Check the source of a resolution, such as query or cache.
    ///
    ///
    /// Parameter `resolution_report`: A resolution report.
    ///
    ///
    /// Returns: The source of the resolution (query or cache).
    ///
    /// # Safety
    ///
    /// `resolution_report` must be a valid pointer.
    pub fn nw_resolution_report_get_source(
        resolution_report: NonNull<nw_resolution_report_t>,
    ) -> nw_report_resolution_source_t;
}

extern "C-unwind" {
    /// Get the number of milliseconds spent on this resolution step.
    ///
    ///
    /// Parameter `resolution_report`: A resolution report.
    ///
    ///
    /// Returns: The number of milliseconds spent on this resolution step.
    ///
    /// # Safety
    ///
    /// `resolution_report` must be a valid pointer.
    pub fn nw_resolution_report_get_milliseconds(
        resolution_report: NonNull<nw_resolution_report_t>,
    ) -> u64;
}

extern "C-unwind" {
    /// Get the number of resolved endpoints discovered by the resolution step.
    ///
    ///
    /// Parameter `resolution_report`: A resolution report.
    ///
    ///
    /// Returns: The number of resolved endpoints discovered by the resolution step.
    ///
    /// # Safety
    ///
    /// `resolution_report` must be a valid pointer.
    pub fn nw_resolution_report_get_endpoint_count(
        resolution_report: NonNull<nw_resolution_report_t>,
    ) -> u32;
}

/// Copy the resolved endpoint that led to a successful connection.
///
///
/// Parameter `resolution_report`: A resolution report.
///
///
/// Returns: The resolved endpoint that led to a successful connection.
///
/// # Safety
///
/// `resolution_report` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_resolution_report_copy_successful_endpoint(
    resolution_report: NonNull<nw_resolution_report_t>,
) -> NWRetained<nw_endpoint_t> {
    extern "C-unwind" {
        fn nw_resolution_report_copy_successful_endpoint(
            resolution_report: NonNull<nw_resolution_report_t>,
        ) -> Option<NonNull<nw_endpoint_t>>;
    }
    let ret = unsafe { nw_resolution_report_copy_successful_endpoint(resolution_report) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Copy first resolved endpoint attempted, which may be the same as the successful endpoint.
///
///
/// Parameter `resolution_report`: A resolution report.
///
///
/// Returns: The first resolved endpoint attempted.
///
/// # Safety
///
/// `resolution_report` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_resolution_report_copy_preferred_endpoint(
    resolution_report: NonNull<nw_resolution_report_t>,
) -> NWRetained<nw_endpoint_t> {
    extern "C-unwind" {
        fn nw_resolution_report_copy_preferred_endpoint(
            resolution_report: NonNull<nw_resolution_report_t>,
        ) -> Option<NonNull<nw_endpoint_t>>;
    }
    let ret = unsafe { nw_resolution_report_copy_preferred_endpoint(resolution_report) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// The protocol used for endpoint resolution.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_report_resolution_protocol_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_report_resolution_protocol_t(pub c_uint);
impl nw_report_resolution_protocol_t {
    #[doc(alias = "nw_report_resolution_protocol_unknown")]
    pub const unknown: Self = Self(0);
    #[doc(alias = "nw_report_resolution_protocol_udp")]
    pub const udp: Self = Self(1);
    #[doc(alias = "nw_report_resolution_protocol_tcp")]
    pub const tcp: Self = Self(2);
    #[doc(alias = "nw_report_resolution_protocol_tls")]
    pub const tls: Self = Self(3);
    #[doc(alias = "nw_report_resolution_protocol_https")]
    pub const https: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_report_resolution_protocol_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_report_resolution_protocol_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Check the protocol used for endpoint resolution.
    ///
    ///
    /// Parameter `resolution_report`: A resolution report.
    ///
    ///
    /// Returns: The protocol used for endpoint resolution.
    ///
    /// # Safety
    ///
    /// `resolution_report` must be a valid pointer.
    pub fn nw_resolution_report_get_protocol(
        resolution_report: NonNull<nw_resolution_report_t>,
    ) -> nw_report_resolution_protocol_t;
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_report_resolution_enumerator_t?language=objc)
pub type nw_report_resolution_enumerator_t = *mut block2::DynBlock<
    dyn Fn(
        nw_report_resolution_source_t,
        u64,
        u32,
        NonNull<nw_endpoint_t>,
        NonNull<nw_endpoint_t>,
    ) -> bool,
>;

extern "C-unwind" {
    /// Enumerate the steps of connection establishment that involved endpoint
    /// resolution, such as DNS hostname resolution and Bonjour service resolution.
    /// The provided block will be called inline zero or more times.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Parameter `enumerate_block`: A block to be invoked zero or more times, once for each step of resolution
    /// used during connection establishment.
    ///
    /// The values passed to the enumerator are:
    /// - source: The source of the resolution (query or cache).
    /// - milliseconds: The number of milliseconds spent on this resolution step.
    /// - endpoint_count: The number of resolved endpoints discovered by the resolution step.
    /// - successful_endpoint: The resolved endpoint that led to a successful connection.
    /// - preferred_endpoint: The first resolved endpoint attempted, which may be the same as the successful_endpoint.
    ///
    /// Returning true from the block indicates that the enumeration should continue.
    /// Returning false indicates that the enumeration should stop.
    ///
    /// # Safety
    ///
    /// - `report` must be a valid pointer.
    /// - `enumerate_block` must be a valid pointer.
    pub fn nw_establishment_report_enumerate_resolutions(
        report: NonNull<nw_establishment_report_t>,
        enumerate_block: nw_report_resolution_enumerator_t,
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_report_resolution_report_enumerator_t?language=objc)
pub type nw_report_resolution_report_enumerator_t =
    *mut block2::DynBlock<dyn Fn(NonNull<nw_resolution_report_t>) -> bool>;

extern "C-unwind" {
    /// Enumerate the steps of connection establishment that involved endpoint
    /// resolution, such as DNS hostname resolution and Bonjour service resolution.
    /// This variant provides resolution report objects, which allow more detailed
    /// access to information.
    ///
    /// The provided block will be called inline zero or more times.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Parameter `enumerate_block`: A block to be invoked zero or more times, once for each step of resolution
    /// used during connection establishment. Each block contains a nw_resolution_report_t.
    ///
    /// Returning true from the block indicates that the enumeration should continue.
    /// Returning false indicates that the enumeration should stop.
    ///
    /// # Safety
    ///
    /// - `report` must be a valid pointer.
    /// - `enumerate_block` must be a valid pointer.
    pub fn nw_establishment_report_enumerate_resolution_reports(
        report: NonNull<nw_establishment_report_t>,
        enumerate_block: nw_report_resolution_report_enumerator_t,
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_report_protocol_enumerator_t?language=objc)
pub type nw_report_protocol_enumerator_t =
    *mut block2::DynBlock<dyn Fn(NonNull<nw_protocol_definition_t>, u64, u64) -> bool>;

extern "C-unwind" {
    /// Enumerate the protocols used in the established connection.
    /// The provided block will be called inline zero or more times.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Parameter `enumerate_block`: A block to be invoked zero or more times, once for each protocol
    /// used in the established connection.
    ///
    /// The values passed to the enumerator are:
    /// - protocol: The protocol definition.
    /// - handshake_milliseconds: The number of milliseconds spent on the protocol's handshake.
    /// - handshake_rtt_milliseconds: The round trip time in milliseconds measured by the protocol's handshake.
    ///
    /// Returning true from the block indicates that the enumeration should continue.
    /// Returning false indicates that the enumeration should stop.
    ///
    /// # Safety
    ///
    /// - `report` must be a valid pointer.
    /// - `enumerate_block` must be a valid pointer.
    pub fn nw_establishment_report_enumerate_protocols(
        report: NonNull<nw_establishment_report_t>,
        enumerate_block: nw_report_protocol_enumerator_t,
    );
}

/// Create a new data transfer report on a connection. Multiple
/// reports may be created for a single connection. The report begins
/// capturing data when the connection becomes ready, or when the
/// report is created (whichever occurs last).
///
/// Call nw_data_transfer_report_collect() to complete collection of
/// report, after which point the details of the report will be available.
///
///
/// Parameter `connection`: A connection object, in or before the ready state.
///
///
/// Returns: Returns an allocated nw_data_transfer_report_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
/// Returns NULL on failure. Fails due to invalid parameters.
///
/// # Safety
///
/// `connection` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_connection_create_new_data_transfer_report(
    connection: NonNull<nw_connection_t>,
) -> NWRetained<nw_data_transfer_report_t> {
    extern "C-unwind" {
        fn nw_connection_create_new_data_transfer_report(
            connection: NonNull<nw_connection_t>,
        ) -> Option<NonNull<nw_data_transfer_report_t>>;
    }
    let ret = unsafe { nw_connection_create_new_data_transfer_report(connection) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// The state of a Data Transfer Report indicates whether or not the contents
/// have been collected, and are ready to be accessed.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_data_transfer_report_state_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_data_transfer_report_state_t(pub c_uint);
impl nw_data_transfer_report_state_t {
    #[doc(alias = "nw_data_transfer_report_state_collecting")]
    pub const collecting: Self = Self(1);
    #[doc(alias = "nw_data_transfer_report_state_collected")]
    pub const collected: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_data_transfer_report_state_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_data_transfer_report_state_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Access the state of a data transfer report. Once a report
    /// is "collected", individual fields may be read.
    ///
    ///
    /// Parameter `report`: A data transfer report to check.
    ///
    ///
    /// Returns: Returns the current state of the data transfer report.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    pub fn nw_data_transfer_report_get_state(
        report: NonNull<nw_data_transfer_report_t>,
    ) -> nw_data_transfer_report_state_t;
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_data_transfer_report_collect_block_t?language=objc)
pub type nw_data_transfer_report_collect_block_t =
    *mut block2::DynBlock<dyn Fn(NonNull<nw_data_transfer_report_t>)>;

extern "C-unwind" {
    /// Mark a data transfer report as complete, and request collection of
    /// values. Once the report has been collected, the callback block
    /// will be invoked exactly once on the provided dispatch queue.
    ///
    /// If a connection is cancelled or fails prior to the report being collected,
    /// the report will automatically be collected. Calling
    /// nw_data_transfer_report_collect() will be redundant but not harmful.
    ///
    ///
    /// Parameter `report`: A data transfer report to check.
    ///
    ///
    /// Parameter `queue`: The dispatch queue on which to call the collect_block.
    ///
    ///
    /// Parameter `collect_block`: A block to invoke once the report has been collected.
    ///
    /// # Safety
    ///
    /// - `report` must be a valid pointer.
    /// - `collect_block` must be a valid pointer.
    pub fn nw_data_transfer_report_collect(
        report: NonNull<nw_data_transfer_report_t>,
        queue: &DispatchQueue,
        collect_block: nw_data_transfer_report_collect_block_t,
    );
}

extern "C" {
    /// Pass NW_ALL_PATHS to data transfer report accessors to sum
    /// values across paths where applicable. For values that cannot
    /// sum, the value of the primary path is used.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/network/_nw_data_transfer_report_all_paths?language=objc)
    pub static _nw_data_transfer_report_all_paths: u32;
}

extern "C-unwind" {
    /// Retrieve the duration of the data transfer report. This is a length
    /// of time in milliseconds which can be used to calculate throughput
    /// when compared to application and transport byte counts.
    ///
    /// The start time is calculated from when the report was created, or the connection
    /// became ready if the connection was not ready when the report was created.
    /// The duration ends when the report is collected, or the connection fails
    /// or is cancelled.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Returns: Returns the duration of the data transport report in milliseconds, or 0
    /// if the report is not in the "collected" state.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    pub fn nw_data_transfer_report_get_duration_milliseconds(
        report: NonNull<nw_data_transfer_report_t>,
    ) -> u64;
}

extern "C-unwind" {
    /// Retrieve the number of paths used by the connection for the
    /// duration of the report. Any value greater than or equal to 0 and
    /// less than this count may be used as a "path_index" for retrieving
    /// specific details from the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Returns: Returns the number of paths used by the connection, which
    /// limits the value of the "path_index" parameter used in other report
    /// functions. Returns 0 if the report is not in the "collected" state.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    pub fn nw_data_transfer_report_get_path_count(
        report: NonNull<nw_data_transfer_report_t>,
    ) -> u32;
}

extern "C-unwind" {
    /// Retrieve the number of IP packets received on a given path for the
    /// duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of IP packets received, or 0
    /// if the report is not in the "collected" state.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    pub fn nw_data_transfer_report_get_received_ip_packet_count(
        report: NonNull<nw_data_transfer_report_t>,
        path_index: u32,
    ) -> u64;
}

extern "C-unwind" {
    /// Retrieve the number of IP packets sent on a given path for the
    /// duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of IP packets sent, or 0 if the report is not
    /// in the "collected" state.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    pub fn nw_data_transfer_report_get_sent_ip_packet_count(
        report: NonNull<nw_data_transfer_report_t>,
        path_index: u32,
    ) -> u64;
}

extern "C-unwind" {
    /// Retrieve the number of transport protocol bytes (such as TCP stream bytes)
    /// received on a given path for the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of transport protocol bytes received, or 0 if the
    /// report is not in the "collected" state.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    pub fn nw_data_transfer_report_get_received_transport_byte_count(
        report: NonNull<nw_data_transfer_report_t>,
        path_index: u32,
    ) -> u64;
}

extern "C-unwind" {
    /// Retrieve the number of duplicate transport protocol bytes (such as
    /// duplicate TCP bytes) received on a given path for the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of duplicate transport protocol bytes received, or 0
    /// if the report is not in the "collected" state.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    pub fn nw_data_transfer_report_get_received_transport_duplicate_byte_count(
        report: NonNull<nw_data_transfer_report_t>,
        path_index: u32,
    ) -> u64;
}

extern "C-unwind" {
    /// Retrieve the number of out-of-order transport protocol bytes (such as
    /// out-of-order TCP bytes) received on a given path for the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of out-of-order transport protocol bytes received, or 0
    /// if the report is not in the "collected" state.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    pub fn nw_data_transfer_report_get_received_transport_out_of_order_byte_count(
        report: NonNull<nw_data_transfer_report_t>,
        path_index: u32,
    ) -> u64;
}

extern "C-unwind" {
    /// Retrieve the number of transport protocol bytes (such as TCP stream bytes)
    /// sent on a given path for the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of transport protocol bytes sent, or 0
    /// if the report is not in the "collected" state.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    pub fn nw_data_transfer_report_get_sent_transport_byte_count(
        report: NonNull<nw_data_transfer_report_t>,
        path_index: u32,
    ) -> u64;
}

extern "C-unwind" {
    /// Retrieve the number of retransmitted transport protocol bytes (such as
    /// retransmitted TCP bytes) sent on a given path for the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of retransmitted transport protocol bytes sent, or 0
    /// if the report is not in the "collected" state.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    pub fn nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(
        report: NonNull<nw_data_transfer_report_t>,
        path_index: u32,
    ) -> u64;
}

extern "C-unwind" {
    /// Retrieve the smoothed average for the transport protocol's round trip time
    /// (RTT) on a given path for the duration of the report, measured in milliseconds.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// For non-multipath connections, pass 0 as the path index to access
    /// the single path. Passing NW_ALL_PATHS for this function is
    /// equivalent to passing 0.
    ///
    ///
    /// Returns: Returns the smoothed RTT as measured by the transport protocol, or 0
    /// if the report is not in the "collected" state.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    pub fn nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds(
        report: NonNull<nw_data_transfer_report_t>,
        path_index: u32,
    ) -> u64;
}

extern "C-unwind" {
    /// Retrieve the minimum (best) round trip time (RTT) on a given path for
    /// the duration of the report, measured in milliseconds.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// For non-multipath connections, pass 0 as the path index to access
    /// the single path. Passing NW_ALL_PATHS for this function is
    /// equivalent to passing 0.
    ///
    ///
    /// Returns: Returns the minimum RTT as measured by the transport protocol, or 0
    /// if the report is not in the "collected" state.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    pub fn nw_data_transfer_report_get_transport_minimum_rtt_milliseconds(
        report: NonNull<nw_data_transfer_report_t>,
        path_index: u32,
    ) -> u64;
}

extern "C-unwind" {
    /// Retrieve the variance of the round trip time (RTT) on a given path for
    /// the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// For non-multipath connections, pass 0 as the path index to access
    /// the single path. Passing NW_ALL_PATHS for this function is
    /// equivalent to passing 0.
    ///
    ///
    /// Returns: Returns the RTT variance as measured by the transport protocol, or 0
    /// if the report is not in the "collected" state.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    pub fn nw_data_transfer_report_get_transport_rtt_variance(
        report: NonNull<nw_data_transfer_report_t>,
        path_index: u32,
    ) -> u64;
}

extern "C-unwind" {
    /// Retrieve the number of application bytes received on a given
    /// path for the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of application bytes received, or 0
    /// if the report is not in the "collected" state.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    pub fn nw_data_transfer_report_get_received_application_byte_count(
        report: NonNull<nw_data_transfer_report_t>,
        path_index: u32,
    ) -> u64;
}

extern "C-unwind" {
    /// Retrieve the number of application bytes sent on a given
    /// path for the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of application bytes sent, or 0
    /// if the report is not in the "collected" state.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    pub fn nw_data_transfer_report_get_sent_application_byte_count(
        report: NonNull<nw_data_transfer_report_t>,
        path_index: u32,
    ) -> u64;
}

/// Retrieve the interface used for data transfer for a given
/// path used by a connection.
///
///
/// Parameter `report`: A data transfer report in the "collected" state.
///
///
/// Parameter `path_index`: The index for the path over which data is transferred.
/// Passing NW_ALL_PATHS for this function is
/// equivalent to passing 0.
///
///
/// Returns: Returns a retained nw_interface_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
/// Returns NULL on failure. Fails if the report is not yet collected.
///
/// # Safety
///
/// `report` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_data_transfer_report_copy_path_interface(
    report: NonNull<nw_data_transfer_report_t>,
    path_index: u32,
) -> NWRetained<nw_interface_t> {
    extern "C-unwind" {
        fn nw_data_transfer_report_copy_path_interface(
            report: NonNull<nw_data_transfer_report_t>,
            path_index: u32,
        ) -> Option<NonNull<nw_interface_t>>;
    }
    let ret = unsafe { nw_data_transfer_report_copy_path_interface(report, path_index) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Retrieve the radio type used for data transfer for a given
    /// path used by a connection.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function is
    /// equivalent to passing 0.
    ///
    ///
    /// Returns: Returns the radio type used for the specified path.
    /// Returns nw_interface_radio_type_unknown on failure.
    /// Fails if the report is not yet collected.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    pub fn nw_data_transfer_report_get_path_radio_type(
        report: NonNull<nw_data_transfer_report_t>,
        path_index: u32,
    ) -> nw_interface_radio_type_t;
}

/// Channel states sent by nw_ethernet_channel_set_state_changed_handler.
/// States generally progress forward and do not move backwards, with the
/// exception of preparing and waiting, which may alternate before the channel
/// becomes ready or failed.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ethernet_channel_state_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_ethernet_channel_state_t(pub c_uint);
impl nw_ethernet_channel_state_t {
    /// will never be delivered in the channel's state update handler, and can be treated as
    /// an unexpected value.
    #[doc(alias = "nw_ethernet_channel_state_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_ethernet_channel_state_waiting")]
    pub const waiting: Self = Self(1);
    #[doc(alias = "nw_ethernet_channel_state_preparing")]
    pub const preparing: Self = Self(2);
    #[doc(alias = "nw_ethernet_channel_state_ready")]
    pub const ready: Self = Self(3);
    #[doc(alias = "nw_ethernet_channel_state_failed")]
    pub const failed: Self = Self(4);
    #[doc(alias = "nw_ethernet_channel_state_cancelled")]
    pub const cancelled: Self = Self(5);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ethernet_channel_state_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ethernet_channel_state_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Creates an Ethernet channel with a custom EtherType.
///
///
/// Parameter `ether_type`: The custom EtherType to be used for all Ethernet frames in this channel. The
/// EtherType is the two-octet field in an Ethernet frame, indicating the protocol
/// encapsulated in the payload of the frame.  This parameter is in little-endian
/// byte order.  Only custom EtherType values are supported. This parameter cannot
/// be an EtherType already handled by the system, such as IPv4, IPv6, ARP, VLAN Tag,
/// or 802.1x.
///
/// Calling processes must hold the "com.apple.developer.networking.custom-protocol"
/// entitlement.
///
///
/// Parameter `interface`: The interface on which this custom Ethernet channel will be allowed.
///
///
/// Returns: Returns an allocated nw_ethernet_channel_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
/// Returns NULL on failure. Fails due to invalid parameters.
///
/// # Safety
///
/// `interface` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_ethernet_channel_create(
    ether_type: u16,
    interface: NonNull<nw_interface_t>,
) -> NWRetained<nw_ethernet_channel_t> {
    extern "C-unwind" {
        fn nw_ethernet_channel_create(
            ether_type: u16,
            interface: NonNull<nw_interface_t>,
        ) -> Option<NonNull<nw_ethernet_channel_t>>;
    }
    let ret = unsafe { nw_ethernet_channel_create(ether_type, interface) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Creates an Ethernet channel with a custom EtherType and networking parameters
///
///
/// Parameter `ether_type`: The custom EtherType to be used for all Ethernet frames in this channel. The
/// EtherType is the two-octet field in an Ethernet frame, indicating the protocol
/// encapsulated in the payload of the frame.  This parameter is in little-endian
/// byte order.  Only custom EtherType values are supported. This parameter cannot
/// be an EtherType already handled by the system, such as IPv4, IPv6, ARP, VLAN Tag,
/// or 802.1x.
///
/// Calling processes must hold the "com.apple.developer.networking.custom-protocol"
/// entitlement.
///
///
/// Parameter `interface`: The interface on which this custom Ethernet channel will be allowed.
///
///
/// Parameter `parameters`: nw_parameters_t that allows caller to specify networking parameters such as custom context and queue.
///
///
/// Returns: Returns an allocated nw_ethernet_channel_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
/// Returns NULL on failure. Fails due to invalid parameters.
///
/// # Safety
///
/// - `interface` must be a valid pointer.
/// - `parameters` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_ethernet_channel_create_with_parameters(
    ether_type: u16,
    interface: NonNull<nw_interface_t>,
    parameters: NonNull<nw_parameters_t>,
) -> NWRetained<nw_ethernet_channel_t> {
    extern "C-unwind" {
        fn nw_ethernet_channel_create_with_parameters(
            ether_type: u16,
            interface: NonNull<nw_interface_t>,
            parameters: NonNull<nw_parameters_t>,
        ) -> Option<NonNull<nw_ethernet_channel_t>>;
    }
    let ret =
        unsafe { nw_ethernet_channel_create_with_parameters(ether_type, interface, parameters) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// A state change handler to handle state changes.
///
///
/// Parameter `state`: The current state.
///
///
/// Parameter `error`: error if present, indicates the reason of the failure.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ethernet_channel_state_changed_handler_t?language=objc)
pub type nw_ethernet_channel_state_changed_handler_t =
    *mut block2::DynBlock<dyn Fn(nw_ethernet_channel_state_t, *mut nw_error_t)>;

extern "C-unwind" {
    /// Sets the state change handler. For clients that need to perform cleanup when the
    /// channel has been cancelled, the nw_ethernet_channel_state_cancelled state will
    /// be delivered last.
    ///
    ///
    /// Parameter `ethernet_channel`: The ethernet_channel object.
    ///
    ///
    /// Parameter `handler`: The state changed handler to call when the channel state changes.
    /// Pass NULL to remove the state changed handler.
    ///
    /// # Safety
    ///
    /// - `ethernet_channel` must be a valid pointer.
    /// - `handler` must be a valid pointer or null.
    pub fn nw_ethernet_channel_set_state_changed_handler(
        ethernet_channel: NonNull<nw_ethernet_channel_t>,
        handler: nw_ethernet_channel_state_changed_handler_t,
    );
}

extern "C-unwind" {
    /// Sets the client callback queue, on which blocks for events will
    /// be scheduled. This must be done before calling nw_ethernet_channel_start().
    ///
    ///
    /// Parameter `ethernet_channel`: The ethernet_channel object.
    ///
    ///
    /// Parameter `queue`: The client's dispatch queue.
    ///
    /// # Safety
    ///
    /// `ethernet_channel` must be a valid pointer.
    pub fn nw_ethernet_channel_set_queue(
        ethernet_channel: NonNull<nw_ethernet_channel_t>,
        queue: &DispatchQueue,
    );
}

extern "C-unwind" {
    /// Returns the maximum payload size that can be written
    /// on the channel. Any payloads written must be less than
    /// or equal to this size.  Payloads exceeding this size will be
    /// dropped by 'nw_ethernet_channel_send()'.
    ///
    ///
    /// Parameter `ethernet_channel`: The ethernet_channel object.
    ///
    ///
    /// Returns: Returns a payload size based on the current MTU of the channel.
    ///
    /// # Safety
    ///
    /// `ethernet_channel` must be a valid pointer.
    pub fn nw_ethernet_channel_get_maximum_payload_size(
        ethernet_channel: NonNull<nw_ethernet_channel_t>,
    ) -> u32;
}

extern "C-unwind" {
    /// Starts the Ethernet channel, which will cause the channel to evaluate
    /// its path, and try to become readable and writable.
    ///
    ///
    /// Parameter `ethernet_channel`: The ethernet_channel object.
    ///
    /// # Safety
    ///
    /// `ethernet_channel` must be a valid pointer.
    pub fn nw_ethernet_channel_start(ethernet_channel: NonNull<nw_ethernet_channel_t>);
}

extern "C-unwind" {
    /// Cancel the Ethernet channel. This will close the channel. The process of cancellation will be
    /// completed asynchronously, and the final callback event delivered to the caller will be
    /// a state update with a value of nw_ethernet_channel_state_cancelled. Once this update is
    /// delivered, the caller may clean up any associated memory or objects.
    ///
    /// Outstanding sends and receives will receive errors before the state changes to cancelled.
    /// There is no guarantee that any outstanding sends that have not yet delivered
    /// completion handlers will send data before the channel is closed.
    ///
    ///
    /// Parameter `ethernet_channel`: The ethernet_channel object.
    ///
    /// # Safety
    ///
    /// `ethernet_channel` must be a valid pointer.
    pub fn nw_ethernet_channel_cancel(ethernet_channel: NonNull<nw_ethernet_channel_t>);
}

/// This receive handler is invoked when a frame of the set EtherType is received from the Ethernet
/// channel.
///
///
/// Parameter `content`: The received Ethernet payload, which has a length constrained by the maximum Ethernet frame size
/// of 1518 minus Ethernet header size of (18/14 bytes with/without vlan tag).
///
///
/// Parameter `vlan_tag`: The vlan tag of the frame, 0 if there is no vlan tag.  This parameter is in little-endian
/// byte order.
///
///
/// Parameter `local_address`: The local Ethernet address in the received Ethernet frame header.
///
///
/// Parameter `remote_address`: The remote Ethernet address in the received Ethernet frame header.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ethernet_channel_receive_handler_t?language=objc)
pub type nw_ethernet_channel_receive_handler_t = *mut block2::DynBlock<
    dyn Fn(NonNull<DispatchData>, u16, nw_ethernet_address_t, nw_ethernet_address_t),
>;

extern "C-unwind" {
    /// Sets the Ethernet channel receive handler. Should be called before nw_ethernet_channel_start.
    ///
    ///
    /// Parameter `ethernet_channel`: The Ethernet channel object.
    ///
    ///
    /// Parameter `handler`: The event handler to call when the Ethernet channel receives a new frame.
    /// Pass NULL to remove the receive handler.
    ///
    /// # Safety
    ///
    /// - `ethernet_channel` must be a valid pointer.
    /// - `handler` must be a valid pointer or null.
    pub fn nw_ethernet_channel_set_receive_handler(
        ethernet_channel: NonNull<nw_ethernet_channel_t>,
        handler: nw_ethernet_channel_receive_handler_t,
    );
}

/// A send completion is invoked exactly once for a call to nw_ethernet_channel_send().
/// The completion indicates that the sent Ethernet frame has been processed by the stack
/// (not necessarily that it has left the host), or else an error has occurred during
/// sending.
///
///
/// Parameter `error`: An error will be sent if the associated frame could not be fully sent before an
/// error occurred. An error will be sent for any outstanding sends when the channel
/// is cancelled.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ethernet_channel_send_completion_t?language=objc)
pub type nw_ethernet_channel_send_completion_t = *mut block2::DynBlock<dyn Fn(*mut nw_error_t)>;

extern "C-unwind" {
    /// Send an Ethernet frame on a channel.  This must be called after the channel
    /// becomes ready.  This is an asynchronous send and the completion block can be used
    /// to determine when the send is complete.
    ///
    ///
    /// Parameter `ethernet_channel`: The ethernet_channel object on which to send frame.
    ///
    ///
    /// Parameter `content`: An Ethernet payload to send.
    ///
    ///
    /// Parameter `vlan_tag`: The vlan tag of the frame.  If vlan_tag is specified, the 802.1Q tag will be included.
    /// TPID will be set to 0x8100 followed by the specified 16-bit vlan_tag (only the highest
    /// 3-bit class of service field is supported.  The remaining 13 bits must be set to zero).
    /// Pass 0 to omit the vlan tag for this frame.
    ///
    ///
    /// Parameter `remote_address`: Remote Ethernet address for this Ethernet frame.  This is a required parameter.
    /// Note that the local Ethernet address will be the Ethernet address of the specified
    /// interface of this Ethernet channel.
    ///
    ///
    /// Parameter `completion`: A callback to be called when the data has been sent, or an error has occurred.
    /// This callback does not indicate that the remote side has acknowledged the data.
    /// This callback does indicate that the data has been sent.
    ///
    /// # Safety
    ///
    /// - `ethernet_channel` must be a valid pointer.
    /// - `remote_address` Array TODO.
    /// - `completion` must be a valid pointer.
    pub fn nw_ethernet_channel_send(
        ethernet_channel: NonNull<nw_ethernet_channel_t>,
        content: &DispatchData,
        vlan_tag: u16,
        remote_address: nw_ethernet_address_t,
        completion: nw_ethernet_channel_send_completion_t,
    );
}

/// A framer message is an instance of protocol metadata associated
/// with the definition of a framer, created by nw_framer_create_definition().
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_message_t?language=objc)
pub type nw_framer_message_t = *mut nw_protocol_metadata_t;

extern "C-unwind" {
    /// Create an instance of a framer message on which per-
    /// message options can be configured when sending data
    /// on a connection. This is intended to be used by the
    /// application above the connection to send message data
    /// down to the framer protocol instance.
    ///
    ///
    /// Parameter `definition`: The framer protocol definition, as retrieved from
    /// nw_protocol_options_copy_definition() on the framer options.
    ///
    ///
    /// Returns: Returns a retained protocol metadata object.
    ///
    /// # Safety
    ///
    /// `definition` must be a valid pointer.
    pub fn nw_framer_protocol_create_message(
        definition: NonNull<nw_protocol_definition_t>,
    ) -> nw_framer_message_t;
}

extern "C-unwind" {
    /// Checks if a protocol metadata object is a framer protocol
    /// message. This indicates whether or not it is compatible
    /// with the framer message setters and accessors.
    ///
    ///
    /// Parameter `metadata`: The protocol metadata to check.
    ///
    ///
    /// Returns: Returns true if the metadata is associated with a framer
    /// protocol definition, false otherwise.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_protocol_metadata_is_framer_message(
        metadata: NonNull<nw_protocol_metadata_t>,
    ) -> bool;
}

extern "C-unwind" {
    /// Create a framer message, given a framer instance. This
    /// is intended to be used within the implementation of
    /// the framer protocol to create messages that are delivered
    /// as input to the application.
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Returns: Returns a retained framer message object.
    ///
    /// # Safety
    ///
    /// `framer` must be a valid pointer.
    pub fn nw_framer_message_create(framer: NonNull<nw_framer_t>) -> nw_framer_message_t;
}

/// A block to be invoked when a value stored in a framer message is disposed.
/// If the value was created using malloc(), for example, it should be freed here.
///
///
/// Parameter `value`: A pointer to the stored message value.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_message_dispose_value_t?language=objc)
pub type nw_framer_message_dispose_value_t = *mut block2::DynBlock<dyn Fn(NonNull<c_void>)>;

extern "C-unwind" {
    /// Set a key-value pair on a framer message, with a custom
    /// dispose function for the value.
    ///
    ///
    /// Parameter `message`: The framer message object.
    ///
    ///
    /// Parameter `key`: The string key to identify the value.
    ///
    ///
    /// Parameter `value`: A pointer to the value to store.
    ///
    ///
    /// Parameter `dispose_value`: A block to invoke to dispose the stored value.
    ///
    /// # Safety
    ///
    /// - `message` must be a valid pointer.
    /// - `key` must be a valid pointer.
    /// - `value` must be a valid pointer or null.
    /// - `dispose_value` must be a valid pointer or null.
    pub fn nw_framer_message_set_value(
        message: nw_framer_message_t,
        key: NonNull<c_char>,
        value: *mut c_void,
        dispose_value: nw_framer_message_dispose_value_t,
    );
}

extern "C-unwind" {
    /// Access the value with a key on a framer message.
    ///
    ///
    /// Parameter `message`: The framer message object.
    ///
    ///
    /// Parameter `key`: The string key to identify the value.
    ///
    ///
    /// Parameter `access_value`: A block to invoke inline with the pointer to the stored value.
    /// This pointer may be NULL if no value is stored for the key.
    ///
    ///
    /// Returns: Returns the boolean value returned by the access_value block,
    /// or else false if the parameters were invalid.
    ///
    /// # Safety
    ///
    /// - `message` must be a valid pointer.
    /// - `key` must be a valid pointer.
    pub fn nw_framer_message_access_value(
        message: nw_framer_message_t,
        key: NonNull<c_char>,
        access_value: &block2::DynBlock<dyn Fn(*const c_void) -> bool>,
    ) -> bool;
}

extern "C-unwind" {
    /// Set a key-value pair on a framer message, where the
    /// value is a reference-counted object.
    ///
    ///
    /// Parameter `message`: The framer message object.
    ///
    ///
    /// Parameter `key`: The string key to identify the value.
    ///
    ///
    /// Parameter `value`: A reference counted object to store.
    ///
    /// # Safety
    ///
    /// - `message` must be a valid pointer.
    /// - `key` must be a valid pointer.
    /// - `value` should be of the correct type.
    #[cfg(feature = "objc2")]
    pub fn nw_framer_message_set_object_value(
        message: nw_framer_message_t,
        key: NonNull<c_char>,
        value: Option<&AnyObject>,
    );
}

/// Copy the stored object value using a key on a framer message.
///
///
/// Parameter `message`: The framer message object.
///
///
/// Parameter `key`: The string key to identify the value.
///
///
/// Returns: Returns a reference counted object with a +1 reference count,
/// or NULL if no value was found for the specified key.
///
/// # Safety
///
/// - `message` must be a valid pointer.
/// - `key` must be a valid pointer.
#[cfg(feature = "objc2")]
#[inline]
pub unsafe extern "C-unwind" fn nw_framer_message_copy_object_value(
    message: nw_framer_message_t,
    key: NonNull<c_char>,
) -> Option<Retained<AnyObject>> {
    extern "C-unwind" {
        fn nw_framer_message_copy_object_value(
            message: nw_framer_message_t,
            key: NonNull<c_char>,
        ) -> *mut AnyObject;
    }
    let ret = unsafe { nw_framer_message_copy_object_value(message, key) };
    unsafe { Retained::from_raw(ret) }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_start_result_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_framer_start_result_t(pub c_uint);
impl nw_framer_start_result_t {
    #[doc(alias = "nw_framer_start_result_ready")]
    pub const ready: Self = Self(1);
    #[doc(alias = "nw_framer_start_result_will_mark_ready")]
    pub const will_mark_ready: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_framer_start_result_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_framer_start_result_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A block to be invoked when starting a new instance of the framer
/// protocol. This may occur more than once for a single nw_connection.
///
///
/// Parameter `framer`: A new instance of the framer protocol. This handle should be used
/// to set callbacks, such as with nw_framer_set_input_handler()
/// and nw_framer_set_output_handler(); and to perform actions, such
/// as nw_framer_deliver_input() and nw_framer_write_output().
///
///
/// Returns: Return whether or not the start should implicitly mark the protocol
/// as "ready" using nw_framer_start_result_ready, or that the protocol
/// will call nw_framer_mark_ready() later using
/// nw_framer_start_result_will_mark_ready.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_start_handler_t?language=objc)
pub type nw_framer_start_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<nw_framer_t>) -> nw_framer_start_result_t>;

/// Create a protocol definition for a custom framer protocol.
///
///
/// Parameter `identifier`: A string identifier used to name this framer protocol. This does not
/// define uniqueness, and is primarily used for logging and debugging.
///
///
/// Parameter `flags`: Flags to describe extended options on framer protocol behavior,
/// all prefixed with "NW_FRAMER_CREATE_FLAGS_".
///
///
/// Parameter `start_handler`: A block to be invoked when starting a new instance of the framer
/// protocol. This may occur more than once for a single nw_connection.
///
///
/// Returns: Returns a retained protocol definition that can be used with protocol
/// options and metadata.
///
/// # Safety
///
/// - `identifier` must be a valid pointer.
/// - `start_handler` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_framer_create_definition(
    identifier: NonNull<c_char>,
    flags: u32,
    start_handler: nw_framer_start_handler_t,
) -> NWRetained<nw_protocol_definition_t> {
    extern "C-unwind" {
        fn nw_framer_create_definition(
            identifier: NonNull<c_char>,
            flags: u32,
            start_handler: nw_framer_start_handler_t,
        ) -> Option<NonNull<nw_protocol_definition_t>>;
    }
    let ret = unsafe { nw_framer_create_definition(identifier, flags, start_handler) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Create protocol options from a framer definition. This object can
/// be added to an nw_protocol_stack_t to be used in an nw_connection_t
/// or an nw_listener_t.
///
///
/// Parameter `framer_definition`: A protocol definition created with nw_framer_create_definition().
///
///
/// Returns: Returns a retained protocol options object to add into a protocol
/// stack.
///
/// # Safety
///
/// `framer_definition` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_framer_create_options(
    framer_definition: NonNull<nw_protocol_definition_t>,
) -> NWRetained<nw_protocol_options_t> {
    extern "C-unwind" {
        fn nw_framer_create_options(
            framer_definition: NonNull<nw_protocol_definition_t>,
        ) -> Option<NonNull<nw_protocol_options_t>>;
    }
    let ret = unsafe { nw_framer_create_options(framer_definition) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Set a key-value pair on framer options, where the
    /// value is a reference-counted object.
    ///
    ///
    /// Parameter `options`: The framer options object.
    ///
    ///
    /// Parameter `key`: The string key to identify the value.
    ///
    ///
    /// Parameter `value`: A reference counted object to store.
    ///
    /// # Safety
    ///
    /// - `options` must be a valid pointer.
    /// - `key` must be a valid pointer.
    /// - `value` should be of the correct type.
    #[cfg(feature = "objc2")]
    pub fn nw_framer_options_set_object_value(
        options: NonNull<nw_protocol_options_t>,
        key: NonNull<c_char>,
        value: Option<&AnyObject>,
    );
}

/// Copy the stored object value using a key on framer options.
///
///
/// Parameter `options`: The framer options object.
///
///
/// Parameter `key`: The string key to identify the value.
///
///
/// Returns: Returns a reference counted object with a +1 reference count,
/// or NULL if no value was found for the specified key.
///
/// # Safety
///
/// - `options` must be a valid pointer.
/// - `key` must be a valid pointer.
#[cfg(feature = "objc2")]
#[inline]
pub unsafe extern "C-unwind" fn nw_framer_options_copy_object_value(
    options: NonNull<nw_protocol_options_t>,
    key: NonNull<c_char>,
) -> Option<Retained<AnyObject>> {
    extern "C-unwind" {
        fn nw_framer_options_copy_object_value(
            options: NonNull<nw_protocol_options_t>,
            key: NonNull<c_char>,
        ) -> *mut AnyObject;
    }
    let ret = unsafe { nw_framer_options_copy_object_value(options, key) };
    unsafe { Retained::from_raw(ret) }
}

/// A handler block to be invoked whenever new input
/// data is available to be parsed. When this block is
/// run, the implementation should call functions like
/// nw_framer_parse_input() and nw_framer_deliver_input().
///
/// Each invocation represents new data being available
/// to read from the network. This data may be insufficient
/// to complete a message, or may contain multiple messages.
/// Implementations are expected to try to parse messages
/// in a loop until parsing fails to read enough to continue.
///
///
/// Parameter `framer`: The instance of the framer protocol.
///
///
/// Returns: Return a hint of the number of bytes that should be present
/// before invoking this handler again. Returning 0 indicates
/// that the handler should be invoked once any data is available.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_input_handler_t?language=objc)
pub type nw_framer_input_handler_t = *mut block2::DynBlock<dyn Fn(NonNull<nw_framer_t>) -> usize>;

extern "C-unwind" {
    /// Set a handler block to be invoked whenever new input
    /// data is available to be parsed. When this block is
    /// run, the implementation should call functions like
    /// nw_framer_parse_input() and nw_framer_deliver_input().
    ///
    /// Input events are edge triggered. The input_handler block
    /// should continue to call nw_framer_parse_input()
    /// until nw_framer_parse_input() can no longer produce
    /// enough bytes to satisfy the request, or the protocol
    /// needs to wait for some other event to continue processing
    /// later.
    ///
    /// This setter is required, and must only be set from within
    /// the invocation of a nw_framer_start_handler_t.
    ///
    ///
    /// Parameter `framer`: The framer instance object, passed via the
    /// nw_framer_start_handler_t block.
    ///
    ///
    /// Parameter `input_handler`: The block to invoke whenever new input data is available.
    ///
    /// # Safety
    ///
    /// - `framer` must be a valid pointer.
    /// - `input_handler` must be a valid pointer.
    pub fn nw_framer_set_input_handler(
        framer: NonNull<nw_framer_t>,
        input_handler: nw_framer_input_handler_t,
    );
}

/// A handler block to be invoked whenever an output
/// message is ready to be sent. When this block is
/// run, the implementation should call functions like
/// nw_framer_parse_output() and nw_framer_write_output().
///
/// Each invocation represents a single complete or partial
/// message that is being sent. The implementation is
/// expected to write this message or let it be dropped
/// in this handler.
///
///
/// Parameter `framer`: The instance of the framer protocol.
///
///
/// Parameter `message`: The framer message being sent.
///
///
/// Parameter `message_length`: The length of the data associated with this message send.
/// If the message is not complete, the length represents the
/// partial message length being sent, which may be smaller
/// than the complete message length.
///
///
/// Parameter `is_complete`: A boolean indicating whether or not the message is now complete.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_output_handler_t?language=objc)
pub type nw_framer_output_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<nw_framer_t>, nw_framer_message_t, usize, bool)>;

extern "C-unwind" {
    /// Set a handler block to be invoked whenever an output
    /// message is ready to be sent. When this block is
    /// run, the implementation should call functions like
    /// nw_framer_parse_output() and nw_framer_write_output().
    ///
    /// This setter is required, and must only be set from within
    /// the invocation of a nw_framer_start_handler_t.
    ///
    ///
    /// Parameter `framer`: The framer instance object, passed via the
    /// nw_framer_start_handler_t block.
    ///
    ///
    /// Parameter `output_handler`: The block to invoke whenever a new output message is ready
    /// to be sent.
    ///
    /// # Safety
    ///
    /// - `framer` must be a valid pointer.
    /// - `output_handler` must be a valid pointer.
    pub fn nw_framer_set_output_handler(
        framer: NonNull<nw_framer_t>,
        output_handler: nw_framer_output_handler_t,
    );
}

/// A handler block to be invoked whenever the wakeup timer
/// set via nw_framer_schedule_wakeup() fires. This is intended to
/// be used for sending keepalives or other control traffic.
///
///
/// Parameter `framer`: The instance of the framer protocol.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_wakeup_handler_t?language=objc)
pub type nw_framer_wakeup_handler_t = *mut block2::DynBlock<dyn Fn(NonNull<nw_framer_t>)>;

extern "C-unwind" {
    /// Set a handler block to be invoked whenever the wakeup timer
    /// set via nw_framer_schedule_wakeup() fires. This is intended to
    /// be used for sending keepalives or other control traffic.
    ///
    /// This setter is optional, and must only be set from within
    /// the invocation of a nw_framer_start_handler_t.
    ///
    ///
    /// Parameter `framer`: The framer instance object, passed via the
    /// nw_framer_start_handler_t block.
    ///
    ///
    /// Parameter `wakeup_handler`: The block to invoke whenever the timeout set by
    /// nw_framer_schedule_wakeup() is reached.
    ///
    /// # Safety
    ///
    /// - `framer` must be a valid pointer.
    /// - `wakeup_handler` must be a valid pointer.
    pub fn nw_framer_set_wakeup_handler(
        framer: NonNull<nw_framer_t>,
        wakeup_handler: nw_framer_wakeup_handler_t,
    );
}

/// A handler block to be invoked when the connection
/// is being disconnected, to allow the framer implementation
/// a chance to send any final data.
///
///
/// Parameter `framer`: The instance of the framer protocol.
///
///
/// Returns: Return true if the framer is done and the connection
/// can be fully disconnected, or false the stop should
/// be delayed. If false, the implementation must later
/// call nw_framer_mark_failed_with_error().
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_stop_handler_t?language=objc)
pub type nw_framer_stop_handler_t = *mut block2::DynBlock<dyn Fn(NonNull<nw_framer_t>) -> bool>;

extern "C-unwind" {
    /// Set a handler block to be invoked when the connection
    /// is being disconnected, to allow the framer implementation
    /// a chance to send any final data.
    ///
    /// This setter is optional, and must only be set from within
    /// the invocation of a nw_framer_start_handler_t.
    ///
    ///
    /// Parameter `framer`: The framer instance object, passed via the
    /// nw_framer_start_handler_t block.
    ///
    ///
    /// Parameter `stop_handler`: The block to invoke when the connection is disconnected.
    ///
    /// # Safety
    ///
    /// - `framer` must be a valid pointer.
    /// - `stop_handler` must be a valid pointer.
    pub fn nw_framer_set_stop_handler(
        framer: NonNull<nw_framer_t>,
        stop_handler: nw_framer_stop_handler_t,
    );
}

/// A handler block to be invoked when the protocol stack
/// is being torn down and deallocated. This is the opportunity
/// for the framer implementation to release any state it may
/// have saved.
///
///
/// Parameter `framer`: The instance of the framer protocol.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_cleanup_handler_t?language=objc)
pub type nw_framer_cleanup_handler_t = *mut block2::DynBlock<dyn Fn(NonNull<nw_framer_t>)>;

extern "C-unwind" {
    /// Set a handler block to be invoked when the protocol stack
    /// is being torn down and deallocated. This is the opportunity
    /// for the framer implementation to release any state it may
    /// have saved.
    ///
    /// This setter is optional, and must only be set from within
    /// the invocation of a nw_framer_start_handler_t.
    ///
    ///
    /// Parameter `framer`: The framer instance object, passed via the
    /// nw_framer_start_handler_t block.
    ///
    ///
    /// Parameter `cleanup_handler`: The block to invoke when the protocol stack is being deallocated.
    ///
    /// # Safety
    ///
    /// - `framer` must be a valid pointer.
    /// - `cleanup_handler` must be a valid pointer.
    pub fn nw_framer_set_cleanup_handler(
        framer: NonNull<nw_framer_t>,
        cleanup_handler: nw_framer_cleanup_handler_t,
    );
}

extern "C-unwind" {
    /// Mark the connection associated with the framer instance
    /// as ready (see nw_connection_state_ready). This is intended
    /// to be used by protocols that require a handshake before being
    /// able to send application data. This should only be called
    /// if the return value to the nw_framer_start_handler_t block
    /// was nw_framer_start_result_will_call_ready.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    /// # Safety
    ///
    /// `framer` must be a valid pointer.
    pub fn nw_framer_mark_ready(framer: NonNull<nw_framer_t>);
}

extern "C-unwind" {
    /// Dynamically add a protocol to a connection establishment
    /// attempt "above" the framer protocol. This means that the
    /// protocol above will start running once the framer becomes
    /// ready by calling nw_framer_mark_ready(). This can only
    /// be used with framers that return a value of
    /// nw_framer_start_result_will_call_ready to their start
    /// handlers. An example of using this functionality is
    /// adding a security protocol, like TLS, above a framer
    /// once that framer completes its initial handshake.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `protocol_options`: Protocol options for an application protocol to dynamically
    /// add "above" the framer.
    ///
    ///
    /// Returns: Returns true if the protocol was successfully added,
    /// or false it it could not be added. This will fail if
    /// the framer is already marked ready.
    ///
    /// # Safety
    ///
    /// - `framer` must be a valid pointer.
    /// - `protocol_options` must be a valid pointer.
    pub fn nw_framer_prepend_application_protocol(
        framer: NonNull<nw_framer_t>,
        protocol_options: NonNull<nw_protocol_options_t>,
    ) -> bool;
}

extern "C-unwind" {
    /// Mark the connection associated with the framer instance
    /// as failed (see nw_connection_state_failed).
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `error_code`: An error code to describe why the connection failed.
    ///
    /// # Safety
    ///
    /// `framer` must be a valid pointer.
    pub fn nw_framer_mark_failed_with_error(framer: NonNull<nw_framer_t>, error_code: c_int);
}

/// A completion block that is invoked inline to parse available
/// bytes, either input or output. This is the way a framer can
/// access the underlying buffer for data being sent or received.
/// The block has a side effect of advancing the parsing cursor
/// by the number of bytes specified in the return value.
///
///
/// Parameter `buffer`: The buffer of bytes being sent or received.
///
///
/// Parameter `buffer_length`: The number of valid bytes in buffer.
///
///
/// Parameter `is_complete`: The boolean indicating if this section of the buffer indicates
/// the end of a message or stream.
///
///
/// Returns: Return the number of bytes by which to advance the input or
/// output cursor. For example, if nw_framer_parse_input() is called
/// and the completion returns 0, calling nw_framer_parse_input() again
/// will allow the implementation to start parsing again at the same
/// start location. However, if the completion returns 10, the next
/// call to nw_framer_parse_input() will return bytes starting from 10
/// bytes beyond the previous call.
///
/// The cursors also define the offsets at which data being delivered
/// or written using nw_framer_deliver_input_no_copy() and
/// nw_framer_write_output_no_copy() will start.
///
/// The returned value for incrementing the cursor may be larger than
/// the length of the buffer just parsed. This allows an implementation
/// to "skip" ahead by a number of bytes if it knows it does not
/// need to parse more.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_parse_completion_t?language=objc)
pub type nw_framer_parse_completion_t =
    *mut block2::DynBlock<dyn Fn(*mut u8, usize, bool) -> usize>;

extern "C-unwind" {
    /// Parse currently available input from the location of the input
    /// cursor in the stream or message being parsed.
    ///
    /// The parse completion block will always be invoked inline exactly once.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `minimum_incomplete_length`: The minimum number of bytes to parse. If this amount is
    /// not available, the parse completion block will be invoked
    /// with 0 bytes.
    ///
    ///
    /// Parameter `maximum_length`: The maximum number of bytes to parse as a contiguous buffer.
    /// If temp_buffer is not NULL, then this represents the length
    /// of valid bytes in temp_buffer.
    ///
    ///
    /// Parameter `temp_buffer`: A buffer provided by the caller to copy parse bytes into.
    /// If it is not NULL, it must have at least maximum_length bytes
    /// available, and any parsed bytes will be copied into the buffer.
    /// Any data stored in temp_buffer will be overwritten.
    /// If it is NULL, the buffer provided in the completion will not
    /// copy unless a copy is required to provide the minimum bytes
    /// as a contiguous buffer. The temp_buffer allows the caller to
    /// guarantee alignment properties of the buffer it parses.
    ///
    ///
    /// Parameter `parse`: The completion that provides the bytes to parse, which will
    /// be called exactly once.
    ///
    ///
    /// Returns: Returns true if the parse succeeded, or false if not enough
    /// bytes were available.
    ///
    /// # Safety
    ///
    /// - `framer` must be a valid pointer.
    /// - `temp_buffer` must be a valid pointer or null.
    /// - `parse` must be a valid pointer.
    pub fn nw_framer_parse_input(
        framer: NonNull<nw_framer_t>,
        minimum_incomplete_length: usize,
        maximum_length: usize,
        temp_buffer: *mut u8,
        parse: nw_framer_parse_completion_t,
    ) -> bool;
}

extern "C-unwind" {
    /// Deliver arbitrary data to the application. This is intended to
    /// deliver any data that is generated or transformed by the
    /// protocol instance. It will incur a copy of bytes.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `input_buffer`: The bytes to deliver to the application. This must be non-NULL.
    /// If an empty message needs to be delivered, use
    /// nw_framer_deliver_input_no_copy().
    ///
    ///
    /// Parameter `input_length`: The length of input_buffer. This must be non-zero.
    ///
    ///
    /// Parameter `message`: The message to associate with the received data.
    ///
    ///
    /// Parameter `is_complete`: A boolean indicating whether or not this data represents
    /// the end of the message.
    ///
    /// # Safety
    ///
    /// - `framer` must be a valid pointer.
    /// - `input_buffer` must be a valid pointer.
    /// - `message` must be a valid pointer.
    pub fn nw_framer_deliver_input(
        framer: NonNull<nw_framer_t>,
        input_buffer: NonNull<u8>,
        input_length: usize,
        message: nw_framer_message_t,
        is_complete: bool,
    );
}

extern "C-unwind" {
    /// Deliver bytes directly to the application without any
    /// transformation or copy. The bytes will start at the current
    /// input cursor used for parsing, and will implicitly advance
    /// the cursor by the length being delivered.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `input_length`: The number of input bytes to deliver. This will advance
    /// the parsing cursor by the specified number of bytes.
    ///
    /// The length may be 0, which can be used to indicate the
    /// end of the message if is_complete is set.
    ///
    ///
    /// Parameter `message`: The message to associate with the received data.
    ///
    ///
    /// Parameter `is_complete`: A boolean indicating whether or not this data represents
    /// the end of the message.
    ///
    ///
    /// Returns: Returns true if the input was delivered immediately, or
    /// false if it will be delivered once more bytes become available.
    ///
    /// # Safety
    ///
    /// - `framer` must be a valid pointer.
    /// - `message` must be a valid pointer.
    pub fn nw_framer_deliver_input_no_copy(
        framer: NonNull<nw_framer_t>,
        input_length: usize,
        message: nw_framer_message_t,
        is_complete: bool,
    ) -> bool;
}

extern "C-unwind" {
    /// Mark the input side of the framer as a pass-through, which
    /// means the framer will not be notified of any further input
    /// data.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    /// # Safety
    ///
    /// `framer` must be a valid pointer.
    pub fn nw_framer_pass_through_input(framer: NonNull<nw_framer_t>);
}

extern "C-unwind" {
    /// Parse currently available output from a message from the location
    /// of the output cursor in the message being parsed.
    ///
    /// The parse completion block will always be invoked inline exactly once.
    ///
    /// This function must only be called from within the output handler
    /// set with nw_framer_set_output_handler().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `minimum_incomplete_length`: The minimum number of bytes to parse. If this amount is
    /// not available, the parse completion block will be invoked
    /// with 0 bytes.
    ///
    ///
    /// Parameter `maximum_length`: The maximum number of bytes to parse as a contiguous buffer.
    /// If temp_buffer is not NULL, then this represents the length
    /// of valid bytes in temp_buffer.
    ///
    ///
    /// Parameter `temp_buffer`: A buffer provided by the caller to copy parse bytes into.
    /// If it is not NULL, it must have at least maximum_length bytes
    /// available, and any parsed bytes will be copied into the buffer.
    /// Any data stored in temp_buffer will be overwritten.
    /// If it is NULL, the buffer provided in the completion will not
    /// copy unless a copy is required to provide the minimum bytes
    /// as a contiguous buffer. The temp_buffer allows the caller to
    /// guarantee alignment properties of the buffer it parses.
    ///
    ///
    /// Parameter `parse`: The completion that provides the bytes to parse, which will
    /// be called exactly once.
    ///
    ///
    /// Returns: Returns true if the parse succeeded, or false if not enough
    /// bytes were available.
    ///
    /// # Safety
    ///
    /// - `framer` must be a valid pointer.
    /// - `temp_buffer` must be a valid pointer or null.
    /// - `parse` must be a valid pointer.
    pub fn nw_framer_parse_output(
        framer: NonNull<nw_framer_t>,
        minimum_incomplete_length: usize,
        maximum_length: usize,
        temp_buffer: *mut u8,
        parse: nw_framer_parse_completion_t,
    ) -> bool;
}

extern "C-unwind" {
    /// Write arbitrary bytes as part of an outbound message. This
    /// is intended to be used for adding headers around application
    /// data, or writing any other data that is generated or transformed
    /// by the protocol instance. It does not pass along data directly
    /// from the application.
    ///
    /// This variant will copy bytes.
    ///
    /// This function may be called as part of any framer callback,
    /// not just the output handler.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `output_buffer`: The bytes to write.
    ///
    ///
    /// Parameter `output_length`: The length of output_buffer.
    ///
    /// # Safety
    ///
    /// - `framer` must be a valid pointer.
    /// - `output_buffer` must be a valid pointer.
    pub fn nw_framer_write_output(
        framer: NonNull<nw_framer_t>,
        output_buffer: NonNull<u8>,
        output_length: usize,
    );
}

extern "C-unwind" {
    /// Write arbitrary bytes as part of an outbound message. This
    /// is intended to be used for adding headers around application
    /// data, or writing any other data that is generated or transformed
    /// by the protocol instance. It does not pass along data directly
    /// from the application.
    ///
    /// This variant is the same as nw_framer_write_output(), but allows
    /// the implementation to pass its buffer as a dispatch_data_t to
    /// avoid a copy.
    ///
    /// This function may be called as part of any framer callback,
    /// not just the output handler.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `output_data`: A dispatch_data_t to write.
    ///
    /// # Safety
    ///
    /// `framer` must be a valid pointer.
    pub fn nw_framer_write_output_data(framer: NonNull<nw_framer_t>, output_data: &DispatchData);
}

extern "C-unwind" {
    /// Write bytes directly from the application without any
    /// transformation or copy. The bytes will start at the current
    /// output cursor used for parsing, and will implicitly advance
    /// the cursor by the length being written.
    ///
    /// This function must only be called from within the output handler
    /// set with nw_framer_set_output_handler().
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `output_length`: The number of application bytes to write. This will advance
    /// the parsing cursor by the specified number of bytes.
    ///
    ///
    /// Returns: Returns true if the write could be completed, otherwise
    /// false if the call was made from an invalid context
    /// or with an invalid number of bytes.
    ///
    /// # Safety
    ///
    /// `framer` must be a valid pointer.
    pub fn nw_framer_write_output_no_copy(
        framer: NonNull<nw_framer_t>,
        output_length: usize,
    ) -> bool;
}

extern "C-unwind" {
    /// Mark the output side of the framer as a pass-through, which
    /// means the framer will not be notified of any further output
    /// data.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    /// # Safety
    ///
    /// `framer` must be a valid pointer.
    pub fn nw_framer_pass_through_output(framer: NonNull<nw_framer_t>);
}

extern "C-unwind" {
    /// Schedule a wakeup on the framer instance for a number of
    /// milliseconds into the future. If this is called multiple
    /// times before the timeout is reached, the new value replaces
    /// the previous value.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `milliseconds`: The number of milliseconds into the future at which to
    /// invoke the wakeup handler. Pass the reserved value
    /// NW_FRAMER_WAKEUP_TIME_FOREVER to push the wakeup timer
    /// out to "forever", effectively unscheduling the timer.
    ///
    /// # Safety
    ///
    /// `framer` must be a valid pointer.
    pub fn nw_framer_schedule_wakeup(framer: NonNull<nw_framer_t>, milliseconds: u64);
}

/// A block to perform actions on a framer's scheduling context.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_block_t?language=objc)
pub type nw_framer_block_t = *mut block2::DynBlock<dyn Fn()>;

extern "C-unwind" {
    /// Schedule a block asynchronously on the framer instance. This
    /// must be used anytime the caller wants to perform any other
    /// action on the framer instance while not directly in the call stack
    /// of a callback from the framer.
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `async_block`: A block to execute on the correct scheduling context for the
    /// framer instance.
    ///
    /// # Safety
    ///
    /// - `framer` must be a valid pointer.
    /// - `async_block` must be a valid pointer.
    pub fn nw_framer_async(framer: NonNull<nw_framer_t>, async_block: nw_framer_block_t);
}

/// Access the remote endpoint being used for a given
/// instance of a framer.
///
/// To ensure thread safety, this function can only be called
/// in one of the callback blocks invoked on the framer, or
/// in a block passed to nw_framer_async().
///
///
/// Parameter `framer`: The framer instance.
///
///
/// Returns: Returns a retained endpoint object representing
/// the remote side of a connection.
///
/// # Safety
///
/// `framer` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_framer_copy_remote_endpoint(
    framer: NonNull<nw_framer_t>,
) -> NWRetained<nw_endpoint_t> {
    extern "C-unwind" {
        fn nw_framer_copy_remote_endpoint(
            framer: NonNull<nw_framer_t>,
        ) -> Option<NonNull<nw_endpoint_t>>;
    }
    let ret = unsafe { nw_framer_copy_remote_endpoint(framer) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Access the local endpoint being used for a given
/// instance of a framer.
///
/// To ensure thread safety, this function can only be called
/// in one of the callback blocks invoked on the framer, or
/// in a block passed to nw_framer_async().
///
///
/// Parameter `framer`: The framer instance.
///
///
/// Returns: Returns a retained endpoint object representing
/// the local side of a connection.
///
/// # Safety
///
/// `framer` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_framer_copy_local_endpoint(
    framer: NonNull<nw_framer_t>,
) -> NWRetained<nw_endpoint_t> {
    extern "C-unwind" {
        fn nw_framer_copy_local_endpoint(
            framer: NonNull<nw_framer_t>,
        ) -> Option<NonNull<nw_endpoint_t>>;
    }
    let ret = unsafe { nw_framer_copy_local_endpoint(framer) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Access the parameters being used for a given
/// instance of a framer.
///
/// To ensure thread safety, this function can only be called
/// in one of the callback blocks invoked on the framer, or
/// in a block passed to nw_framer_async().
///
///
/// Parameter `framer`: The framer instance.
///
///
/// Returns: Returns a retained parameters object.
///
/// # Safety
///
/// `framer` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_framer_copy_parameters(
    framer: NonNull<nw_framer_t>,
) -> NWRetained<nw_parameters_t> {
    extern "C-unwind" {
        fn nw_framer_copy_parameters(
            framer: NonNull<nw_framer_t>,
        ) -> Option<NonNull<nw_parameters_t>>;
    }
    let ret = unsafe { nw_framer_copy_parameters(framer) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Access the protocol options being used for a given
/// instance of a framer.
///
///
/// Parameter `framer`: The framer instance.
///
///
/// Returns: Returns a retained protocol options object.
///
/// # Safety
///
/// `framer` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_framer_copy_options(
    framer: NonNull<nw_framer_t>,
) -> NWRetained<nw_protocol_options_t> {
    extern "C-unwind" {
        fn nw_framer_copy_options(
            framer: NonNull<nw_framer_t>,
        ) -> Option<NonNull<nw_protocol_options_t>>;
    }
    let ret = unsafe { nw_framer_copy_options(framer) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Access the definition of the default system protocol implementation
/// of IP (Internet Protocol). This protocol can be used
/// as part of a connection's protocol stack as the internet protocol.
///
///
/// Returns: Returns a retained protocol definition object.
#[inline]
pub extern "C-unwind" fn nw_protocol_copy_ip_definition() -> NWRetained<nw_protocol_definition_t> {
    extern "C-unwind" {
        fn nw_protocol_copy_ip_definition() -> Option<NonNull<nw_protocol_definition_t>>;
    }
    let ret = unsafe { nw_protocol_copy_ip_definition() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// A specific version of the Internet Protocol.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ip_version_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_ip_version_t(pub c_uint);
impl nw_ip_version_t {
    #[doc(alias = "nw_ip_version_any")]
    pub const any: Self = Self(0);
    #[doc(alias = "nw_ip_version_4")]
    pub const v4: Self = Self(4);
    #[doc(alias = "nw_ip_version_6")]
    pub const v6: Self = Self(6);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ip_version_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ip_version_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Specify a single version of the Internet Protocol to allow.
    /// Setting this value will constrain which address endpoints can
    /// be used, and will filter DNS results during connection establishment.
    ///
    ///
    /// Parameter `options`: An IP protocol options object.
    ///
    ///
    /// Parameter `version`: A specific, restricted IP version.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_ip_options_set_version(
        options: NonNull<nw_protocol_options_t>,
        version: nw_ip_version_t,
    );
}

extern "C-unwind" {
    /// Configure the IP hop limit (or 'TTL' for IPv4).
    ///
    ///
    /// Parameter `options`: An IP protocol options object.
    ///
    ///
    /// Parameter `hop_limit`: The hop limit to set on outgoing IP packets.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_ip_options_set_hop_limit(options: NonNull<nw_protocol_options_t>, hop_limit: u8);
}

extern "C-unwind" {
    /// Configure IP to use the minimum MTU value, which
    /// is 1280 bytes for IPv6. This value has no effect for
    /// IPv4.
    ///
    ///
    /// Parameter `options`: An IP protocol options object.
    ///
    ///
    /// Parameter `use_minimum_mtu`: A boolean indicating that the IP should use
    /// its minimum MTU value.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_ip_options_set_use_minimum_mtu(
        options: NonNull<nw_protocol_options_t>,
        use_minimum_mtu: bool,
    );
}

extern "C-unwind" {
    /// Configure IP to disable fragmentation on outgoing
    /// packets.
    ///
    ///
    /// Parameter `options`: An IP protocol options object.
    ///
    ///
    /// Parameter `disable_fragmentation`: A boolean indicating that the IP should use
    /// disable fragmentation on outgoing packets.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_ip_options_set_disable_fragmentation(
        options: NonNull<nw_protocol_options_t>,
        disable_fragmentation: bool,
    );
}

extern "C-unwind" {
    /// Configure IP to calculate receive time for inbound
    /// packets.
    ///
    ///
    /// Parameter `options`: An IP protocol options object.
    ///
    ///
    /// Parameter `calculate_receive_time`: A boolean indicating that the IP packets
    /// should mark their receive time in IP metadata.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_ip_options_set_calculate_receive_time(
        options: NonNull<nw_protocol_options_t>,
        calculate_receive_time: bool,
    );
}

/// Preference for local addresses selection.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ip_local_address_preference_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_ip_local_address_preference_t(pub c_uint);
impl nw_ip_local_address_preference_t {
    #[doc(alias = "nw_ip_local_address_preference_default")]
    pub const default: Self = Self(0);
    #[doc(alias = "nw_ip_local_address_preference_temporary")]
    pub const temporary: Self = Self(1);
    #[doc(alias = "nw_ip_local_address_preference_stable")]
    pub const stable: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ip_local_address_preference_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ip_local_address_preference_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Specify a preference for how to select local addresses for outbound
    /// connections.
    ///
    ///
    /// Parameter `options`: An IP protocol options object.
    ///
    ///
    /// Parameter `preference`: Preference for how to select local addresses.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_ip_options_set_local_address_preference(
        options: NonNull<nw_protocol_options_t>,
        preference: nw_ip_local_address_preference_t,
    );
}

extern "C-unwind" {
    /// If a multicast packet is sent to a group to which the sending host itself
    /// belongs (on the outgoing interface), a copy of the datagram is, by default,
    /// looped back by the IP layer for local delivery.
    /// Setting the disable_multicast_loopback option disables this behavior and,
    /// if set, multicast packets will not be looped back to the sender.
    /// Only applies to multicast packets.
    ///
    ///
    /// Parameter `options`: An IP protocol options object.
    ///
    ///
    /// Parameter `disable_multicast_loopback`: If multicast loopback should be disabled.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_ip_options_set_disable_multicast_loopback(
        options: NonNull<nw_protocol_options_t>,
        disable_multicast_loopback: bool,
    );
}

/// Create an instance of IP metadata that can be used
/// to configure per-packet options when sending data
/// on a connection.
///
///
/// Returns: Returns a retained protocol metadata object.
#[inline]
pub extern "C-unwind" fn nw_ip_create_metadata() -> NWRetained<nw_protocol_metadata_t> {
    extern "C-unwind" {
        fn nw_ip_create_metadata() -> Option<NonNull<nw_protocol_metadata_t>>;
    }
    let ret = unsafe { nw_ip_create_metadata() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Checks if a protocol metadata object is compatible with the
    /// accessors defined in this file for the default system
    /// implementation of IP.
    ///
    ///
    /// Returns: Returns true if the metadata is for the default system IP,
    /// false otherwise.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_protocol_metadata_is_ip(metadata: NonNull<nw_protocol_metadata_t>) -> bool;
}

/// ECN flags marked in IP headers to indicate congestion.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ip_ecn_flag_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_ip_ecn_flag_t(pub c_uint);
impl nw_ip_ecn_flag_t {
    #[doc(alias = "nw_ip_ecn_flag_non_ect")]
    pub const non_ect: Self = Self(0);
    #[doc(alias = "nw_ip_ecn_flag_ect_0")]
    pub const ect_0: Self = Self(2);
    #[doc(alias = "nw_ip_ecn_flag_ect_1")]
    pub const ect_1: Self = Self(1);
    #[doc(alias = "nw_ip_ecn_flag_ce")]
    pub const ce: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ip_ecn_flag_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ip_ecn_flag_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Sets ECN flags on IP metadata. This will take effect if
    /// applied to any sent content.
    ///
    ///
    /// Parameter `metadata`: An IP metadata object.
    ///
    ///
    /// Parameter `ecn_flag`: The ECN flag to apply to packets.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_ip_metadata_set_ecn_flag(
        metadata: NonNull<nw_protocol_metadata_t>,
        ecn_flag: nw_ip_ecn_flag_t,
    );
}

extern "C-unwind" {
    /// Gets ECN flags from IP metadata. This will be set only
    /// for metadata associated with received content.
    ///
    ///
    /// Parameter `metadata`: An IP metadata object.
    ///
    ///
    /// Returns: Returns the ECN flag received from a packet.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_ip_metadata_get_ecn_flag(
        metadata: NonNull<nw_protocol_metadata_t>,
    ) -> nw_ip_ecn_flag_t;
}

extern "C-unwind" {
    /// Sets service class on IP metadata. This will not generally
    /// translate into TOS or Traffic Class bits unless the network
    /// explicitly supports it, but it will impact local queuing of
    /// packets.
    ///
    ///
    /// Parameter `metadata`: An IP metadata object.
    ///
    ///
    /// Parameter `service_class`: The service class to apply to packets.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_ip_metadata_set_service_class(
        metadata: NonNull<nw_protocol_metadata_t>,
        service_class: nw_service_class_t,
    );
}

extern "C-unwind" {
    /// Gets service class from IP metadata. This reflects the value
    /// set using nw_ip_metadata_set_service_class. It will not
    /// be received from the network.
    ///
    ///
    /// Parameter `metadata`: An IP metadata object.
    ///
    ///
    /// Returns: Returns the service class set on a packet.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_ip_metadata_get_service_class(
        metadata: NonNull<nw_protocol_metadata_t>,
    ) -> nw_service_class_t;
}

extern "C-unwind" {
    /// Access the time at which a packet was received. This is
    /// useful for calculating precise timing for round-trip-time
    /// estimates. Same as clock_gettime_nsec_np(CLOCK_MONOTONIC_RAW).
    ///
    /// The receive time will be 0 unless timestamps have been enabled
    /// using nw_ip_options_set_calculate_receive_time().
    ///
    ///
    /// Parameter `metadata`: An IP metadata object.
    ///
    ///
    /// Returns: Returns the time that the packet was received.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_ip_metadata_get_receive_time(metadata: NonNull<nw_protocol_metadata_t>) -> u64;
}

/// Listener states sent by nw_listener_set_state_changed_handler.
/// States progress forward and do not move backwards.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_listener_state_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_listener_state_t(pub c_uint);
impl nw_listener_state_t {
    /// will never be delivered in the listener's state update handler, and can be treated as
    /// an unexpected value.
    #[doc(alias = "nw_listener_state_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_listener_state_waiting")]
    pub const waiting: Self = Self(1);
    #[doc(alias = "nw_listener_state_ready")]
    pub const ready: Self = Self(2);
    #[doc(alias = "nw_listener_state_failed")]
    pub const failed: Self = Self(3);
    #[doc(alias = "nw_listener_state_cancelled")]
    pub const cancelled: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_listener_state_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_listener_state_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Creates a networking listener bound to a specified local port.
///
///
/// Parameter `port`: A port number as a C string, such as "443", or a service
/// name, such as "https".
///
///
/// Parameter `parameters`: The parameters to use for the listener. These include the protocols to be
/// used for the listener.
///
///
/// Returns: Returns an allocated nw_listener_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
/// Returns NULL on failure. Fails due to invalid parameters.
///
/// # Safety
///
/// - `port` must be a valid pointer.
/// - `parameters` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_listener_create_with_port(
    port: NonNull<c_char>,
    parameters: NonNull<nw_parameters_t>,
) -> Option<NWRetained<nw_listener_t>> {
    extern "C-unwind" {
        fn nw_listener_create_with_port(
            port: NonNull<c_char>,
            parameters: NonNull<nw_parameters_t>,
        ) -> Option<NonNull<nw_listener_t>>;
    }
    let ret = unsafe { nw_listener_create_with_port(port, parameters) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

/// Creates a network listener from a launchd key.
///
///
/// Parameter `parameters`: The parameters to use for the listener. These include the protocols to be
/// used for the listener. Since launchd creates the listening sockets, these
/// parameters may not be applied in all cases.
///
///
/// Parameter `launchd_key`: The name of the socket entry as specified in the launchd.plist.
///
///
/// Returns: Returns an allocated nw_listener_t object.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
///
/// # Safety
///
/// - `parameters` must be a valid pointer.
/// - `launchd_key` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_listener_create_with_launchd_key(
    parameters: NonNull<nw_parameters_t>,
    launchd_key: NonNull<c_char>,
) -> NWRetained<nw_listener_t> {
    extern "C-unwind" {
        fn nw_listener_create_with_launchd_key(
            parameters: NonNull<nw_parameters_t>,
            launchd_key: NonNull<c_char>,
        ) -> Option<NonNull<nw_listener_t>>;
    }
    let ret = unsafe { nw_listener_create_with_launchd_key(parameters, launchd_key) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Creates a networking listener. The listener will be assigned a random
/// port upon which to listen unless otherwise specified by the parameters.
///
///
/// Parameter `parameters`: The parameters to use for the listener. These include the protocols to be
/// used for the listener.
///
///
/// Returns: Returns an allocated nw_listener_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
/// Returns NULL on failure. Fails due to invalid parameters.
///
/// # Safety
///
/// `parameters` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_listener_create(
    parameters: NonNull<nw_parameters_t>,
) -> Option<NWRetained<nw_listener_t>> {
    extern "C-unwind" {
        fn nw_listener_create(
            parameters: NonNull<nw_parameters_t>,
        ) -> Option<NonNull<nw_listener_t>>;
    }
    let ret = unsafe { nw_listener_create(parameters) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

/// Creates a networking listener based on an existing
/// multiplexing connection. If there are multiple protocols
/// in the connection that support listening for incoming flows,
/// the listener will be hooked up the highest in the stack
/// (the closest to the reading and writing of the client data).
///
///
/// Parameter `connection`: An existing connection that has a multiplexing protocol
/// that supports receiving new connections.
///
///
/// Parameter `parameters`: The parameters to use for the listener. The protocol stack
/// defined in the parameters must be able to join a protocol
/// in the connection that supports listening protocols.
///
///
/// Returns: Returns an allocated nw_listener_t object on success. Use nw_release() to deallocate.
/// Returns NULL on failure. Fails due to invalid parameters.
///
/// # Safety
///
/// - `connection` must be a valid pointer.
/// - `parameters` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_listener_create_with_connection(
    connection: NonNull<nw_connection_t>,
    parameters: NonNull<nw_parameters_t>,
) -> Option<NWRetained<nw_listener_t>> {
    extern "C-unwind" {
        fn nw_listener_create_with_connection(
            connection: NonNull<nw_connection_t>,
            parameters: NonNull<nw_parameters_t>,
        ) -> Option<NonNull<nw_listener_t>>;
    }
    let ret = unsafe { nw_listener_create_with_connection(connection, parameters) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Sets the client callback queue, on which blocks for events will
    /// be scheduled. This must be done before calling nw_listener_start().
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Parameter `queue`: The client's dispatch queue.
    ///
    /// # Safety
    ///
    /// `listener` must be a valid pointer.
    pub fn nw_listener_set_queue(listener: NonNull<nw_listener_t>, queue: &DispatchQueue);
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_listener_state_changed_handler_t?language=objc)
pub type nw_listener_state_changed_handler_t =
    *mut block2::DynBlock<dyn Fn(nw_listener_state_t, *mut nw_error_t)>;

extern "C-unwind" {
    /// Sets the state change handler. For clients that need to perform cleanup when the
    /// connection has been cancelled, the nw_listener_state_cancelled state will
    /// be delivered last.
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Parameter `handler`: The state changed handler to call when the listener state changes.
    /// Pass NULL to remove the event handler.
    ///
    /// # Safety
    ///
    /// - `listener` must be a valid pointer.
    /// - `handler` must be a valid pointer or null.
    pub fn nw_listener_set_state_changed_handler(
        listener: NonNull<nw_listener_t>,
        handler: nw_listener_state_changed_handler_t,
    );
}

/// The block called to notify client of a new connection.
///
///
/// Parameter `connection`: The new connection object. This connection is not yet started. Set the
/// event handler and other settings on the connection before calling start.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_listener_new_connection_handler_t?language=objc)
pub type nw_listener_new_connection_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<nw_connection_t>)>;

extern "C-unwind" {
    /// Sets the client new connection handler. Must be called before
    /// nw_listener_start.
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Parameter `handler`: The event handler to call when the listener receives a new connection.
    /// Pass NULL to remove the new connection handler.
    ///
    /// # Safety
    ///
    /// - `listener` must be a valid pointer.
    /// - `handler` must be a valid pointer or null.
    pub fn nw_listener_set_new_connection_handler(
        listener: NonNull<nw_listener_t>,
        handler: nw_listener_new_connection_handler_t,
    );
}

/// The block called to notify the client of a new connection group.
///
///
/// Parameter `connection_group`: The new connection group object. This connection group is not yet started. Set the
/// event handler and other settings on the connection group before calling start.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_listener_new_connection_group_handler_t?language=objc)
pub type nw_listener_new_connection_group_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<nw_connection_group_t>)>;

extern "C-unwind" {
    /// Sets a new connection group handler to be called upon receiving an incoming
    /// connection that has a multiplexing protocol in its connected protocol stack.
    /// Must be called before nw_listener_start. Note that this handler is mutually
    /// exclusive with the new connection handler that is set via
    /// nw_listener_set_new_connection_handler. Only one of these handlers may
    /// be set at one time.
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Parameter `handler`: The event handler to call when the listener receives a new connection group.
    /// Pass NULL to remove the new connection group handler.
    ///
    /// # Safety
    ///
    /// - `listener` must be a valid pointer.
    /// - `handler` must be a valid pointer or null.
    pub fn nw_listener_set_new_connection_group_handler(
        listener: NonNull<nw_listener_t>,
        handler: nw_listener_new_connection_group_handler_t,
    );
}

extern "C-unwind" {
    /// Gets the listener new connection limit. The default value is
    /// NW_LISTENER_INFINITE_CONNECTION_LIMIT which indicates that
    /// the listener should not limit incoming connections. If the value
    /// is not NW_LISTENER_INFINITE_CONNECTION_LIMIT, it will be decremented
    /// by 1 every time a new connection is created. When the value becomes
    /// 0, new connection handlers will no longer be invoked until
    /// nw_listener_set_new_connection_limit() is invoked with a value
    /// that is greater than 0. Incoming connections will eventually be rejected
    /// if nw_listener_set_new_connection_limit() is not called after the connection
    /// limit reaches 0.
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Returns: Returns current new connection limit
    ///
    /// # Safety
    ///
    /// `listener` must be a valid pointer.
    pub fn nw_listener_get_new_connection_limit(listener: NonNull<nw_listener_t>) -> u32;
}

extern "C-unwind" {
    /// Sets the listener new connection limit. Use the value NW_LISTENER_INFINITE_CONNECTION_LIMIT
    /// to disable connection limits. If the value is not NW_LISTENER_INFINITE_CONNECTION_LIMIT,
    /// it will be decremented by 1 every time a new connection is created. When the value becomes
    /// 0, new connection handlers will no longer be invoked until
    /// nw_listener_set_new_connection_limit() is invoked with a value
    /// that is greater than 0. Incoming connections will eventually be rejected
    /// if nw_listener_set_new_connection_limit() is not called after the connection
    /// limit reaches 0.
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Parameter `new_connection_limit`: The new connection limit. Pass NW_LISTENER_INFINITE_CONNECTION_LIMIT
    /// to disable new connection limiting.
    ///
    /// # Safety
    ///
    /// `listener` must be a valid pointer.
    pub fn nw_listener_set_new_connection_limit(
        listener: NonNull<nw_listener_t>,
        new_connection_limit: u32,
    );
}

extern "C-unwind" {
    /// Describes the bonjour service the listener should register. Setting the
    /// advertise descriptor more than once may be used to update the TXT record.
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Parameter `advertise_descriptor`: The advertise_descriptor or NULL to prevent or remove registration of a service.
    ///
    /// # Safety
    ///
    /// - `listener` must be a valid pointer.
    /// - `advertise_descriptor` must be a valid pointer or null.
    pub fn nw_listener_set_advertise_descriptor(
        listener: NonNull<nw_listener_t>,
        advertise_descriptor: *mut nw_advertise_descriptor_t,
    );
}

/// A block called to notify client of a change in advertised endpoints.
///
///
/// Parameter `advertised_endpoint`: An endpoint that is has been added or removed from the list of advertised
/// endpoints for the listener.
///
///
/// Parameter `added`: A boolean indicating if the endpoint is being added or removed. If added,
/// the value with be true; if removed, the value will be false.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_listener_advertised_endpoint_changed_handler_t?language=objc)
pub type nw_listener_advertised_endpoint_changed_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<nw_endpoint_t>, bool)>;

extern "C-unwind" {
    /// Sets the client advertised endpoint changed handler. The handler will be
    /// invoked for listeners which have called nw_listener_set_advertise_descriptor().
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Parameter `handler`: The event handler to call when the listener adds or removes an advertised endpoint.
    /// Pass NULL to remove the handler.
    ///
    /// # Safety
    ///
    /// - `listener` must be a valid pointer.
    /// - `handler` must be a valid pointer or null.
    pub fn nw_listener_set_advertised_endpoint_changed_handler(
        listener: NonNull<nw_listener_t>,
        handler: nw_listener_advertised_endpoint_changed_handler_t,
    );
}

extern "C-unwind" {
    /// Gets the local port as a number in host byte order. If the listener was created with a
    /// port of 0 (let the system assign a port), nw_listener_get_port will return 0 until the
    /// listener is in the ready state.
    ///
    ///
    /// Parameter `listener`: The listener to get the local port of.
    ///
    ///
    /// Returns: Returns a port in host byte order.
    ///
    /// # Safety
    ///
    /// `listener` must be a valid pointer.
    pub fn nw_listener_get_port(listener: NonNull<nw_listener_t>) -> u16;
}

extern "C-unwind" {
    /// Starts the listener, which will cause the listener
    /// to start listening for inbound connections.
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    /// # Safety
    ///
    /// `listener` must be a valid pointer.
    pub fn nw_listener_start(listener: NonNull<nw_listener_t>);
}

extern "C-unwind" {
    /// Cancel the listener. This will de-register the listener from the system. The process
    /// of cancellation will be completed asynchronously, and the final callback event
    /// delivered to the caller will be a state update with a value of nw_listener_state_cancelled.
    /// Once this update is delivered, the caller may clean up any associated memory or objects.
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    /// # Safety
    ///
    /// `listener` must be a valid pointer.
    pub fn nw_listener_cancel(listener: NonNull<nw_listener_t>);
}

/// Create a default path monitor, that will allow the enumeration of all available
/// interfaces on the system.
///
///
/// Returns: Returns an allocated nw_path_monitor_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
/// Returns NULL on failure. Fails due to invalid parameters.
#[inline]
pub extern "C-unwind" fn nw_path_monitor_create() -> NWRetained<nw_path_monitor_t> {
    extern "C-unwind" {
        fn nw_path_monitor_create() -> Option<NonNull<nw_path_monitor_t>>;
    }
    let ret = unsafe { nw_path_monitor_create() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Create a path monitor specific to an interface type, that will allow the enumeration
/// of any interface that matches the type on the system.
///
///
/// Parameter `required_interface_type`: An interface type that will filter any results that the path monitor returns.
///
///
/// Returns: Returns an allocated nw_path_monitor_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
/// Returns NULL on failure. Fails due to invalid parameters.
#[inline]
pub extern "C-unwind" fn nw_path_monitor_create_with_type(
    required_interface_type: nw_interface_type_t,
) -> NWRetained<nw_path_monitor_t> {
    extern "C-unwind" {
        fn nw_path_monitor_create_with_type(
            required_interface_type: nw_interface_type_t,
        ) -> Option<NonNull<nw_path_monitor_t>>;
    }
    let ret = unsafe { nw_path_monitor_create_with_type(required_interface_type) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Create a path monitor that enumerates all interfaces that support
/// Ethernet channel.
///
///
/// Returns: Returns an allocated nw_path_monitor_t object on success.
/// Callers are responsible for deallocating using nw_release(obj) or [obj release].
/// These objects support ARC.
/// Returns NULL on failure.
#[inline]
pub extern "C-unwind" fn nw_path_monitor_create_for_ethernet_channel(
) -> NWRetained<nw_path_monitor_t> {
    extern "C-unwind" {
        fn nw_path_monitor_create_for_ethernet_channel() -> Option<NonNull<nw_path_monitor_t>>;
    }
    let ret = unsafe { nw_path_monitor_create_for_ethernet_channel() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Prohibit this path monitor from using the provided network interface type.
    /// Call before calling nw_path_monitor_start.
    ///
    ///
    /// Parameter `monitor`: The path monitor object.
    ///
    ///
    /// Parameter `interface_type`: The interface type to prohibit for the path monitor.
    ///
    /// # Safety
    ///
    /// `monitor` must be a valid pointer.
    pub fn nw_path_monitor_prohibit_interface_type(
        monitor: NonNull<nw_path_monitor_t>,
        interface_type: nw_interface_type_t,
    );
}

/// A block handler to be called when a path monitor is cancelled. This
/// is used to allow clients to release any objects they have retained in
/// association with the path monitor.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_path_monitor_cancel_handler_t?language=objc)
pub type nw_path_monitor_cancel_handler_t = *mut block2::DynBlock<dyn Fn()>;

extern "C-unwind" {
    /// Set a handler to be called on the queue provided to nw_path_monitor_set_queue
    /// once cancellation has completed. Once the cancel handler has been called, the
    /// update handler will not fire again.
    ///
    ///
    /// Parameter `monitor`: The path monitor object.
    ///
    ///
    /// Parameter `cancel_handler`: The block to call upon cancellation. Pass NULL to remove the cancel handler.
    ///
    /// # Safety
    ///
    /// - `monitor` must be a valid pointer.
    /// - `cancel_handler` must be a valid pointer.
    pub fn nw_path_monitor_set_cancel_handler(
        monitor: NonNull<nw_path_monitor_t>,
        cancel_handler: nw_path_monitor_cancel_handler_t,
    );
}

/// A block handler to be called whenever a path monitor has a new snapshot.
/// This will be called one or more times after calling nw_path_monitor_start.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_path_monitor_update_handler_t?language=objc)
pub type nw_path_monitor_update_handler_t = *mut block2::DynBlock<dyn Fn(NonNull<nw_path_t>)>;

extern "C-unwind" {
    /// Sets the client update handler. This block will be called with the
    /// current path when start is called and any time the path changes.
    ///
    ///
    /// Parameter `monitor`: The path monitor object.
    ///
    ///
    /// Parameter `update_handler`: The block to call when the path changes.
    ///
    /// # Safety
    ///
    /// - `monitor` must be a valid pointer.
    /// - `update_handler` must be a valid pointer.
    pub fn nw_path_monitor_set_update_handler(
        monitor: NonNull<nw_path_monitor_t>,
        update_handler: nw_path_monitor_update_handler_t,
    );
}

extern "C-unwind" {
    /// Sets the client update queue. All blocks will be scheduled on
    /// this queue. Call before calling nw_path_monitor_start.
    ///
    ///
    /// Parameter `monitor`: The path monitor object.
    ///
    ///
    /// Parameter `queue`: The dispatch queue on which to call the update and cancel handlers.
    ///
    /// # Safety
    ///
    /// `monitor` must be a valid pointer.
    pub fn nw_path_monitor_set_queue(monitor: NonNull<nw_path_monitor_t>, queue: &DispatchQueue);
}

extern "C-unwind" {
    /// Starts the path monitor.
    ///
    ///
    /// Parameter `monitor`: The path monitor object.
    ///
    /// # Safety
    ///
    /// `monitor` must be a valid pointer.
    pub fn nw_path_monitor_start(monitor: NonNull<nw_path_monitor_t>);
}

extern "C-unwind" {
    /// Cancel the path monitor.
    ///
    ///
    /// Parameter `monitor`: The path monitor object.
    ///
    /// # Safety
    ///
    /// `monitor` must be a valid pointer.
    pub fn nw_path_monitor_cancel(monitor: NonNull<nw_path_monitor_t>);
}

/// Access the definition of the default system protocol implementation
/// of QUIC. This protocol can be used as part of a
/// connection's protocol stack as a transport protocol.
///
///
/// Returns: Returns a retained protocol definition object.
#[inline]
pub extern "C-unwind" fn nw_protocol_copy_quic_definition() -> NWRetained<nw_protocol_definition_t>
{
    extern "C-unwind" {
        fn nw_protocol_copy_quic_definition() -> Option<NonNull<nw_protocol_definition_t>>;
    }
    let ret = unsafe { nw_protocol_copy_quic_definition() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Create an instance of QUIC protocol options. This object can be added
/// to an nw_protocol_stack_t to be used in an nw_connection_t or
/// an nw_listener_t.
///
///
/// Returns: Returns a retained protocol options object.
#[inline]
pub extern "C-unwind" fn nw_quic_create_options() -> NWRetained<nw_protocol_options_t> {
    extern "C-unwind" {
        fn nw_quic_create_options() -> Option<NonNull<nw_protocol_options_t>>;
    }
    let ret = unsafe { nw_quic_create_options() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Checks whether the given protocol options define a QUIC protocol.
    ///
    ///
    /// Returns: Returns true if the protocol options are for QUIC, false otherwise.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_protocol_options_is_quic(options: NonNull<nw_protocol_options_t>) -> bool;
}

extern "C-unwind" {
    /// Adds an Application-Layer Protocol Negotiation (ALPN) value to present in the TLS handshake.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    /// # Safety
    ///
    /// - `options` must be a valid pointer.
    /// - `application_protocol` must be a valid pointer.
    pub fn nw_quic_add_tls_application_protocol(
        options: NonNull<nw_protocol_options_t>,
        application_protocol: NonNull<c_char>,
    );
}

extern "C-unwind" {
    /// Returns whether or not a QUIC stream is unidirectional.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for a QUIC stream.
    ///
    ///
    /// Returns: True if the stream is unidirectional, false otherwise.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_get_stream_is_unidirectional(options: NonNull<nw_protocol_options_t>) -> bool;
}

extern "C-unwind" {
    /// Set whether or not a QUIC stream should be unidirectional.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for a QUIC stream.
    ///
    ///
    /// Parameter `is_unidirectional`: True if the stream is unidirectional, false otherwise.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_set_stream_is_unidirectional(
        options: NonNull<nw_protocol_options_t>,
        is_unidirectional: bool,
    );
}

extern "C-unwind" {
    /// Get whether or not the QUIC stream is a QUIC datagram flow.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Returns: is_datagram
    /// True if the QUIC stream is a QUIC datagram flow.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_get_stream_is_datagram(options: NonNull<nw_protocol_options_t>) -> bool;
}

extern "C-unwind" {
    /// Set whether or not the QUIC stream should be a QUIC datagram flow.
    /// Only one QUIC datagram flow can be created per connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Parameter `is_datagram`: A boolean to indicate whether or not the QUIC stream should be a QUIC datagram flow.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_set_stream_is_datagram(
        options: NonNull<nw_protocol_options_t>,
        is_datagram: bool,
    );
}

extern "C-unwind" {
    /// Get the initial_max_data transport parameter on a QUIC
    /// connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Returns: The initial_max_data that a client
    /// is willing to receive on a connection.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_get_initial_max_data(options: NonNull<nw_protocol_options_t>) -> u64;
}

extern "C-unwind" {
    /// Set the initial_max_data transport parameter on a QUIC
    /// connection. Setting this option requires
    /// initial_max_stream_data_bidirectional_local,
    /// initial_max_stream_data_bidirectional_remote and
    /// initial_max_stream_data_unidirectional also to be set.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Parameter `initial_max_data`: The initial_max_data controls how much data, in bytes, a client
    /// is willing to receive on a connection.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_set_initial_max_data(
        options: NonNull<nw_protocol_options_t>,
        initial_max_data: u64,
    );
}

extern "C-unwind" {
    /// Get the maximum length of a QUIC packet (UDP payload)
    /// that the client is willing to receive on a connection, in bytes.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Returns: The max_udp_payload_size value, in bytes.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_get_max_udp_payload_size(options: NonNull<nw_protocol_options_t>) -> u16;
}

extern "C-unwind" {
    /// Define the maximum length of a QUIC packet (UDP payload)
    /// that the client is willing to receive on a connection, in bytes.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Parameter `max_udp_payload_size`: The max_udp_payload_size value, in bytes.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_set_max_udp_payload_size(
        options: NonNull<nw_protocol_options_t>,
        max_udp_payload_size: u16,
    );
}

extern "C-unwind" {
    /// Get the idle timeout value for the QUIC connection. If no packets are sent or received
    /// within this timeout, the QUIC connection will be closed.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Returns: The idle_timeout value, in milliseconds.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_get_idle_timeout(options: NonNull<nw_protocol_options_t>) -> u32;
}

extern "C-unwind" {
    /// Define an idle timeout value for the QUIC connection. If no packets are sent or received
    /// within this timeout, the QUIC connection will be closed.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Parameter `idle_timeout`: The idle_timeout value, in milliseconds.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_set_idle_timeout(options: NonNull<nw_protocol_options_t>, idle_timeout: u32);
}

extern "C-unwind" {
    /// Get the initial value of maximum bidirectional streams
    /// that the peer can initiate on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Returns: The initial value for the maximum concurrent bidirectional streams.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_get_initial_max_streams_bidirectional(
        options: NonNull<nw_protocol_options_t>,
    ) -> u64;
}

extern "C-unwind" {
    /// Set the initial value of maximum bidirectional streams
    /// that the peer can initiate on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Parameter `initial_max_streams_bidirectional`: The initial value for the maximum concurrent bidirectional streams.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_set_initial_max_streams_bidirectional(
        options: NonNull<nw_protocol_options_t>,
        initial_max_streams_bidirectional: u64,
    );
}

extern "C-unwind" {
    /// Get the initial value of maximum unidirectional streams
    /// that the peer can initiate on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Returns: The initial value for the maximum concurrent unidirectional streams.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_get_initial_max_streams_unidirectional(
        options: NonNull<nw_protocol_options_t>,
    ) -> u64;
}

extern "C-unwind" {
    /// Set the initial value of maximum unidirectional streams
    /// that the peer can initiate on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Parameter `initial_max_streams_unidirectional`: The initial value for the maximum concurrent unidirectional streams.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_set_initial_max_streams_unidirectional(
        options: NonNull<nw_protocol_options_t>,
        initial_max_streams_unidirectional: u64,
    );
}

extern "C-unwind" {
    /// Get the initial_max_stream_data_bidi_local transport parameter
    /// on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Returns: How much data the client is willing to receive on a locally initiated stream.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_get_initial_max_stream_data_bidirectional_local(
        options: NonNull<nw_protocol_options_t>,
    ) -> u64;
}

extern "C-unwind" {
    /// Set the initial_max_stream_data_bidi_local transport parameter
    /// on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Parameter `initial_max_stream_data_bidirectional_local`: The initial_max_stream_data_bidi_local controls how much data
    /// the client is willing to receive on a locally initiated stream.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_set_initial_max_stream_data_bidirectional_local(
        options: NonNull<nw_protocol_options_t>,
        initial_max_stream_data_bidirectional_local: u64,
    );
}

extern "C-unwind" {
    /// Get the initial_max_stream_data_bidi_remote transport parameter
    /// on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Returns: How much data the client is willing to receive on a remotely initiated stream.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_get_initial_max_stream_data_bidirectional_remote(
        options: NonNull<nw_protocol_options_t>,
    ) -> u64;
}

extern "C-unwind" {
    /// Set the initial_max_stream_data_bidi_remote transport parameter
    /// on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Parameter `initial_max_stream_data_bidirectional_remote`: The initial_max_stream_data_bidi_remote controls how much data
    /// the client is willing to receive on a remotely initiated stream.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_set_initial_max_stream_data_bidirectional_remote(
        options: NonNull<nw_protocol_options_t>,
        initial_max_stream_data_bidirectional_remote: u64,
    );
}

extern "C-unwind" {
    /// Get the initial_max_stream_data_uni transport parameter
    /// on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Returns: How much data the client is willing to receive on a unidirectional stream.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_get_initial_max_stream_data_unidirectional(
        options: NonNull<nw_protocol_options_t>,
    ) -> u64;
}

extern "C-unwind" {
    /// Set the initial_max_stream_data_uni transport parameter
    /// on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Parameter `initial_max_stream_data_unidirectional`: The initial_max_stream_data_uni controls how much data
    /// the client is willing to receive on a unidirectional stream.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_set_initial_max_stream_data_unidirectional(
        options: NonNull<nw_protocol_options_t>,
        initial_max_stream_data_unidirectional: u64,
    );
}

extern "C-unwind" {
    /// Get the max_datagram_frame_size transport parameter
    /// on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Returns: If greater than zero, the max_datagram_frame_size value indicates that
    /// DATAGRAM frames are supported, and describes the maximum number
    /// of bytes that a single DATAGRAM frame can contain.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_get_max_datagram_frame_size(options: NonNull<nw_protocol_options_t>) -> u16;
}

extern "C-unwind" {
    /// Set the max_datagram_frame_size transport parameter
    /// on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Parameter `max_datagram_frame_size`: If greater than zero, the max_datagram_frame_size value indicates that
    /// DATAGRAM frames are supported, and describes the maximum number
    /// of bytes that a single DATAGRAM frame can contain.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_quic_set_max_datagram_frame_size(
        options: NonNull<nw_protocol_options_t>,
        max_datagram_frame_size: u16,
    );
}

/// Represents the type of a QUIC stream.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_quic_stream_type_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_quic_stream_type_t(pub c_uint);
impl nw_quic_stream_type_t {
    #[doc(alias = "nw_quic_stream_type_unknown")]
    pub const unknown: Self = Self(0);
    #[doc(alias = "nw_quic_stream_type_bidirectional")]
    pub const bidirectional: Self = Self(1);
    #[doc(alias = "nw_quic_stream_type_unidirectional")]
    pub const unidirectional: Self = Self(2);
    #[doc(alias = "nw_quic_stream_type_datagram")]
    pub const datagram: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_quic_stream_type_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_quic_stream_type_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Checks if a protocol metadata object is compatible with the
    /// accessors defined in this file for the default system
    /// implementation of QUIC.
    ///
    ///
    /// Returns: Returns true if the metadata is for the default system QUIC,
    /// false otherwise.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_protocol_metadata_is_quic(metadata: NonNull<nw_protocol_metadata_t>) -> bool;
}

extern "C-unwind" {
    /// Get the QUIC stream ID.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for a QUIC stream.
    ///
    ///
    /// Returns: Returns the QUIC stream id.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_quic_get_stream_id(metadata: NonNull<nw_protocol_metadata_t>) -> u64;
}

extern "C-unwind" {
    /// Describes the type of the QUIC stream.
    ///
    ///
    /// Parameter `stream_metadata`: A nw_protocol_metadata_t for a QUIC stream.
    ///
    ///
    /// Returns: Returns the type of the QUIC stream, stored in nw_quic_stream_type_t.
    /// If the type can not be determined, returns nw_quic_stream_type_unknown.
    ///
    /// # Safety
    ///
    /// `stream_metadata` must be a valid pointer.
    pub fn nw_quic_get_stream_type(stream_metadata: NonNull<nw_protocol_metadata_t>) -> u8;
}

extern "C-unwind" {
    /// Access the Application Error value received from the peer in a stream close
    /// message.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for a QUIC stream.
    ///
    ///
    /// Returns: Returns the Application Error code value received from by the peer,
    /// or UINT64_MAX if no error has been received.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_quic_get_stream_application_error(metadata: NonNull<nw_protocol_metadata_t>) -> u64;
}

extern "C-unwind" {
    /// Set an Application Error value to send to the peer when the stream
    /// is closed.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for a QUIC stream.
    ///
    ///
    /// Parameter `application_error`: An application-specific error code value.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_quic_set_stream_application_error(
        metadata: NonNull<nw_protocol_metadata_t>,
        application_error: u64,
    );
}

extern "C-unwind" {
    /// Get the most recent value of the maximum number of bidirectional streams that the peer can create.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Returns: Returns the most recent value of the peer's max number of bidirectional streams.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_quic_get_local_max_streams_bidirectional(
        metadata: NonNull<nw_protocol_metadata_t>,
    ) -> u64;
}

extern "C-unwind" {
    /// Sets the maximum number of bidirectional streams that the peer can create.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Parameter `max_streams_bidirectional`: The new number of maximum bidirectional streams.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_quic_set_local_max_streams_bidirectional(
        metadata: NonNull<nw_protocol_metadata_t>,
        max_streams_bidirectional: u64,
    );
}

extern "C-unwind" {
    /// Get the most recent value of the maximum number of unidirectional streams that the peer can create.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Returns: Returns the most recent value of the peer's max number of unidirectional streams.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_quic_get_local_max_streams_unidirectional(
        metadata: NonNull<nw_protocol_metadata_t>,
    ) -> u64;
}

extern "C-unwind" {
    /// Sets the maximum number of unidirectional streams that the peer can create.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Parameter `max_streams_unidirectional`: The new number of maximum unidirectional streams.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_quic_set_local_max_streams_unidirectional(
        metadata: NonNull<nw_protocol_metadata_t>,
        max_streams_unidirectional: u64,
    );
}

extern "C-unwind" {
    /// Get the maximum number of bidirectional streams advertised by peer that an application
    /// is allowed to create.
    ///
    /// Note that while attempts to create streams above this limit will
    /// be blocked until the server increases the limit, these blocked
    /// attempts will cause a STREAMS_BLOCKED frame to be sent to the
    /// server. This informs the server that the client has more streams
    /// it would like to create. As a result, the caller should attempt to
    /// create streams over this limit if it desires more streams.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Returns: Returns the most recent value of the peer's advertised max number of bidirectional streams.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_quic_get_remote_max_streams_bidirectional(
        metadata: NonNull<nw_protocol_metadata_t>,
    ) -> u64;
}

extern "C-unwind" {
    /// Get the maximum number of unidirectional streams advertised by peer that an application
    /// is allowed to create.
    ///
    /// Note that while attempts to create streams above this limit will
    /// be blocked until the server increases the limit, these blocked
    /// attempts will cause a STREAMS_BLOCKED frame to be sent to the
    /// server. This informs the server that the client has more streams
    /// it would like to create. As a result, the caller should attempt to
    /// create streams over this limit if it desires more streams.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Returns: Returns the most recent value of the peer's advertised max number of unidirectional streams.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_quic_get_remote_max_streams_unidirectional(
        metadata: NonNull<nw_protocol_metadata_t>,
    ) -> u64;
}

extern "C-unwind" {
    /// Get the usable size of a datagram frame from a QUIC datagram flow.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Returns: Returns the usable datagram frame size.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_quic_get_stream_usable_datagram_frame_size(
        metadata: NonNull<nw_protocol_metadata_t>,
    ) -> u16;
}

extern "C-unwind" {
    /// Access the Application Error value received from the peer in a connection close
    /// message.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Returns: Returns the Application Error code value received from by the peer,
    /// or UINT64_MAX if no    error has been received.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_quic_get_application_error(metadata: NonNull<nw_protocol_metadata_t>) -> u64;
}

extern "C-unwind" {
    /// Access the Application Error reason string received from the peer in a connection
    /// close message.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Returns: Returns the Application Error reason received from by the peer,
    /// or NULL if no error reason has been received.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_quic_get_application_error_reason(
        metadata: NonNull<nw_protocol_metadata_t>,
    ) -> *const c_char;
}

extern "C-unwind" {
    /// Set the Application Error value to send to the peer in a connection close
    /// message.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Parameter `application_error`: Sets the Application Error code value.
    ///
    ///
    /// Parameter `reason`: An optional reason string to associate with the error.
    ///
    /// # Safety
    ///
    /// - `metadata` must be a valid pointer.
    /// - `reason` must be a valid pointer or null.
    pub fn nw_quic_set_application_error(
        metadata: NonNull<nw_protocol_metadata_t>,
        application_error: u64,
        reason: *const c_char,
    );
}

extern "C-unwind" {
    /// Retrieves the keep-alive interval set on a QUIC connection.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Returns: Returns value of the keep-alive interval, in seconds,
    /// or 0 if the keep-alive timer is disabled.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_quic_get_keepalive_interval(metadata: NonNull<nw_protocol_metadata_t>) -> u16;
}

extern "C-unwind" {
    /// Changes the keep-alive interval for QUIC.
    ///
    ///
    /// QUIC connections are encrypted and operate over the UDP protocol
    /// which makes it hard for Network Address    Translators and firewalls
    /// to track their state. For this reason, these middleboxes may
    /// use short timeouts for QUIC flows. By sending keep-alive packets
    /// (QUIC PING frames), the endpoint can maintain
    /// state of the flow across the network.
    /// Keep-alives should only be enabled while there is an outstanding
    /// exchange of information with the remote endpoint that has not yet
    /// completed, it is not recommended to enable keep-alive packets on an
    /// idle connection that is not expecting to send or receive data in
    /// the near future.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Parameter `keepalive_interval`: The keep-alive interval for QUIC, in seconds,
    /// or 0 if the keep-alive timer is disabled.
    /// Pass `NW_QUIC_CONNECTION_DEFAULT_KEEPALIVE` to use the default
    /// keep-alive interval.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_quic_set_keepalive_interval(
        metadata: NonNull<nw_protocol_metadata_t>,
        keepalive_interval: u16,
    );
}

extern "C-unwind" {
    /// Access the idle_timeout value in milliseconds received from the peer
    /// in the transport parameters.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Returns: Returns the idle_timeout value in milliseconds received from the peer.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_quic_get_remote_idle_timeout(metadata: NonNull<nw_protocol_metadata_t>) -> u64;
}

/// Access the definition of the default system protocol implementation
/// of TCP (Transmission Control Protocol). This protocol can be used
/// as part of a connection's protocol stack as the transport protocol.
///
///
/// Returns: Returns a retained protocol definition object.
#[inline]
pub extern "C-unwind" fn nw_protocol_copy_tcp_definition() -> NWRetained<nw_protocol_definition_t> {
    extern "C-unwind" {
        fn nw_protocol_copy_tcp_definition() -> Option<NonNull<nw_protocol_definition_t>>;
    }
    let ret = unsafe { nw_protocol_copy_tcp_definition() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Create an instance of TCP protocol options. This object can be added
/// to an nw_protocol_stack_t to be used in an nw_connection_t or
/// an nw_listener_t.
///
///
/// Returns: Returns a retained protocol options object.
#[inline]
pub extern "C-unwind" fn nw_tcp_create_options() -> NWRetained<nw_protocol_options_t> {
    extern "C-unwind" {
        fn nw_tcp_create_options() -> Option<NonNull<nw_protocol_options_t>>;
    }
    let ret = unsafe { nw_tcp_create_options() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Configure TCP to disable Nagle's algorithm, which will
    /// delay sending packets to coalesce sending.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `no_delay`: A boolean indicating that TCP should disable
    /// Nagle's algorithm.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_tcp_options_set_no_delay(options: NonNull<nw_protocol_options_t>, no_delay: bool);
}

extern "C-unwind" {
    /// Wait to send TCP data until the connection has finished
    /// writing, or else the TCP send buffer is full.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `no_push`: A boolean indicating that TCP should be set into
    /// no-push mode.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_tcp_options_set_no_push(options: NonNull<nw_protocol_options_t>, no_push: bool);
}

extern "C-unwind" {
    /// Disable sending TCP options and extensions.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `no_options`: A boolean indicating that TCP should be set into
    /// no-options mode.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_tcp_options_set_no_options(options: NonNull<nw_protocol_options_t>, no_options: bool);
}

extern "C-unwind" {
    /// Enable sending TCP keepalive probes.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `enable_keepalive`: A boolean indicating that TCP should send keepalives.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_tcp_options_set_enable_keepalive(
        options: NonNull<nw_protocol_options_t>,
        enable_keepalive: bool,
    );
}

extern "C-unwind" {
    /// Configure the number of times TCP keepalive probes
    /// should be sent without reply before terminating
    /// the connection.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `keepalive_count`: The number of keepalive probes to send before terminating
    /// the connection.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_tcp_options_set_keepalive_count(
        options: NonNull<nw_protocol_options_t>,
        keepalive_count: u32,
    );
}

extern "C-unwind" {
    /// Configure the amount of time that a connection must be
    /// idle before TCP should start sending keepalive probes.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `keepalive_idle_time`: The number of seconds of idleness to wait before keepalive
    /// probes are sent by TCP.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_tcp_options_set_keepalive_idle_time(
        options: NonNull<nw_protocol_options_t>,
        keepalive_idle_time: u32,
    );
}

extern "C-unwind" {
    /// Configure the amount of time between sending TCP keepalive
    /// probes when the peer is not responding.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `keepalive_interval`: The number of seconds of to wait before resending TCP
    /// keepalive probes.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_tcp_options_set_keepalive_interval(
        options: NonNull<nw_protocol_options_t>,
        keepalive_interval: u32,
    );
}

extern "C-unwind" {
    /// Directly configure the maximum segment size (MSS)
    /// TCP will use.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `maximum_segment_size`: The maximum segment size in bytes.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_tcp_options_set_maximum_segment_size(
        options: NonNull<nw_protocol_options_t>,
        maximum_segment_size: u32,
    );
}

extern "C-unwind" {
    /// Define a timeout value after which TCP connection
    /// establishment will give up.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `connection_timeout`: A timeout for TCP connection establishment, in seconds.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_tcp_options_set_connection_timeout(
        options: NonNull<nw_protocol_options_t>,
        connection_timeout: u32,
    );
}

extern "C-unwind" {
    /// Define a timeout value after which TCP connections
    /// in the persist state will terminate. See RFC 6429.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `persist_timeout`: The TCP persist timeout, in seconds.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_tcp_options_set_persist_timeout(
        options: NonNull<nw_protocol_options_t>,
        persist_timeout: u32,
    );
}

extern "C-unwind" {
    /// Define a timeout value after which TCP will drop
    /// a connection with unacknowledged retransmissions.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `retransmit_connection_drop_time`: A timeout for TCP retransmission attempts, in seconds.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_tcp_options_set_retransmit_connection_drop_time(
        options: NonNull<nw_protocol_options_t>,
        retransmit_connection_drop_time: u32,
    );
}

extern "C-unwind" {
    /// Cause TCP to drop connections after not receiving
    /// an ACK multiple times after a FIN, currently set at three.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `retransmit_fin_drop`: A boolean to cause TCP to drop its connection after
    /// not receiving an ACK after a FIN.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_tcp_options_set_retransmit_fin_drop(
        options: NonNull<nw_protocol_options_t>,
        retransmit_fin_drop: bool,
    );
}

extern "C-unwind" {
    /// Configure TCP to disable ACK stretching. ACKs will be sent
    /// for every other data packet.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `disable_ack_stretching`: A boolean to cause TCP to disable ACK stretching.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_tcp_options_set_disable_ack_stretching(
        options: NonNull<nw_protocol_options_t>,
        disable_ack_stretching: bool,
    );
}

extern "C-unwind" {
    /// Configure TCP to enable TCP Fast Open (TFO). This may take effect
    /// even when TCP is not the top-level protocol in the protocol stack.
    /// For example, if TLS is running over TCP, the Client Hello message
    /// may be sent as fast open data.
    ///
    /// If TCP is the top-level protocol in the stack (the one the application
    /// directly interacts with), TFO will be disabled unless the application
    /// indicated that it will provide its own fast open data by calling
    /// nw_parameters_set_fast_open_enabled().
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `enable_fast_open`: A boolean to enable TFO.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_tcp_options_set_enable_fast_open(
        options: NonNull<nw_protocol_options_t>,
        enable_fast_open: bool,
    );
}

extern "C-unwind" {
    /// Configure TCP to disable default Explicit Congestion
    /// Notification (ECN) behavior.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `disable_ecn`: A boolean to disable ECN support in TCP.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_tcp_options_set_disable_ecn(
        options: NonNull<nw_protocol_options_t>,
        disable_ecn: bool,
    );
}

/// Multipath versions represent the MPTCP standard versions
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_multipath_version_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_multipath_version_t(pub c_int);
impl nw_multipath_version_t {
    #[doc(alias = "nw_multipath_version_unspecified")]
    pub const unspecified: Self = Self(-1);
    #[doc(alias = "nw_multipath_version_0")]
    pub const v0: Self = Self(0);
    #[doc(alias = "nw_multipath_version_1")]
    pub const v1: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_multipath_version_t {
    const ENCODING: Encoding = c_int::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_multipath_version_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Configure MPTCP to use a specified MPTCP standard version.
    /// This ignores the cached value from MPTCP version discovery.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `multipath_force_version`: The MPTCP version.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_tcp_options_set_multipath_force_version(
        options: NonNull<nw_protocol_options_t>,
        multipath_force_version: nw_multipath_version_t,
    );
}

extern "C-unwind" {
    /// Checks if a protocol metadata object is compatible with the
    /// accessors defined in this file for the default system
    /// implementation of TCP.
    ///
    ///
    /// Returns: Returns true if the metadata is for the default system TCP,
    /// false otherwise.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_protocol_metadata_is_tcp(metadata: NonNull<nw_protocol_metadata_t>) -> bool;
}

extern "C-unwind" {
    /// Fetch the number of bytes waiting to be read from the receive buffer.
    ///
    ///
    /// Returns: The number of bytes available in the receive buffer.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_tcp_get_available_receive_buffer(metadata: NonNull<nw_protocol_metadata_t>) -> u32;
}

extern "C-unwind" {
    /// Fetch the number of bytes waiting to be acknowledged in the send buffer.
    ///
    ///
    /// Returns: The number of bytes waiting to be acknowledged.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_tcp_get_available_send_buffer(metadata: NonNull<nw_protocol_metadata_t>) -> u32;
}

/// Access the definition of the default system protocol implementation
/// of TLS (Transport Layer Security). This protocol can be used
/// as part of a connection's protocol stack as an application protocol.
///
///
/// Returns: Returns a retained protocol definition object.
#[inline]
pub extern "C-unwind" fn nw_protocol_copy_tls_definition() -> NWRetained<nw_protocol_definition_t> {
    extern "C-unwind" {
        fn nw_protocol_copy_tls_definition() -> Option<NonNull<nw_protocol_definition_t>>;
    }
    let ret = unsafe { nw_protocol_copy_tls_definition() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Create an instance of TLS protocol options. This object can be added
/// to an nw_protocol_stack_t to be used in an nw_connection_t or
/// an nw_listener_t.
///
///
/// Returns: Returns a retained protocol options object.
#[inline]
pub extern "C-unwind" fn nw_tls_create_options() -> NWRetained<nw_protocol_options_t> {
    extern "C-unwind" {
        fn nw_tls_create_options() -> Option<NonNull<nw_protocol_options_t>>;
    }
    let ret = unsafe { nw_tls_create_options() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Checks if a protocol metadata object is compatible with the
    /// accessors defined in this file for the default system
    /// implementation of TLS.
    ///
    ///
    /// Returns: Returns true if the metadata is for the default system TLS,
    /// false otherwise.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_protocol_metadata_is_tls(metadata: NonNull<nw_protocol_metadata_t>) -> bool;
}

/// Access the definition of the default system protocol implementation
/// of UDP (User Datagram Protocol). This protocol can be used
/// as part of a connection's protocol stack as the transport protocol.
///
///
/// Returns: Returns a retained protocol definition object.
#[inline]
pub extern "C-unwind" fn nw_protocol_copy_udp_definition() -> NWRetained<nw_protocol_definition_t> {
    extern "C-unwind" {
        fn nw_protocol_copy_udp_definition() -> Option<NonNull<nw_protocol_definition_t>>;
    }
    let ret = unsafe { nw_protocol_copy_udp_definition() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Create an instance of UDP protocol options. This object can be added
/// to an nw_protocol_stack_t to be used in an nw_connection_t or
/// an nw_listener_t.
///
///
/// Returns: Returns a retained protocol options object.
#[inline]
pub extern "C-unwind" fn nw_udp_create_options() -> NWRetained<nw_protocol_options_t> {
    extern "C-unwind" {
        fn nw_udp_create_options() -> Option<NonNull<nw_protocol_options_t>>;
    }
    let ret = unsafe { nw_udp_create_options() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Configure UDP to skip computing checksums when sending.
    /// This will only take effect when running over IPv4.
    ///
    ///
    /// Parameter `options`: A UDP protocol options object.
    ///
    ///
    /// Parameter `prefer_no_checksum`: A boolean that indicates if UDP is allowed to skip computing
    /// its checksum.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_udp_options_set_prefer_no_checksum(
        options: NonNull<nw_protocol_options_t>,
        prefer_no_checksum: bool,
    );
}

/// Create an instance of UDP metadata that can be used
/// to configure per-datagram options when sending data
/// on a connection.
///
///
/// Returns: Returns a retained protocol metadata object.
#[inline]
pub extern "C-unwind" fn nw_udp_create_metadata() -> NWRetained<nw_protocol_metadata_t> {
    extern "C-unwind" {
        fn nw_udp_create_metadata() -> Option<NonNull<nw_protocol_metadata_t>>;
    }
    let ret = unsafe { nw_udp_create_metadata() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Checks if a protocol metadata object is compatible with the
    /// accessors defined in this file for the default system
    /// implementation of UDP.
    ///
    ///
    /// Returns: Returns true if the metadata is for the default system UDP,
    /// false otherwise.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_protocol_metadata_is_udp(metadata: NonNull<nw_protocol_metadata_t>) -> bool;
}

/// WebSocket opcodes that denote the type of frame sent or received by
/// a WebSocket endpoint. Opcodes define the interpretation of their
/// associated payload data.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_opcode_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_ws_opcode_t(pub c_int);
impl nw_ws_opcode_t {
    #[doc(alias = "nw_ws_opcode_invalid")]
    pub const invalid: Self = Self(-1);
    /// Protocol WebSocket handles continuation frames internally,
    /// so clients will not see or use continuation frames.
    #[doc(alias = "nw_ws_opcode_cont")]
    pub const cont: Self = Self(0x0);
    #[doc(alias = "nw_ws_opcode_text")]
    pub const text: Self = Self(0x1);
    #[doc(alias = "nw_ws_opcode_binary")]
    pub const binary: Self = Self(0x2);
    #[doc(alias = "nw_ws_opcode_close")]
    pub const close: Self = Self(0x8);
    #[doc(alias = "nw_ws_opcode_ping")]
    pub const ping: Self = Self(0x9);
    #[doc(alias = "nw_ws_opcode_pong")]
    pub const pong: Self = Self(0xA);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ws_opcode_t {
    const ENCODING: Encoding = c_int::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ws_opcode_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// WebSocket close codes that describe the reason for closing a WebSocket
/// connection. Endpoints MAY use the following pre-defined status codes
/// when sending a Close frame.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_close_code_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_ws_close_code_t(pub c_uint);
impl nw_ws_close_code_t {
    /// meaning that the purpose for which the connection was established
    /// has been fulfilled.
    #[doc(alias = "nw_ws_close_code_normal_closure")]
    pub const normal_closure: Self = Self(1000);
    /// "going away", such as a server going down or a browser having
    /// navigated away from a page.
    #[doc(alias = "nw_ws_close_code_going_away")]
    pub const going_away: Self = Self(1001);
    /// terminating the connection due to a protocol error.
    #[doc(alias = "nw_ws_close_code_protocol_error")]
    pub const protocol_error: Self = Self(1002);
    /// terminating the connection because it has received a type of data
    /// it cannot accept (e.g., an endpoint that understands only text data
    /// MAY send this if it receives a binary message).
    #[doc(alias = "nw_ws_close_code_unsupported_data")]
    pub const unsupported_data: Self = Self(1003);
    /// be set as a status code in a Close control frame by an endpoint. It
    /// is designated for use in applications expecting a status code to
    /// indicate that no status code was actually present.
    #[doc(alias = "nw_ws_close_code_no_status_received")]
    pub const no_status_received: Self = Self(1005);
    /// be set as a status code in a Close control frame by an endpoint.
    /// It is designated for use in applications expecting a status code to
    /// indicate that the connection was closed abnormally, e.g., without
    /// sending or receiving a Close control frame.
    #[doc(alias = "nw_ws_close_code_abnormal_closure")]
    pub const abnormal_closure: Self = Self(1006);
    /// endpoint is terminating the connection because it has received data
    /// within a message that was not consistent with the type of the
    /// message (e.g., non-UTF-8 [RFC3629] data within a text message).
    #[doc(alias = "nw_ws_close_code_invalid_frame_payload_data")]
    pub const invalid_frame_payload_data: Self = Self(1007);
    /// terminating the connection because it has received a message that
    /// violates its policy. This is a generic status code that can be
    /// returned when there is no other more suitable status code (e.g.,
    /// 1003 or 1009) or if there is a need to hide specific details about
    /// the policy.
    #[doc(alias = "nw_ws_close_code_policy_violation")]
    pub const policy_violation: Self = Self(1008);
    /// terminating the connection because it has received a message that
    /// is too big for it to process.
    #[doc(alias = "nw_ws_close_code_message_too_big")]
    pub const message_too_big: Self = Self(1009);
    /// (client) is terminating the connection because it has expected the
    /// server to negotiate one or more extensions, but the server didn't
    /// return them in the response message of the WebSocket handshake. The
    /// list of extensions that are needed SHOULD appear in the /reason/
    /// part of the Close frame. Note that this status code is not used by
    /// the server, because it can fail the WebSocket handshake instead.
    #[doc(alias = "nw_ws_close_code_mandatory_extension")]
    pub const mandatory_extension: Self = Self(1010);
    /// terminating the connection because it encountered an unexpected
    /// condition that prevented it from fulfilling the request.
    #[doc(alias = "nw_ws_close_code_internal_server_error")]
    pub const internal_server_error: Self = Self(1011);
    /// be set as a status code in a Close control frame by an endpoint. It
    /// is designated for use in applications expecting a status code to
    /// indicate that the connection was closed due to a failure to perform
    /// a TLS handshake (e.g., the server certificate can't be verified).
    #[doc(alias = "nw_ws_close_code_tls_handshake")]
    pub const tls_handshake: Self = Self(1015);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ws_close_code_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ws_close_code_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The WebSocket Protocol version.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_version_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_ws_version_t(pub c_uint);
impl nw_ws_version_t {
    #[doc(alias = "nw_ws_version_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_ws_version_13")]
    pub const v13: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ws_version_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ws_version_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Access the definition of the default system implementation of the
/// WebSocket protocol. This protocol can be appended to a connection's
/// protocol stack.
///
///
/// Returns: Returns a retained protocol definition object.
#[inline]
pub extern "C-unwind" fn nw_protocol_copy_ws_definition() -> NWRetained<nw_protocol_definition_t> {
    extern "C-unwind" {
        fn nw_protocol_copy_ws_definition() -> Option<NonNull<nw_protocol_definition_t>>;
    }
    let ret = unsafe { nw_protocol_copy_ws_definition() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Create an instance of WebSocket protocol options. This object can be
/// added to an nw_protocol_stack_t to be used in an nw_connection_t or
/// an nw_listener_t.
///
///
/// Returns: Returns a retained protocol options object.
#[inline]
pub extern "C-unwind" fn nw_ws_create_options(
    version: nw_ws_version_t,
) -> NWRetained<nw_protocol_options_t> {
    extern "C-unwind" {
        fn nw_ws_create_options(version: nw_ws_version_t)
            -> Option<NonNull<nw_protocol_options_t>>;
    }
    let ret = unsafe { nw_ws_create_options(version) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Set additional HTTP headers to be sent by the client during the
    /// WebSocket handshake.
    ///
    ///
    /// Parameter `options`: The WebSocket protocol options object.
    ///
    ///
    /// Parameter `name`: The HTTP header name.
    ///
    ///
    /// Parameter `value`: The HTTP header value.
    ///
    /// # Safety
    ///
    /// - `options` must be a valid pointer.
    /// - `name` must be a valid pointer.
    /// - `value` must be a valid pointer.
    pub fn nw_ws_options_add_additional_header(
        options: NonNull<nw_protocol_options_t>,
        name: NonNull<c_char>,
        value: NonNull<c_char>,
    );
}

extern "C-unwind" {
    /// Add to the list of subprotocols that will be presented to a
    /// WebSocket server during connection establishment.
    ///
    ///
    /// Parameter `options`: The WebSocket protocol options object.
    ///
    ///
    /// Parameter `subprotocol`: The subprotocol supported by the client.
    ///
    /// # Safety
    ///
    /// - `options` must be a valid pointer.
    /// - `subprotocol` must be a valid pointer.
    pub fn nw_ws_options_add_subprotocol(
        options: NonNull<nw_protocol_options_t>,
        subprotocol: NonNull<c_char>,
    );
}

extern "C-unwind" {
    /// Set whether the WebSocket connection should automatically reply to all
    /// incoming pings. If set to true, the WebSocket protocol will automatically
    /// reply to incoming pings and will deliver the pings to receive requests
    /// on the connection.
    ///
    ///
    /// Parameter `options`: The WebSocket protocol options object.
    ///
    ///
    /// Parameter `auto_reply_ping`: Whether the WebSocket connection should automatically reply to all
    /// incoming pings.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_ws_options_set_auto_reply_ping(
        options: NonNull<nw_protocol_options_t>,
        auto_reply_ping: bool,
    );
}

extern "C-unwind" {
    /// Set whether the WebSocket protocol should skip the opening handshake
    /// and begin framing data as soon as a connection is established.
    ///
    ///
    /// Parameter `options`: The WebSocket protocol options object.
    ///
    ///
    /// Parameter `skip_handshake`: Whether the WebSocket connection should skip the opening handshake.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_ws_options_set_skip_handshake(
        options: NonNull<nw_protocol_options_t>,
        skip_handshake: bool,
    );
}

extern "C-unwind" {
    /// Set the maximum allowed message size to be received by the WebSocket
    /// connection. This does not limit the sending message size.
    ///
    ///
    /// Parameter `options`: The WebSocket protocol options object.
    ///
    ///
    /// Parameter `maximum_message_size`: The maximum message size in bytes. A maximum message size of 0 means
    /// there is no receive limit. The default maximum message size is 0.
    ///
    /// # Safety
    ///
    /// `options` must be a valid pointer.
    pub fn nw_ws_options_set_maximum_message_size(
        options: NonNull<nw_protocol_options_t>,
        maximum_message_size: usize,
    );
}

extern "C-unwind" {
    /// Checks if a protocol metadata object is compatible with the
    /// accessors defined in this file for the default system
    /// implementation of WebSocket.
    ///
    ///
    /// Returns: Returns true if the metadata is for the default system
    /// implementation of WebSocket, false otherwise.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_protocol_metadata_is_ws(metadata: NonNull<nw_protocol_metadata_t>) -> bool;
}

/// Creates a protocol metadata object that can be used to define the
/// content context of messages sent over a WebSocket connection.
///
///
/// Parameter `opcode`: Set the opcode on a WebSocket frame. This must be defined on create.
///
///
/// Returns: Returns a retained metadata object representing the WebSocket frame.
#[inline]
pub extern "C-unwind" fn nw_ws_create_metadata(
    opcode: nw_ws_opcode_t,
) -> NWRetained<nw_protocol_metadata_t> {
    extern "C-unwind" {
        fn nw_ws_create_metadata(opcode: nw_ws_opcode_t)
            -> Option<NonNull<nw_protocol_metadata_t>>;
    }
    let ret = unsafe { nw_ws_create_metadata(opcode) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Get the opcode on a WebSocket frame.
    ///
    ///
    /// Parameter `metadata`: The metadata object representing the WebSocket frame.
    ///
    ///
    /// Returns: The opcode on the WebSocket frame.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_ws_metadata_get_opcode(metadata: NonNull<nw_protocol_metadata_t>) -> nw_ws_opcode_t;
}

extern "C-unwind" {
    /// Set the close code on a WebSocket frame. The WebSocket frame's opcode
    /// should be nw_ws_opcode_close.
    ///
    ///
    /// Parameter `metadata`: The metadata object representing the WebSocket frame.
    ///
    ///
    /// Parameter `close_code`: The close code on the WebSocket frame.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_ws_metadata_set_close_code(
        metadata: NonNull<nw_protocol_metadata_t>,
        close_code: nw_ws_close_code_t,
    );
}

extern "C-unwind" {
    /// Get the close code from a WebSocket frame. If the close code is equal
    /// to nw_ws_close_code_no_status_received, it means that a close code
    /// was not actually present in the WebSocket frame.
    ///
    ///
    /// Parameter `metadata`: The metadata object representing the WebSocket frame.
    ///
    ///
    /// Returns: The close code on the WebSocket frame.
    ///
    /// # Safety
    ///
    /// `metadata` must be a valid pointer.
    pub fn nw_ws_metadata_get_close_code(
        metadata: NonNull<nw_protocol_metadata_t>,
    ) -> nw_ws_close_code_t;
}

/// A block to be invoked when a pong reply is received after sending a ping
/// message, or if the WebSocket connection has closed or failed.
///
///
/// Parameter `error`: An optional error if the WebSocket connection fails or closes before a
/// pong reply is received.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_pong_handler_t?language=objc)
pub type nw_ws_pong_handler_t = *mut block2::DynBlock<dyn Fn(*mut nw_error_t)>;

extern "C-unwind" {
    /// Set a callback that will notify the client when a pong message has been
    /// received for a ping message sent. The metadata object's associated
    /// opcode should be nw_ws_opcode_ping.
    ///
    ///
    /// Parameter `metadata`: The WebSocket metadata object.
    ///
    ///
    /// Parameter `client_queue`: The queue on which the pong handler will be delivered.
    ///
    ///
    /// Parameter `pong_handler`: The handler that gets called when a pong reply is received.
    ///
    /// # Safety
    ///
    /// - `metadata` must be a valid pointer.
    /// - `pong_handler` must be a valid pointer.
    pub fn nw_ws_metadata_set_pong_handler(
        metadata: NonNull<nw_protocol_metadata_t>,
        client_queue: &DispatchQueue,
        pong_handler: nw_ws_pong_handler_t,
    );
}

/// A block that can be applied to every subprotocol in a client's WebSocket
/// request.
///
///
/// Parameter `subprotocol`: A subprotocol presented by the client.
///
///
/// Returns: A boolean value that indicating if enumeration should continue.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_subprotocol_enumerator_t?language=objc)
pub type nw_ws_subprotocol_enumerator_t = *mut block2::DynBlock<dyn Fn(NonNull<c_char>) -> bool>;

extern "C-unwind" {
    /// Enumerates the list of subprotocols on the client's request.
    ///
    ///
    /// Parameter `request`: The client request.
    ///
    ///
    /// Parameter `enumerator`: The enumerator block.
    ///
    ///
    /// Returns: Whether the enumeration completed.
    ///
    /// # Safety
    ///
    /// - `request` must be a valid pointer.
    /// - `enumerator` must be a valid pointer.
    pub fn nw_ws_request_enumerate_subprotocols(
        request: NonNull<nw_ws_request_t>,
        enumerator: nw_ws_subprotocol_enumerator_t,
    ) -> bool;
}

/// A block that can be applied to every additional header in a client's
/// WebSocket request.
///
///
/// Parameter `name`: The HTTP name.
///
///
/// Parameter `value`: The HTTP value.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_additional_header_enumerator_t?language=objc)
pub type nw_ws_additional_header_enumerator_t =
    *mut block2::DynBlock<dyn Fn(NonNull<c_char>, NonNull<c_char>) -> bool>;

extern "C-unwind" {
    /// Enumerates the list of additional headers on the client's request.
    ///
    ///
    /// Parameter `request`: The client request.
    ///
    ///
    /// Parameter `enumerator`: The enumerator block.
    ///
    ///
    /// Returns: Whether the enumeration completed.
    ///
    /// # Safety
    ///
    /// - `request` must be a valid pointer.
    /// - `enumerator` must be a valid pointer.
    pub fn nw_ws_request_enumerate_additional_headers(
        request: NonNull<nw_ws_request_t>,
        enumerator: nw_ws_additional_header_enumerator_t,
    ) -> bool;
}

/// The status of a WebSocket server's response to a client's request to
/// connect.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_response_status_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_ws_response_status_t(pub c_uint);
impl nw_ws_response_status_t {
    /// be treated as an unexpected value.
    #[doc(alias = "nw_ws_response_status_invalid")]
    pub const invalid: Self = Self(0);
    /// WebSocket connection will begin framing data.
    #[doc(alias = "nw_ws_response_status_accept")]
    pub const accept: Self = Self(1);
    /// WebSocket connection will be closed.
    #[doc(alias = "nw_ws_response_status_reject")]
    pub const reject: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ws_response_status_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ws_response_status_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Create a server response to a WebSocket client's opening handshake.
///
///
/// Parameter `status`: The status of the response. If the status is nw_ws_response_status_accept,
/// the server will accept the handshake and open the WebSocket connection.
/// If the status is nw_ws_response_status_reject, the server will reject the
/// handshake and respond with the HTTP error 400 Bad Request.
///
///
/// Parameter `selected_subprotocol`: The server's selected protocol from the client's list of proposed
/// subprotocols. If the status of this response is nw_ws_response_status_reject,
/// this parameter is ignored. Pass NULL to indicate the server did not find
/// a suitable subprotocol, but has accepted the handshake anyways.
/// Passing an empty string is prohibited by the WebSocket protocol.
///
///
/// Returns: An instantiated WebSocket server response object.
///
/// # Safety
///
/// `selected_subprotocol` must be a valid pointer or null.
#[inline]
pub unsafe extern "C-unwind" fn nw_ws_response_create(
    status: nw_ws_response_status_t,
    selected_subprotocol: *const c_char,
) -> NWRetained<nw_ws_response_t> {
    extern "C-unwind" {
        fn nw_ws_response_create(
            status: nw_ws_response_status_t,
            selected_subprotocol: *const c_char,
        ) -> Option<NonNull<nw_ws_response_t>>;
    }
    let ret = unsafe { nw_ws_response_create(status, selected_subprotocol) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Get the status from a WebSocket server's response. If the response is
    /// nil, the return value will be nw_ws_response_status_invalid.
    ///
    ///
    /// Parameter `response`: The server response.
    ///
    ///
    /// Returns: The status of the server's response.
    ///
    /// # Safety
    ///
    /// `response` must be a valid pointer or null.
    pub fn nw_ws_response_get_status(response: *mut nw_ws_response_t) -> nw_ws_response_status_t;
}

extern "C-unwind" {
    /// Get the selected subprotocol from a WebSocket server's response.
    ///
    ///
    /// Parameter `response`: The server response.
    ///
    ///
    /// Returns: The status of the server's response.
    ///
    /// # Safety
    ///
    /// `response` must be a valid pointer.
    pub fn nw_ws_response_get_selected_subprotocol(
        response: NonNull<nw_ws_response_t>,
    ) -> *const c_char;
}

extern "C-unwind" {
    /// Add additional HTTP headers to be sent back to the WebSocket client in
    /// the server's response.
    ///
    ///
    /// Parameter `response`: The server response.
    ///
    ///
    /// Parameter `name`: The HTTP name.
    ///
    ///
    /// Parameter `value`: The HTTP value.
    ///
    /// # Safety
    ///
    /// - `response` must be a valid pointer.
    /// - `name` must be a valid pointer.
    /// - `value` must be a valid pointer.
    pub fn nw_ws_response_add_additional_header(
        response: NonNull<nw_ws_response_t>,
        name: NonNull<c_char>,
        value: NonNull<c_char>,
    );
}

/// Copy the WebSocket server's response to a client's request to connect.
/// If this is called on a WebSocket server, the response object will contain
/// the server's own response to the client.
///
///
/// Parameter `metadata`: The metadata object representing the WebSocket connection.
///
///
/// Returns: The server response.
///
/// # Safety
///
/// `metadata` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_ws_metadata_copy_server_response(
    metadata: NonNull<nw_protocol_metadata_t>,
) -> NWRetained<nw_ws_response_t> {
    extern "C-unwind" {
        fn nw_ws_metadata_copy_server_response(
            metadata: NonNull<nw_protocol_metadata_t>,
        ) -> Option<NonNull<nw_ws_response_t>>;
    }
    let ret = unsafe { nw_ws_metadata_copy_server_response(metadata) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Enumerates the list of additional headers on the server's response.
    ///
    ///
    /// Parameter `response`: The server response.
    ///
    ///
    /// Parameter `enumerator`: The enumerator block.
    ///
    ///
    /// Returns: Whether the enumeration completed.
    ///
    /// # Safety
    ///
    /// - `response` must be a valid pointer.
    /// - `enumerator` must be a valid pointer.
    pub fn nw_ws_response_enumerate_additional_headers(
        response: NonNull<nw_ws_response_t>,
        enumerator: nw_ws_additional_header_enumerator_t,
    ) -> bool;
}

/// A block to be invoked when a WebSocket server receives a WebSocket
/// client's request to connect.
///
///
/// Parameter `request`: The client request.
///
///
/// Returns: The server response.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_client_request_handler_t?language=objc)
pub type nw_ws_client_request_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<nw_ws_request_t>) -> NonNull<nw_ws_response_t>>;

extern "C-unwind" {
    /// Set callback handler to be invoked when a WebSocket server receives a
    /// WebSocket client's request to connect.
    ///
    ///
    /// Parameter `options`: The protocol options object.
    ///
    ///
    /// Parameter `client_queue`: The queue on which the client request handler will be delivered.
    ///
    ///
    /// Parameter `handler`: The callback handler.
    ///
    /// # Safety
    ///
    /// - `options` must be a valid pointer.
    /// - `handler` must be a valid pointer.
    pub fn nw_ws_options_set_client_request_handler(
        options: NonNull<nw_protocol_options_t>,
        client_queue: &DispatchQueue,
        handler: nw_ws_client_request_handler_t,
    );
}
