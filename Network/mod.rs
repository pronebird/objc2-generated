// This file has been automatically generated by `objc2`'s `header-translator`.
// DO NOT EDIT

#![allow(unused_imports)]
#![allow(deprecated)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(missing_docs)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::type_complexity)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::identity_op)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::doc_lazy_continuation)]
#![allow(rustdoc::broken_intra_doc_links)]
#![allow(rustdoc::bare_urls)]
#![allow(rustdoc::invalid_html_tags)]

#[link(name = "Network", kind = "framework")]
extern "C" {}

#[cfg(feature = "FoundationExtension")]
#[path = "FoundationExtension.rs"]
mod __FoundationExtension;

#[cfg(all(feature = "FoundationExtension", feature = "objc2"))]
pub use self::__FoundationExtension::NSURLSessionConfigurationNetwork;
use core::ffi::*;
use core::ptr::NonNull;
use dispatch2::*;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;

use crate::*;

extern "C-unwind" {
    /// # Safety
    ///
    /// `obj` must be a valid pointer.
    pub fn nw_retain(obj: *mut c_void) -> *mut c_void;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// `obj` must be a valid pointer.
    pub fn nw_release(obj: *mut c_void);
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_txt_record?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_txt_record: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_txt_record_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_txt_record_t = NSObject;

/// An enumeration of possible find results when trying to find a key-value
/// pair in the TXT record object.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_txt_record_find_key_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_txt_record_find_key_t(pub c_uint);
impl nw_txt_record_find_key_t {
    /// to RFC 1464, a key is invalid if it is an empty string, contains
    /// non-ASCII characters, or has length greater than UINT8_MAX.
    #[doc(alias = "nw_txt_record_find_key_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_txt_record_find_key_not_present")]
    pub const not_present: Self = Self(1);
    #[doc(alias = "nw_txt_record_find_key_no_value")]
    pub const no_value: Self = Self(2);
    #[doc(alias = "nw_txt_record_find_key_empty_value")]
    pub const empty_value: Self = Self(3);
    #[doc(alias = "nw_txt_record_find_key_non_empty_value")]
    pub const non_empty_value: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_txt_record_find_key_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_txt_record_find_key_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWTxtRecord {
    /// Create a new TXT record object from a buffer of bytes. If the buffer
    /// follows the key-value pair format as defined in RFC 1464, the TXT record
    /// object will be created as a dictionary. Otherwise, it is created as a
    /// TXT record buffer.
    ///
    ///
    /// Parameter `txt_bytes`: The pointer to the buffer.
    ///
    ///
    /// Parameter `txt_len`: The length of the buffer.
    ///
    ///
    /// Returns: An instantiated TXT record object.
    /// Callers are responsible for deallocating using nw_release(obj) or
    /// [obj release]. These objects support ARC.
    /// Returns NULL on failure. Fails if txt_bytes is NULL or if txt_len is 0.
    ///
    /// # Safety
    ///
    /// `txt_bytes` must be a valid pointer.
    #[doc(alias = "nw_txt_record_create_with_bytes")]
    #[inline]
    pub unsafe fn with_bytes(txt_bytes: NonNull<u8>, txt_len: usize) -> NWRetained<NWTxtRecord> {
        extern "C-unwind" {
            fn nw_txt_record_create_with_bytes(
                txt_bytes: NonNull<u8>,
                txt_len: usize,
            ) -> Option<NonNull<NWTxtRecord>>;
        }
        let ret = unsafe { nw_txt_record_create_with_bytes(txt_bytes, txt_len) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Create an empty TXT record dictionary.
    ///
    ///
    /// Returns: An empty TXT record dictionary.
    /// Callers are responsible for deallocating using nw_release(obj) or
    /// [obj release]. These objects support ARC.
    #[doc(alias = "nw_txt_record_create_dictionary")]
    #[inline]
    pub fn new_dictionary() -> NWRetained<NWTxtRecord> {
        extern "C-unwind" {
            fn nw_txt_record_create_dictionary() -> Option<NonNull<NWTxtRecord>>;
        }
        let ret = unsafe { nw_txt_record_create_dictionary() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Create a deep copy of an existing TXT record object.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object to be copied.
    ///
    ///
    /// Returns: A deep copy of the TXT record object.
    /// Callers are responsible for deallocating using nw_release(obj) or
    /// [obj release]. These objects support ARC.
    #[doc(alias = "nw_txt_record_copy")]
    #[inline]
    pub fn copy(&self) -> Option<NWRetained<NWTxtRecord>> {
        extern "C-unwind" {
            fn nw_txt_record_copy(txt_record: Option<&NWTxtRecord>)
                -> Option<NonNull<NWTxtRecord>>;
        }
        let ret = unsafe { nw_txt_record_copy(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }
}

impl nw_txt_record_find_key_t {
    /// Find a key-value pair in the TXT record object.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object.
    ///
    ///
    /// Parameter `key`: The key of the key-value pair.
    ///
    ///
    /// Returns: An nw_txt_record_find_key_t representing the type of the key-value pair found.
    /// The key may be invalid, may not exist, have no associated value, have an
    /// empty associated value, or have a non-empty associated value.
    ///
    /// # Safety
    ///
    /// `key` must be a valid pointer.
    #[doc(alias = "nw_txt_record_find_key")]
    #[inline]
    pub unsafe fn new(txt_record: &NWTxtRecord, key: NonNull<c_char>) -> nw_txt_record_find_key_t {
        extern "C-unwind" {
            fn nw_txt_record_find_key(
                txt_record: &NWTxtRecord,
                key: NonNull<c_char>,
            ) -> nw_txt_record_find_key_t;
        }
        unsafe { nw_txt_record_find_key(txt_record, key) }
    }
}

/// Access a value in the TXT record object with its key. Attempts to access
/// or modify the TXT record object from within the block are prohibited.
///
///
/// Parameter `key`: The key of the value.
///
///
/// Parameter `found`: An nw_txt_record_find_key_t representing the type of the key-value pair found.
/// The key may be invalid, may not exist, have no associated value, have an
/// empty associated value, or have a non-empty associated value.
///
///
/// Parameter `value`: The value corresponding to the key. If the key does not exist or has no
/// associated value, value will be NULL. Note that the bytes pointed to by
/// value are only valid within the scope of the block.
///
///
/// Parameter `value_len`: The length of the value. If the key does not exist or has no associated
/// value, value_len will be 0.
///
///
/// Returns: An arbitrary return value defined by the user. For example, the user may
/// want to return true if the operation succeeds.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_txt_record_access_key_t?language=objc)
pub type nw_txt_record_access_key_t = *mut block2::DynBlock<
    dyn Fn(NonNull<c_char>, nw_txt_record_find_key_t, *const u8, usize) -> bool,
>;

impl NWTxtRecord {
    /// Access a value in the TXT record object with its key. Attempts to access
    /// or modify the TXT record object from within the block are prohibited.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object.
    ///
    ///
    /// Parameter `access_value`: The block that will be used to access the value of the given key.
    ///
    ///
    /// Returns: The return value of the access_value block. This is an arbitrary return
    /// value defined by the user.
    ///
    /// # Safety
    ///
    /// - `key` must be a valid pointer.
    /// - `access_value` must be a valid pointer.
    #[doc(alias = "nw_txt_record_access_key")]
    #[inline]
    pub unsafe fn access_key(
        &self,
        key: NonNull<c_char>,
        access_value: nw_txt_record_access_key_t,
    ) -> bool {
        extern "C-unwind" {
            fn nw_txt_record_access_key(
                txt_record: &NWTxtRecord,
                key: NonNull<c_char>,
                access_value: nw_txt_record_access_key_t,
            ) -> bool;
        }
        unsafe { nw_txt_record_access_key(self, key, access_value) }
    }

    /// Set a key-value pair on the TXT record object.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object.
    ///
    ///
    /// Parameter `key`: The key that will be inserted. If the key already exists in the TXT
    /// record object, the existing key-value pair will be replaced.
    ///
    ///
    /// Parameter `value`: The value that will be inserted. If value is set to NULL, then the key
    /// will be inserted with no value.
    ///
    ///
    /// Parameter `value_len`: The length of the value will be inserted. If value is set to zero, then the
    /// key will be inserted with a zero-length value. Inserting a NULL value
    /// with a non-zero length will fail.
    ///
    ///
    /// Returns: A boolean indicating if the key-value pair was inserted successfully.
    /// Returns false if the key is invalid. A key is invalid if it is an empty
    /// string, contains non-ASCII characters, or has length greater than
    /// UINT8_MAX.
    ///
    /// # Safety
    ///
    /// - `key` must be a valid pointer.
    /// - `value` must be a valid pointer or null.
    #[doc(alias = "nw_txt_record_set_key")]
    #[inline]
    pub unsafe fn set_key(&self, key: NonNull<c_char>, value: *const u8, value_len: usize) -> bool {
        extern "C-unwind" {
            fn nw_txt_record_set_key(
                txt_record: &NWTxtRecord,
                key: NonNull<c_char>,
                value: *const u8,
                value_len: usize,
            ) -> bool;
        }
        unsafe { nw_txt_record_set_key(self, key, value, value_len) }
    }

    /// Removes a key-value pair in the TXT record object given its key.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object.
    ///
    ///
    /// Parameter `key`: The key corresponding to the key-value pair.
    ///
    ///
    /// Returns: A boolean indicating if the key-value pair specified by the given key
    /// was removed. Returns false if the key is invalid or not present in the
    /// TXT dictionary. A key is invalid if it is an empty string, contains
    /// non-ASCII characters, or has length greater than UINT8_MAX.
    ///
    /// # Safety
    ///
    /// `key` must be a valid pointer.
    #[doc(alias = "nw_txt_record_remove_key")]
    #[inline]
    pub unsafe fn remove_key(&self, key: NonNull<c_char>) -> bool {
        extern "C-unwind" {
            fn nw_txt_record_remove_key(txt_record: &NWTxtRecord, key: NonNull<c_char>) -> bool;
        }
        unsafe { nw_txt_record_remove_key(self, key) }
    }

    /// Count the number of keys in the TXT record object.
    ///
    ///
    /// Parameter `txt_record`: A TXT record object.
    ///
    ///
    /// Returns: The number of keys in the TXT record object.
    #[doc(alias = "nw_txt_record_get_key_count")]
    #[inline]
    pub fn key_count(&self) -> usize {
        extern "C-unwind" {
            fn nw_txt_record_get_key_count(txt_record: Option<&NWTxtRecord>) -> usize;
        }
        unsafe { nw_txt_record_get_key_count(self) }
    }
}

/// A block to access the raw TXT record inside the TXT record object. For
/// example, the user can copy the raw TXT record into another buffer in the
/// block, or read its contents.
///
///
/// Parameter `raw_txt_record`: The raw TXT record inside the TXT record object. Note that the bytes
/// pointed to by raw_txt_record is only valid within the scope of the block.
///
///
/// Parameter `len`: The length of the raw TXT record.
///
///
/// Returns: A user-defined return value. For example, the user may want to return a
/// boolean indicating if the operation succeeds.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_txt_record_access_bytes_t?language=objc)
pub type nw_txt_record_access_bytes_t = *mut block2::DynBlock<dyn Fn(NonNull<u8>, usize) -> bool>;

impl NWTxtRecord {
    /// Access the raw TXT record inside the TXT record object.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object.
    ///
    ///
    /// Parameter `access_bytes`: The block that will be used to access the raw TXT record inside the TXT
    /// record object.
    ///
    ///
    /// Returns: The return value of the access_bytes block, which is defined by the user.
    /// For example, the user may want to return a boolean indicating if the
    /// operation succeeds.
    ///
    /// # Safety
    ///
    /// `access_bytes` must be a valid pointer.
    #[doc(alias = "nw_txt_record_access_bytes")]
    #[inline]
    pub unsafe fn access_bytes(&self, access_bytes: nw_txt_record_access_bytes_t) -> bool {
        extern "C-unwind" {
            fn nw_txt_record_access_bytes(
                txt_record: &NWTxtRecord,
                access_bytes: nw_txt_record_access_bytes_t,
            ) -> bool;
        }
        unsafe { nw_txt_record_access_bytes(self, access_bytes) }
    }
}

/// A block that can be applied to every key-value pair in the TXT record
/// object.
///
///
/// Parameter `key`: The key of the current iterating key-value pair. Note that key is only
/// valid within the scope of the block.
///
///
/// Parameter `found`: An nw_txt_record_find_key_t representing the type of the key-value pair found.
/// The key may be invalid, may not exist, have no associated value, have an
/// empty associated value, or have a non-empty associated value.
///
///
/// Parameter `value`: The value of the current iterating key-value pair. Note that value is
/// only valid within the scope of the block.
///
///
/// Parameter `value_len`: The length of the value.
///
///
/// Returns: A boolean indicating whether iteration should continue.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_txt_record_applier_t?language=objc)
pub type nw_txt_record_applier_t = *mut block2::DynBlock<
    dyn Fn(NonNull<c_char>, nw_txt_record_find_key_t, NonNull<u8>, usize) -> bool,
>;

impl NWTxtRecord {
    /// Apply the block to every key-value pair in the TXT record object.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object.
    ///
    ///
    /// Parameter `applier`: The block that will be applied to the entire TXT record object.
    ///
    ///
    /// Returns: A boolean indicating whether iteration of the TXT record object
    /// completed successfully. Iteration will only fail if the applier block
    /// returns false.
    ///
    /// # Safety
    ///
    /// `applier` must be a valid pointer.
    #[doc(alias = "nw_txt_record_apply")]
    #[inline]
    pub unsafe fn apply(&self, applier: nw_txt_record_applier_t) -> bool {
        extern "C-unwind" {
            fn nw_txt_record_apply(
                txt_record: &NWTxtRecord,
                applier: nw_txt_record_applier_t,
            ) -> bool;
        }
        unsafe { nw_txt_record_apply(self, applier) }
    }

    /// Check if the two TXT record objects are equal.
    ///
    ///
    /// Parameter `left`: The first TXT record object to be compared.
    ///
    ///
    /// Parameter `right`: The second TXT record object to be compared.
    ///
    ///
    /// Returns: A boolean indicating if the two TXT record objects are equal. Two TXT
    /// record objects are equal if they contain the same set of key-value pairs,
    /// where keys are compared case-insensitively. For example, "ABC=1" and
    /// "abc=1" are identical key-value pairs. The ordering of the key-value
    /// pairs does not matter.
    #[doc(alias = "nw_txt_record_is_equal")]
    #[inline]
    pub fn is_equal(&self, right: Option<&NWTxtRecord>) -> bool {
        extern "C-unwind" {
            fn nw_txt_record_is_equal(
                left: Option<&NWTxtRecord>,
                right: Option<&NWTxtRecord>,
            ) -> bool;
        }
        unsafe { nw_txt_record_is_equal(self, right) }
    }

    /// Check whether the TXT record is a dictionary or a buffer.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object.
    ///
    ///
    /// Returns: A boolean indicating whether the TXT record is a dictionary or a buffer.
    /// If true, the TXT record is a dictionary. If false, the TXT record is a
    /// buffer.
    #[doc(alias = "nw_txt_record_is_dictionary")]
    #[inline]
    pub fn is_dictionary(&self) -> bool {
        extern "C-unwind" {
            fn nw_txt_record_is_dictionary(txt_record: &NWTxtRecord) -> bool;
        }
        unsafe { nw_txt_record_is_dictionary(self) }
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_advertise_descriptor?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_advertise_descriptor: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_advertise_descriptor_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_advertise_descriptor_t = NSObject;

impl NWAdvertiseDescriptor {
    /// Creates a new advertise descriptor object based on a Bonjour service type
    /// and optional domain. This object can be used with listener objects to
    /// specify the service the listener should advertise.
    ///
    /// If the name is unspecified, the default name for the device will be used.
    /// If the domain is unspecified, the default domains for registration will be
    /// used. If the listener is local only, the domain 'local.' will be used
    /// regardless of the parameter passed to domain.
    ///
    ///
    /// Parameter `name`: An optional Bonjour service name.
    ///
    ///
    /// Parameter `type`: A Bonjour service type.
    ///
    ///
    /// Parameter `domain`: An optional Bonjour service domain.
    ///
    ///
    /// Returns: An instantiated browse descriptor object.
    ///
    /// # Safety
    ///
    /// - `name` must be a valid pointer or null.
    /// - `type` must be a valid pointer.
    /// - `domain` must be a valid pointer or null.
    #[doc(alias = "nw_advertise_descriptor_create_bonjour_service")]
    #[inline]
    pub unsafe fn new_bonjour_service(
        name: *const c_char,
        r#type: NonNull<c_char>,
        domain: *const c_char,
    ) -> Option<NWRetained<NWAdvertiseDescriptor>> {
        extern "C-unwind" {
            fn nw_advertise_descriptor_create_bonjour_service(
                name: *const c_char,
                r#type: NonNull<c_char>,
                domain: *const c_char,
            ) -> Option<NonNull<NWAdvertiseDescriptor>>;
        }
        let ret = unsafe { nw_advertise_descriptor_create_bonjour_service(name, r#type, domain) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Set the TXT record for the advertise descriptor's service. You must call
    /// nw_listener_set_advertise_descriptor to update the listener's advertising
    /// afterwards in order for these changes to take effect.
    ///
    ///
    /// Parameter `advertise_descriptor`: The advertise descriptor to modify.
    ///
    ///
    /// Parameter `txt_record`: A pointer to the TXT record.
    ///
    ///
    /// Parameter `txt_length`: The length of the TXT record. The total size of a typical DNS-SD TXT record
    /// is intended to be small - 200 bytes or less. Using TXT records larger than
    /// 1300 bytes is not recommended at this time.
    ///
    /// # Safety
    ///
    /// `txt_record` must be a valid pointer or null.
    #[doc(alias = "nw_advertise_descriptor_set_txt_record")]
    #[inline]
    pub unsafe fn set_txt_record(&self, txt_record: *const c_void, txt_length: usize) {
        extern "C-unwind" {
            fn nw_advertise_descriptor_set_txt_record(
                advertise_descriptor: &NWAdvertiseDescriptor,
                txt_record: *const c_void,
                txt_length: usize,
            );
        }
        unsafe { nw_advertise_descriptor_set_txt_record(self, txt_record, txt_length) }
    }

    /// Disable auto-rename for the Bonjour service registration.
    /// Auto-rename is enabled by default.
    ///
    ///
    /// Parameter `advertise_descriptor`: The advertise descriptor to modify.
    ///
    ///
    /// Parameter `no_auto_rename`: A boolean indicating if auto-rename should be disabled.
    #[doc(alias = "nw_advertise_descriptor_set_no_auto_rename")]
    #[inline]
    pub fn set_no_auto_rename(&self, no_auto_rename: bool) {
        extern "C-unwind" {
            fn nw_advertise_descriptor_set_no_auto_rename(
                advertise_descriptor: &NWAdvertiseDescriptor,
                no_auto_rename: bool,
            );
        }
        unsafe { nw_advertise_descriptor_set_no_auto_rename(self, no_auto_rename) }
    }

    /// Check if auto-rename has been disabled for the Bonjour service
    /// registration.
    ///
    ///
    /// Parameter `advertise_descriptor`: The advertise descriptor object.
    ///
    ///
    /// Returns: A boolean indicating if auto-rename is disabled.
    #[doc(alias = "nw_advertise_descriptor_get_no_auto_rename")]
    #[inline]
    pub fn no_auto_rename(&self) -> bool {
        extern "C-unwind" {
            fn nw_advertise_descriptor_get_no_auto_rename(
                advertise_descriptor: &NWAdvertiseDescriptor,
            ) -> bool;
        }
        unsafe { nw_advertise_descriptor_get_no_auto_rename(self) }
    }

    /// Set the TXT record object on the advertise descriptor.
    ///
    ///
    /// Parameter `advertise_descriptor`: The advertise descriptor object.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object. If txt_record is NULL, the advertise_descriptor's
    /// current TXT record object will be removed.
    #[doc(alias = "nw_advertise_descriptor_set_txt_record_object")]
    #[inline]
    pub fn set_txt_record_object(&self, txt_record: Option<&NWTxtRecord>) {
        extern "C-unwind" {
            fn nw_advertise_descriptor_set_txt_record_object(
                advertise_descriptor: &NWAdvertiseDescriptor,
                txt_record: Option<&NWTxtRecord>,
            );
        }
        unsafe { nw_advertise_descriptor_set_txt_record_object(self, txt_record) }
    }

    /// Copies the TXT record object from the advertise descriptor.
    ///
    ///
    /// Parameter `advertise_descriptor`: The advertise descriptor object.
    ///
    ///
    /// Returns: A copy of the TXT record object, or NULL if the advertise descriptor
    /// does not have an associated TXT record.
    #[doc(alias = "nw_advertise_descriptor_copy_txt_record_object")]
    #[inline]
    pub fn txt_record_object(&self) -> Option<NWRetained<NWTxtRecord>> {
        extern "C-unwind" {
            fn nw_advertise_descriptor_copy_txt_record_object(
                advertise_descriptor: &NWAdvertiseDescriptor,
            ) -> Option<NonNull<NWTxtRecord>>;
        }
        let ret = unsafe { nw_advertise_descriptor_copy_txt_record_object(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Creates an advertise descriptor for application service discovery.
    ///
    ///
    /// Parameter `application_service_name`: The service name to advertise.
    ///
    ///
    /// Returns: An instantiated advertise descriptor object.
    ///
    /// # Safety
    ///
    /// `application_service_name` must be a valid pointer.
    #[doc(alias = "nw_advertise_descriptor_create_application_service")]
    #[inline]
    pub unsafe fn new_application_service(
        application_service_name: NonNull<c_char>,
    ) -> NWRetained<NWAdvertiseDescriptor> {
        extern "C-unwind" {
            fn nw_advertise_descriptor_create_application_service(
                application_service_name: NonNull<c_char>,
            ) -> Option<NonNull<NWAdvertiseDescriptor>>;
        }
        let ret =
            unsafe { nw_advertise_descriptor_create_application_service(application_service_name) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Returns the service name of an application service advertise descriptor.
    ///
    ///
    /// Parameter `advertise_descriptor`: An advertise descriptor object.
    ///
    ///
    /// Returns: The service name or NULL if the advertise descriptor is not of the correct type.
    #[doc(alias = "nw_advertise_descriptor_get_application_service_name")]
    #[inline]
    pub fn application_service_name(&self) -> *const c_char {
        extern "C-unwind" {
            fn nw_advertise_descriptor_get_application_service_name(
                advertise_descriptor: &NWAdvertiseDescriptor,
            ) -> *const c_char;
        }
        unsafe { nw_advertise_descriptor_get_application_service_name(self) }
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_protocol_definition?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_protocol_definition: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_protocol_definition_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_protocol_definition_t = NSObject;

impl NWProtocolDefinition {
    /// Compare two protocol definitions to check if they represent the same protocol.
    ///
    ///
    /// Parameter `definition1`: The first definition to compare
    ///
    ///
    /// Parameter `definition2`: The second definition to compare
    ///
    ///
    /// Returns: Returns true if the definitions represent the same protocol, false otherwise.
    #[doc(alias = "nw_protocol_definition_is_equal")]
    #[inline]
    pub fn is_equal(&self, definition2: &NWProtocolDefinition) -> bool {
        extern "C-unwind" {
            fn nw_protocol_definition_is_equal(
                definition1: &NWProtocolDefinition,
                definition2: &NWProtocolDefinition,
            ) -> bool;
        }
        unsafe { nw_protocol_definition_is_equal(self, definition2) }
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_protocol_options?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_protocol_options: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_protocol_options_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_protocol_options_t = NSObject;

impl NWProtocolOptions {
    /// Retrieve the protocol definition for a given options object.
    ///
    ///
    /// Parameter `options`: The protocol options to check
    ///
    ///
    /// Returns: Returns a reference-counted protocol definition object.
    #[doc(alias = "nw_protocol_options_copy_definition")]
    #[inline]
    pub fn definition(&self) -> NWRetained<NWProtocolDefinition> {
        extern "C-unwind" {
            fn nw_protocol_options_copy_definition(
                options: &NWProtocolOptions,
            ) -> Option<NonNull<NWProtocolDefinition>>;
        }
        let ret = unsafe { nw_protocol_options_copy_definition(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_protocol_metadata?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_protocol_metadata: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_protocol_metadata_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_protocol_metadata_t = NSObject;

impl NWProtocolMetadata {
    /// Retrieve the protocol definition for a given metadata object.
    ///
    ///
    /// Parameter `metadata`: The protocol metadata to check
    ///
    ///
    /// Returns: Returns a reference-counted protocol definition object.
    #[doc(alias = "nw_protocol_metadata_copy_definition")]
    #[inline]
    pub fn definition(&self) -> NWRetained<NWProtocolDefinition> {
        extern "C-unwind" {
            fn nw_protocol_metadata_copy_definition(
                metadata: &NWProtocolMetadata,
            ) -> Option<NonNull<NWProtocolDefinition>>;
        }
        let ret = unsafe { nw_protocol_metadata_copy_definition(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_interface?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_interface: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_interface_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_interface_t = NSObject;

/// Interface types represent the underlying media for a network link, such as Wi-Fi or
/// Cellular.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_interface_type_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_interface_type_t(pub c_uint);
impl nw_interface_type_t {
    #[doc(alias = "nw_interface_type_other")]
    pub const other: Self = Self(0);
    #[doc(alias = "nw_interface_type_wifi")]
    pub const wifi: Self = Self(1);
    #[doc(alias = "nw_interface_type_cellular")]
    pub const cellular: Self = Self(2);
    #[doc(alias = "nw_interface_type_wired")]
    pub const wired: Self = Self(3);
    #[doc(alias = "nw_interface_type_loopback")]
    pub const loopback: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_interface_type_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_interface_type_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWInterface {
    /// Retrieves the type of an interface. This only accesses the type of the specific
    /// interface being queried, and will not take into account types used by interfaces
    /// that traffic will eventually be routed through. That is, if the interface is a virtual
    /// interface (such as a VPN) that eventually forwards traffic through Wi-Fi, the type
    /// will be nw_interface_type_other, not nw_interface_type_wifi.
    ///
    ///
    /// Parameter `interface`: The interface object to check.
    ///
    ///
    /// Returns: Returns the type of the interface.
    #[doc(alias = "nw_interface_get_type")]
    #[inline]
    pub fn r#type(&self) -> nw_interface_type_t {
        extern "C-unwind" {
            fn nw_interface_get_type(interface: &NWInterface) -> nw_interface_type_t;
        }
        unsafe { nw_interface_get_type(self) }
    }
}

/// Interface radio types represent the radio technology for a network link.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_interface_radio_type_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_interface_radio_type_t(pub c_uint);
impl nw_interface_radio_type_t {
    #[doc(alias = "nw_interface_radio_type_unknown")]
    pub const unknown: Self = Self(0);
    #[doc(alias = "nw_interface_radio_type_wifi_b")]
    pub const wifi_b: Self = Self(1);
    #[doc(alias = "nw_interface_radio_type_wifi_a")]
    pub const wifi_a: Self = Self(2);
    #[doc(alias = "nw_interface_radio_type_wifi_g")]
    pub const wifi_g: Self = Self(3);
    #[doc(alias = "nw_interface_radio_type_wifi_n")]
    pub const wifi_n: Self = Self(4);
    #[doc(alias = "nw_interface_radio_type_wifi_ac")]
    pub const wifi_ac: Self = Self(5);
    #[doc(alias = "nw_interface_radio_type_wifi_ax")]
    pub const wifi_ax: Self = Self(6);
    #[doc(alias = "nw_interface_radio_type_cell_lte")]
    pub const cell_lte: Self = Self(0x80);
    #[doc(alias = "nw_interface_radio_type_cell_endc_sub6")]
    pub const cell_endc_sub6: Self = Self(0x81);
    #[doc(alias = "nw_interface_radio_type_cell_endc_mmw")]
    pub const cell_endc_mmw: Self = Self(0x82);
    #[doc(alias = "nw_interface_radio_type_cell_nr_sa_sub6")]
    pub const cell_nr_sa_sub6: Self = Self(0x83);
    #[doc(alias = "nw_interface_radio_type_cell_nr_sa_mmw")]
    pub const cell_nr_sa_mmw: Self = Self(0x84);
    #[doc(alias = "nw_interface_radio_type_cell_wcdma")]
    pub const cell_wcdma: Self = Self(0x85);
    #[doc(alias = "nw_interface_radio_type_cell_gsm")]
    pub const cell_gsm: Self = Self(0x86);
    #[doc(alias = "nw_interface_radio_type_cell_cdma")]
    pub const cell_cdma: Self = Self(0x87);
    #[doc(alias = "nw_interface_radio_type_cell_evdo")]
    pub const cell_evdo: Self = Self(0x88);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_interface_radio_type_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_interface_radio_type_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWInterface {
    /// Retrieves the name of an interface, to be used for reference or logging
    /// purposes.
    ///
    ///
    /// Parameter `interface`: The interface object to check.
    ///
    ///
    /// Returns: Returns the name of the interface as a NULL-terminated C string,
    /// or NULL if the interface is NULL.
    #[doc(alias = "nw_interface_get_name")]
    #[inline]
    pub fn name(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_interface_get_name(interface: &NWInterface) -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_interface_get_name(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Retrieves the index of an interface, to be used for reference or logging
    /// purposes. This is the same value as provided by if_nametoindex.
    ///
    ///
    /// Parameter `interface`: The interface object to check.
    ///
    ///
    /// Returns: Returns the index of the interface, or 0 if the interface is NULL.
    #[doc(alias = "nw_interface_get_index")]
    #[inline]
    pub fn index(&self) -> u32 {
        extern "C-unwind" {
            fn nw_interface_get_index(interface: &NWInterface) -> u32;
        }
        unsafe { nw_interface_get_index(self) }
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_endpoint?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_endpoint: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_endpoint_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_endpoint_t = NSObject;

/// Endpoint types represent a well-known form of endpoint. Values may be
/// added to this enumeration, and some custom endpoint types may use
/// values not defined in this enumeration.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_endpoint_type_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_endpoint_type_t(pub c_uint);
impl nw_endpoint_type_t {
    #[doc(alias = "nw_endpoint_type_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_endpoint_type_address")]
    pub const address: Self = Self(1);
    #[doc(alias = "nw_endpoint_type_host")]
    pub const host: Self = Self(2);
    #[doc(alias = "nw_endpoint_type_bonjour_service")]
    pub const bonjour_service: Self = Self(3);
    #[doc(alias = "nw_endpoint_type_url")]
    pub const url: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_endpoint_type_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_endpoint_type_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWEndpoint {
    /// Retrieves the type of a network endpoint.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object for which to get the type.
    ///
    ///
    /// Returns: Returns the type of the network endpoint.
    #[doc(alias = "nw_endpoint_get_type")]
    #[inline]
    pub fn r#type(&self) -> nw_endpoint_type_t {
        extern "C-unwind" {
            fn nw_endpoint_get_type(endpoint: &NWEndpoint) -> nw_endpoint_type_t;
        }
        unsafe { nw_endpoint_get_type(self) }
    }

    /// Creates a network endpoint with a hostname and port. The hostname
    /// may be a string-encoding of an IP address, in which case the
    /// the endpoint will be treated as an endpoint with the type
    /// nw_endpoint_type_address. Otherwise, the endpoint will have the
    /// type nw_endpoint_type_host.
    ///
    ///
    /// Parameter `hostname`: A hostname, such as "www.example.com", or "2607:ffff::1234:abcd".
    ///
    ///
    /// Parameter `port`: A port number as a C string, such as "443", or a service
    /// name, such as "https".
    ///
    ///
    /// Returns: Returns an allocated nw_endpoint_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    ///
    /// # Safety
    ///
    /// - `hostname` must be a valid pointer.
    /// - `port` must be a valid pointer.
    #[doc(alias = "nw_endpoint_create_host")]
    #[inline]
    pub unsafe fn new_host(
        hostname: NonNull<c_char>,
        port: NonNull<c_char>,
    ) -> NWRetained<NWEndpoint> {
        extern "C-unwind" {
            fn nw_endpoint_create_host(
                hostname: NonNull<c_char>,
                port: NonNull<c_char>,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_endpoint_create_host(hostname, port) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Retrieves the hostname string for a network endpoint with
    /// the type nw_endpoint_type_host, nw_endpoint_type_address,
    /// or nw_endpoint_type_url.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object.
    ///
    ///
    /// Returns: Returns the hostname string for the endpoint, or NULL
    /// if the endpoint is not of type nw_endpoint_type_host,
    /// nw_endpoint_type_address, or nw_endpoint_type_url.
    #[doc(alias = "nw_endpoint_get_hostname")]
    #[inline]
    pub fn hostname(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_endpoint_get_hostname(endpoint: &NWEndpoint) -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_endpoint_get_hostname(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Returns an allocated port string for a network endpoint with
    /// the type nw_endpoint_type_host or nw_endpoint_type_address.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object.
    ///
    ///
    /// Returns: Returns the port string for the endpoint, or NULL
    /// if the endpoint is not of type nw_endpoint_type_host or
    /// nw_endpoint_type_address. This string must be freed with free().
    #[doc(alias = "nw_endpoint_copy_port_string")]
    #[inline]
    pub fn port_string(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_endpoint_copy_port_string(endpoint: &NWEndpoint) -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_endpoint_copy_port_string(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Retrieves the port for a network endpoint with the type
    /// nw_endpoint_type_url, nw_endpoint_type_host, or nw_endpoint_type_address.
    /// The port will be returned in Host Byte Order.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object.
    ///
    ///
    /// Returns: Returns the port for the endpoint, or 0 if the endpoint is not
    /// of type nw_endpoint_type_host or nw_endpoint_type_address.
    /// The port will be returned in Host Byte Order.
    #[doc(alias = "nw_endpoint_get_port")]
    #[inline]
    pub fn port(&self) -> u16 {
        extern "C-unwind" {
            fn nw_endpoint_get_port(endpoint: &NWEndpoint) -> u16;
        }
        unsafe { nw_endpoint_get_port(self) }
    }

    /// Creates a network endpoint with a sockaddr struct. The endpoint
    /// will have the type nw_endpoint_type_address.
    ///
    ///
    /// Parameter `address`: An address stored as a sockaddr.
    ///
    ///
    /// Returns: Returns an allocated nw_endpoint_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    ///
    /// # Safety
    ///
    /// `address` must be a valid pointer.
    #[doc(alias = "nw_endpoint_create_address")]
    #[cfg(feature = "libc")]
    #[inline]
    pub unsafe fn new_address(address: NonNull<libc::sockaddr>) -> NWRetained<NWEndpoint> {
        extern "C-unwind" {
            fn nw_endpoint_create_address(
                address: NonNull<libc::sockaddr>,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_endpoint_create_address(address) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Returns an allocated IP address string for a network endpoint with
    /// the type nw_endpoint_type_address.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object.
    ///
    ///
    /// Returns: Returns the IP address string for the endpoint, or NULL
    /// if the endpoint is not of type nw_endpoint_type_address.
    /// This string must be freed with free().
    #[doc(alias = "nw_endpoint_copy_address_string")]
    #[inline]
    pub fn address_string(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_endpoint_copy_address_string(endpoint: &NWEndpoint) -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_endpoint_copy_address_string(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Retrieves the sockaddr struct for a network endpoint with
    /// the type nw_endpoint_type_address.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object.
    ///
    ///
    /// Returns: Returns the sockaddr struct for the endpoint, or NULL
    /// if the endpoint is not of type nw_endpoint_type_address.
    #[doc(alias = "nw_endpoint_get_address")]
    #[cfg(feature = "libc")]
    #[inline]
    pub fn address(&self) -> NonNull<libc::sockaddr> {
        extern "C-unwind" {
            fn nw_endpoint_get_address(endpoint: &NWEndpoint) -> Option<NonNull<libc::sockaddr>>;
        }
        let ret = unsafe { nw_endpoint_get_address(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Creates a network endpoint for a Bonjour Service name, type, and
    /// domain. The endpoint will have the type nw_endpoint_type_bonjour_service.
    ///
    ///
    /// Parameter `name`: The Bonjour Service name, such as "example".
    ///
    ///
    /// Parameter `type`: The Bonjour Service type, such as "_http._tcp".
    ///
    ///
    /// Parameter `domain`: The Bonjour Service domain, such as "local".
    ///
    ///
    /// Returns: Returns an allocated nw_endpoint_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    ///
    /// # Safety
    ///
    /// - `name` must be a valid pointer.
    /// - `type` must be a valid pointer.
    /// - `domain` must be a valid pointer.
    #[doc(alias = "nw_endpoint_create_bonjour_service")]
    #[inline]
    pub unsafe fn new_bonjour_service(
        name: NonNull<c_char>,
        r#type: NonNull<c_char>,
        domain: NonNull<c_char>,
    ) -> NWRetained<NWEndpoint> {
        extern "C-unwind" {
            fn nw_endpoint_create_bonjour_service(
                name: NonNull<c_char>,
                r#type: NonNull<c_char>,
                domain: NonNull<c_char>,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_endpoint_create_bonjour_service(name, r#type, domain) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Retrieves the Bonjour Service name string for a network
    /// endpoint with the type nw_endpoint_type_bonjour_service.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object.
    ///
    ///
    /// Returns: Returns the Bonjour Service name string for the endpoint, or NULL
    /// if the endpoint is not of type nw_endpoint_type_bonjour_service.
    #[doc(alias = "nw_endpoint_get_bonjour_service_name")]
    #[inline]
    pub fn bonjour_service_name(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_endpoint_get_bonjour_service_name(
                endpoint: &NWEndpoint,
            ) -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_endpoint_get_bonjour_service_name(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Retrieves the Bonjour Service type string for a network
    /// endpoint with the type nw_endpoint_type_bonjour_service.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object.
    ///
    ///
    /// Returns: Returns the Bonjour Service type string for the endpoint, or NULL
    /// if the endpoint is not of type nw_endpoint_type_bonjour_service.
    #[doc(alias = "nw_endpoint_get_bonjour_service_type")]
    #[inline]
    pub fn bonjour_service_type(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_endpoint_get_bonjour_service_type(
                endpoint: &NWEndpoint,
            ) -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_endpoint_get_bonjour_service_type(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Retrieves the Bonjour Service domain string for a network
    /// endpoint with the type nw_endpoint_type_bonjour_service.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object.
    ///
    ///
    /// Returns: Returns the Bonjour Service domain string for the endpoint, or NULL
    /// if the endpoint is not of type nw_endpoint_type_bonjour_service.
    #[doc(alias = "nw_endpoint_get_bonjour_service_domain")]
    #[inline]
    pub fn bonjour_service_domain(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_endpoint_get_bonjour_service_domain(
                endpoint: &NWEndpoint,
            ) -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_endpoint_get_bonjour_service_domain(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Creates a network endpoint with a URL. The endpoint will have the type
    /// nw_endpoint_type_url.
    ///
    ///
    /// Parameter `url`: The URL string.
    ///
    ///
    /// Returns: Returns an allocated nw_endpoint_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters, or due to URL parsing failure.
    ///
    /// # Safety
    ///
    /// `url` must be a valid pointer.
    #[doc(alias = "nw_endpoint_create_url")]
    #[inline]
    pub unsafe fn new_url(url: NonNull<c_char>) -> NWRetained<NWEndpoint> {
        extern "C-unwind" {
            fn nw_endpoint_create_url(url: NonNull<c_char>) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_endpoint_create_url(url) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Retrieves the URL string from a network endpoint of type
    /// nw_endpoint_type_url.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object.
    ///
    ///
    /// Returns: The URL string, or NULL if the endpoint is not of type
    /// nw_endpoint_type_url.
    #[doc(alias = "nw_endpoint_get_url")]
    #[inline]
    pub fn url(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_endpoint_get_url(endpoint: &NWEndpoint) -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_endpoint_get_url(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Retrieves the TXT record associated with the endpoint, if present.
    /// TXT records can be populated during browsing and connection
    /// establishment.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object.
    ///
    ///
    /// Returns: Returns a retained nw_txt_record_t object if a TXT record
    /// is associated with this endpoint, or NULL otherwise.
    #[doc(alias = "nw_endpoint_copy_txt_record")]
    #[inline]
    pub fn txt_record(&self) -> Option<NWRetained<NWTxtRecord>> {
        extern "C-unwind" {
            fn nw_endpoint_copy_txt_record(endpoint: &NWEndpoint) -> Option<NonNull<NWTxtRecord>>;
        }
        let ret = unsafe { nw_endpoint_copy_txt_record(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Retrieves a signed data blob associated with an endpoint.
    ///
    ///
    /// Parameter `endpoint`: The endpoint to modify.
    ///
    ///
    /// Parameter `out_signature_length`: A pointer to a size_t that will take the length of the signature.
    ///
    ///
    /// Returns: Returns a pointer to a buffer of bytes containing a signature,
    /// or NULL if the endpoint is not signed.
    ///
    /// # Safety
    ///
    /// `out_signature_length` must be a valid pointer.
    #[doc(alias = "nw_endpoint_get_signature")]
    #[inline]
    pub unsafe fn signature(&self, out_signature_length: NonNull<usize>) -> *const u8 {
        extern "C-unwind" {
            fn nw_endpoint_get_signature(
                endpoint: &NWEndpoint,
                out_signature_length: NonNull<usize>,
            ) -> *const u8;
        }
        unsafe { nw_endpoint_get_signature(self, out_signature_length) }
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_resolver_config?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_resolver_config: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_resolver_config_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_resolver_config_t = NSObject;

impl NWResolverConfig {
    /// Creates a DNS-over-HTTPS (DoH) resolver configuration. The provided
    /// URL describes the location of the DNS server, such as
    /// "https://dnsserver.example.net/dns-query". See RFC 8484.
    ///
    ///
    /// Parameter `url_endpoint`: The URL template of the DoH server as an endpoint.
    ///
    ///
    /// Returns: Returns an allocated nw_resolver_config_t object on success.
    #[doc(alias = "nw_resolver_config_create_https")]
    #[inline]
    pub fn new_https(url_endpoint: &NWEndpoint) -> NWRetained<NWResolverConfig> {
        extern "C-unwind" {
            fn nw_resolver_config_create_https(
                url_endpoint: &NWEndpoint,
            ) -> Option<NonNull<NWResolverConfig>>;
        }
        let ret = unsafe { nw_resolver_config_create_https(url_endpoint) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a DNS-over-TLS (DoT) resolver configuration. The hostname
    /// of the provided endpoint will be used to validate the TLS certificate of the server.
    /// See RFC 7858.
    ///
    ///
    /// Parameter `server_endpoint`: A host endpoint identifying the DoT server.
    ///
    ///
    /// Returns: Returns an allocated nw_resolver_config_t object on success.
    #[doc(alias = "nw_resolver_config_create_tls")]
    #[inline]
    pub fn new_tls(server_endpoint: &NWEndpoint) -> NWRetained<NWResolverConfig> {
        extern "C-unwind" {
            fn nw_resolver_config_create_tls(
                server_endpoint: &NWEndpoint,
            ) -> Option<NonNull<NWResolverConfig>>;
        }
        let ret = unsafe { nw_resolver_config_create_tls(server_endpoint) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Modifies the resolver configuration by adding a DNS server address as an endpoint.
    ///
    ///
    /// Parameter `config`: A resolver config object.
    ///
    ///
    /// Parameter `server_address`: A server address to assign to the configuration, as an endpoint.
    #[doc(alias = "nw_resolver_config_add_server_address")]
    #[inline]
    pub fn add_server_address(&self, server_address: &NWEndpoint) {
        extern "C-unwind" {
            fn nw_resolver_config_add_server_address(
                config: &NWResolverConfig,
                server_address: &NWEndpoint,
            );
        }
        unsafe { nw_resolver_config_add_server_address(self, server_address) }
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_proxy_config?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_proxy_config: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_proxy_config_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_proxy_config_t = NSObject;

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_relay_hop?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_relay_hop: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_relay_hop_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_relay_hop_t = NSObject;

impl NWRelayHop {
    /// Creates a configuration for a secure relay. A relay is a proxy that is accessible using
    /// HTTP/3, HTTP/2, or both, and uses the CONNECT method to proxy TCP or UDP
    /// connections. At least one of `http3_relay_endpoint` and
    /// `http2_relay_endpoint` must be non-null.
    ///
    ///
    /// Parameter `http3_relay_endpoint`: A URL or host endpoint identifying the relay server accessible using HTTP/3.
    ///
    ///
    /// Parameter `http2_relay_endpoint`: A URL or host endpoint identifying the relay server accessible using HTTP/2.
    ///
    ///
    /// Parameter `relay_tls_options`: Optional TLS options to use for the TLS handshake to the relay. If this is null, default
    /// TLS options will be used.
    ///
    ///
    /// Returns: Returns an allocated `nw_relay_hop_t` object on success.
    #[doc(alias = "nw_relay_hop_create")]
    #[inline]
    pub fn new(
        http3_relay_endpoint: Option<&NWEndpoint>,
        http2_relay_endpoint: Option<&NWEndpoint>,
        relay_tls_options: Option<&NWProtocolOptions>,
    ) -> NWRetained<NWRelayHop> {
        extern "C-unwind" {
            fn nw_relay_hop_create(
                http3_relay_endpoint: Option<&NWEndpoint>,
                http2_relay_endpoint: Option<&NWEndpoint>,
                relay_tls_options: Option<&NWProtocolOptions>,
            ) -> Option<NonNull<NWRelayHop>>;
        }
        let ret = unsafe {
            nw_relay_hop_create(
                http3_relay_endpoint,
                http2_relay_endpoint,
                relay_tls_options,
            )
        };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Adds additional HTTP headers to send as part of CONNECT requests to the
    /// relay.
    ///
    ///
    /// Parameter `relay_hop`: The proxy hop object.
    ///
    ///
    /// Parameter `field_name`: The HTTP header field name.
    ///
    ///
    /// Parameter `field_value`: The HTTP header field value.
    ///
    /// # Safety
    ///
    /// - `field_name` must be a valid pointer.
    /// - `field_value` must be a valid pointer.
    #[doc(alias = "nw_relay_hop_add_additional_http_header_field")]
    #[inline]
    pub unsafe fn add_additional_http_header_field(
        &self,
        field_name: NonNull<c_char>,
        field_value: NonNull<c_char>,
    ) {
        extern "C-unwind" {
            fn nw_relay_hop_add_additional_http_header_field(
                relay_hop: &NWRelayHop,
                field_name: NonNull<c_char>,
                field_value: NonNull<c_char>,
            );
        }
        unsafe { nw_relay_hop_add_additional_http_header_field(self, field_name, field_value) }
    }
}

impl NWProxyConfig {
    /// Creates a proxy configuration with one or two secure relay hops.
    ///
    ///
    /// Parameter `first_hop`: The first or only relay hop.
    ///
    ///
    /// Parameter `second_hop`: An optional second relay hop.
    ///
    ///
    /// Returns: Returns an allocated `nw_proxy_config_t` object on success.
    #[doc(alias = "nw_proxy_config_create_relay")]
    #[inline]
    pub fn new_relay(
        first_hop: &NWRelayHop,
        second_hop: Option<&NWRelayHop>,
    ) -> NWRetained<NWProxyConfig> {
        extern "C-unwind" {
            fn nw_proxy_config_create_relay(
                first_hop: &NWRelayHop,
                second_hop: Option<&NWRelayHop>,
            ) -> Option<NonNull<NWProxyConfig>>;
        }
        let ret = unsafe { nw_proxy_config_create_relay(first_hop, second_hop) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a proxy configuration for an Oblivious HTTP relay and gateway. Note that
    /// Oblivious HTTP proxy configurations must also have specific match domains specified
    /// using `nw_proxy_config_add_match_domain`.
    ///
    ///
    /// Parameter `relay`: The Oblivious HTTP relay hop.
    ///
    ///
    /// Parameter `relay_resource_path`: The HTTP path to use for requests to the Oblivious HTTP relay that will forward requests to the gateway.
    ///
    ///
    /// Parameter `gateway_key_config`: The key configuration for the Oblivious HTTP gateway, or a list of key configurations where each configuration
    /// is prefixed with a two-byte length in network byte order.
    ///
    ///
    /// Parameter `gateway_key_config_length`: The length of the buffer in `gateway_key_config`.
    ///
    ///
    /// Returns: Returns an allocated `nw_proxy_config_t` object on success.
    ///
    /// # Safety
    ///
    /// - `relay_resource_path` must be a valid pointer.
    /// - `gateway_key_config` must be a valid pointer.
    #[doc(alias = "nw_proxy_config_create_oblivious_http")]
    #[inline]
    pub unsafe fn new_oblivious_http(
        relay: &NWRelayHop,
        relay_resource_path: NonNull<c_char>,
        gateway_key_config: NonNull<u8>,
        gateway_key_config_length: usize,
    ) -> NWRetained<NWProxyConfig> {
        extern "C-unwind" {
            fn nw_proxy_config_create_oblivious_http(
                relay: &NWRelayHop,
                relay_resource_path: NonNull<c_char>,
                gateway_key_config: NonNull<u8>,
                gateway_key_config_length: usize,
            ) -> Option<NonNull<NWProxyConfig>>;
        }
        let ret = unsafe {
            nw_proxy_config_create_oblivious_http(
                relay,
                relay_resource_path,
                gateway_key_config,
                gateway_key_config_length,
            )
        };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a legacy HTTP CONNECT proxy configuration for a proxy server accessible
    /// using HTTP/1.1. This proxy will only relay TCP connections.
    ///
    ///
    /// Parameter `proxy_endpoint`: A host endpoint identifying the proxy server accessible using HTTP/1.1.
    ///
    ///
    /// Parameter `proxy_tls_options`: Optional TLS options to use for a TLS handshake to the relay. If no options are provided,
    /// the proxy will be accessed using cleartext HTTP.
    ///
    ///
    /// Returns: Returns an allocated `nw_proxy_config_t` object on success.
    #[doc(alias = "nw_proxy_config_create_http_connect")]
    #[inline]
    pub fn new_http_connect(
        proxy_endpoint: &NWEndpoint,
        proxy_tls_options: Option<&NWProtocolOptions>,
    ) -> NWRetained<NWProxyConfig> {
        extern "C-unwind" {
            fn nw_proxy_config_create_http_connect(
                proxy_endpoint: &NWEndpoint,
                proxy_tls_options: Option<&NWProtocolOptions>,
            ) -> Option<NonNull<NWProxyConfig>>;
        }
        let ret = unsafe { nw_proxy_config_create_http_connect(proxy_endpoint, proxy_tls_options) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a SOCKSv5 proxy configuration.
    ///
    ///
    /// Parameter `proxy_endpoint`: A host endpoint identifying the SOCKS proxy server.
    ///
    ///
    /// Returns: Returns an allocated `nw_proxy_config_t` object on success.
    #[doc(alias = "nw_proxy_config_create_socksv5")]
    #[inline]
    pub fn new_socksv5(proxy_endpoint: &NWEndpoint) -> NWRetained<NWProxyConfig> {
        extern "C-unwind" {
            fn nw_proxy_config_create_socksv5(
                proxy_endpoint: &NWEndpoint,
            ) -> Option<NonNull<NWProxyConfig>>;
        }
        let ret = unsafe { nw_proxy_config_create_socksv5(proxy_endpoint) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Configures a username and password to use with a proxy configuration.
    ///
    ///
    /// Parameter `proxy_config`: The proxy configuration object.
    ///
    ///
    /// Parameter `username`: A proxy authentication username.
    ///
    ///
    /// Parameter `password`: A proxy authentication password.
    ///
    /// # Safety
    ///
    /// - `username` must be a valid pointer.
    /// - `password` must be a valid pointer or null.
    #[doc(alias = "nw_proxy_config_set_username_and_password")]
    #[inline]
    pub unsafe fn set_username_and_password(
        &self,
        username: NonNull<c_char>,
        password: *const c_char,
    ) {
        extern "C-unwind" {
            fn nw_proxy_config_set_username_and_password(
                proxy_config: &NWProxyConfig,
                username: NonNull<c_char>,
                password: *const c_char,
            );
        }
        unsafe { nw_proxy_config_set_username_and_password(self, username, password) }
    }

    /// Set whether or not a proxy configuration allows failover to non-proxied connections.
    /// Failover is not allowed by default.
    ///
    ///
    /// Parameter `proxy_config`: The proxy configuration object.
    ///
    ///
    /// Parameter `failover_allowed`: A Boolean indicating if failover is allowed.
    #[doc(alias = "nw_proxy_config_set_failover_allowed")]
    #[inline]
    pub fn set_failover_allowed(&self, failover_allowed: bool) {
        extern "C-unwind" {
            fn nw_proxy_config_set_failover_allowed(
                proxy_config: &NWProxyConfig,
                failover_allowed: bool,
            );
        }
        unsafe { nw_proxy_config_set_failover_allowed(self, failover_allowed) }
    }

    /// Check whether or not a proxy configuration allows failover to non-proxied connections.
    ///
    ///
    /// Parameter `proxy_config`: The proxy configuration object.
    ///
    ///
    /// Returns: A Boolean indicating if failover is allowed.
    #[doc(alias = "nw_proxy_config_get_failover_allowed")]
    #[inline]
    pub fn failover_allowed(&self) -> bool {
        extern "C-unwind" {
            fn nw_proxy_config_get_failover_allowed(proxy_config: &NWProxyConfig) -> bool;
        }
        unsafe { nw_proxy_config_get_failover_allowed(self) }
    }

    /// Adds a domain to define which hosts should use the proxy.
    ///
    ///
    /// Parameter `config`: The proxy configuration object.
    ///
    ///
    /// Parameter `match_domain`: The domain suffix to match hostnames against, as a string.
    ///
    /// # Safety
    ///
    /// `match_domain` must be a valid pointer.
    #[doc(alias = "nw_proxy_config_add_match_domain")]
    #[inline]
    pub unsafe fn add_match_domain(&self, match_domain: NonNull<c_char>) {
        extern "C-unwind" {
            fn nw_proxy_config_add_match_domain(
                config: &NWProxyConfig,
                match_domain: NonNull<c_char>,
            );
        }
        unsafe { nw_proxy_config_add_match_domain(self, match_domain) }
    }

    /// Clears all match domains defined for the proxy.
    ///
    ///
    /// Parameter `config`: The proxy configuration object.
    #[doc(alias = "nw_proxy_config_clear_match_domains")]
    #[inline]
    pub fn clear_match_domains(&self) {
        extern "C-unwind" {
            fn nw_proxy_config_clear_match_domains(config: &NWProxyConfig);
        }
        unsafe { nw_proxy_config_clear_match_domains(self) }
    }

    /// Adds a domain to define which hosts should not use the proxy.
    ///
    ///
    /// Parameter `config`: The proxy configuration object.
    ///
    ///
    /// Parameter `excluded_domain`: The domain suffix to match hostnames against, as a string.
    ///
    /// # Safety
    ///
    /// `excluded_domain` must be a valid pointer.
    #[doc(alias = "nw_proxy_config_add_excluded_domain")]
    #[inline]
    pub unsafe fn add_excluded_domain(&self, excluded_domain: NonNull<c_char>) {
        extern "C-unwind" {
            fn nw_proxy_config_add_excluded_domain(
                config: &NWProxyConfig,
                excluded_domain: NonNull<c_char>,
            );
        }
        unsafe { nw_proxy_config_add_excluded_domain(self, excluded_domain) }
    }

    /// Clears all excluded domains defined for the proxy.
    ///
    ///
    /// Parameter `config`: The proxy configuration object.
    #[doc(alias = "nw_proxy_config_clear_excluded_domains")]
    #[inline]
    pub fn clear_excluded_domains(&self) {
        extern "C-unwind" {
            fn nw_proxy_config_clear_excluded_domains(config: &NWProxyConfig);
        }
        unsafe { nw_proxy_config_clear_excluded_domains(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_proxy_domain_enumerator_t?language=objc)
pub type nw_proxy_domain_enumerator_t = *mut block2::DynBlock<dyn Fn(NonNull<c_char>)>;

impl NWProxyConfig {
    /// Enumerate all match domains set on the proxy configuration.
    ///
    ///
    /// Parameter `config`: The proxy configuration object.
    ///
    ///
    /// Parameter `enumerator`: A block that will get invoked for every domain that was added to the proxy configuration.
    ///
    /// # Safety
    ///
    /// `enumerator` must be a valid pointer.
    #[doc(alias = "nw_proxy_config_enumerate_match_domains")]
    #[inline]
    pub unsafe fn enumerate_match_domains(&self, enumerator: nw_proxy_domain_enumerator_t) {
        extern "C-unwind" {
            fn nw_proxy_config_enumerate_match_domains(
                config: &NWProxyConfig,
                enumerator: nw_proxy_domain_enumerator_t,
            );
        }
        unsafe { nw_proxy_config_enumerate_match_domains(self, enumerator) }
    }

    /// Enumerate all excluded domains set on the proxy configuration.
    ///
    ///
    /// Parameter `config`: The proxy configuration object.
    ///
    ///
    /// Parameter `enumerator`: A block that will get invoked for every domain that was added to the proxy configuration.
    ///
    /// # Safety
    ///
    /// `enumerator` must be a valid pointer.
    #[doc(alias = "nw_proxy_config_enumerate_excluded_domains")]
    #[inline]
    pub unsafe fn enumerate_excluded_domains(&self, enumerator: nw_proxy_domain_enumerator_t) {
        extern "C-unwind" {
            fn nw_proxy_config_enumerate_excluded_domains(
                config: &NWProxyConfig,
                enumerator: nw_proxy_domain_enumerator_t,
            );
        }
        unsafe { nw_proxy_config_enumerate_excluded_domains(self, enumerator) }
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_privacy_context?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_privacy_context: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_privacy_context_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_privacy_context_t = NSObject;

impl NWPrivacyContext {
    /// Create a new privacy context. This object can be added to connections and listeners
    /// by setting the privacy context on the nw_parameters_t. Each privacy context can have
    /// unique settings for logging and resolution, and implicitly has an isolated cache for
    /// items like TLS sessions.
    ///
    ///
    /// Parameter `description`: A string description used for logging.
    ///
    ///
    /// Returns: Returns an allocated nw_privacy_context_t object on success.
    ///
    /// # Safety
    ///
    /// `description` must be a valid pointer.
    #[doc(alias = "nw_privacy_context_create")]
    #[inline]
    pub unsafe fn new(description: NonNull<c_char>) -> NWRetained<NWPrivacyContext> {
        extern "C-unwind" {
            fn nw_privacy_context_create(
                description: NonNull<c_char>,
            ) -> Option<NonNull<NWPrivacyContext>>;
        }
        let ret = unsafe { nw_privacy_context_create(description) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/network/_nw_privacy_context_default_context?language=objc)
    pub static _nw_privacy_context_default_context: &'static NWPrivacyContext;
}

impl NWPrivacyContext {
    /// Flush any cached state stored in this privacy context. The act of flushing the
    /// cache may be asynchronous, which means that it will take effect shortly after the
    /// function is invoked.
    ///
    ///
    /// Parameter `privacy_context`: A privacy context to flush.
    #[doc(alias = "nw_privacy_context_flush_cache")]
    #[inline]
    pub fn flush_cache(&self) {
        extern "C-unwind" {
            fn nw_privacy_context_flush_cache(privacy_context: &NWPrivacyContext);
        }
        unsafe { nw_privacy_context_flush_cache(self) }
    }

    /// Disable logging for connections and listeners associated with this context. Logging
    /// may not be disabled on the default privacy context.
    ///
    ///
    /// Parameter `privacy_context`: A privacy context on which to disable logging.
    #[doc(alias = "nw_privacy_context_disable_logging")]
    #[inline]
    pub fn disable_logging(&self) {
        extern "C-unwind" {
            fn nw_privacy_context_disable_logging(privacy_context: &NWPrivacyContext);
        }
        unsafe { nw_privacy_context_disable_logging(self) }
    }

    /// Require that any DNS name resolution occurring for connections
    /// associated with this context use encrypted transports, such as TLS or HTTPS.
    /// Any unencrypted queries will be blocked if require_encrypted_name_resolution
    /// is set to true. Optionally, a fallback resolver config can be provided to use
    /// instead of blocking queries when require_encrypted_name_resolution is set to
    /// true.
    ///
    ///
    /// Parameter `privacy_context`: A privacy context to modify. This can include the default privacy context.
    ///
    ///
    /// Parameter `require_encrypted_name_resolution`: If true, require that any name resolution using DNS is performed
    /// with encryption. If false, allow cleartext resolution. Defaults to false.
    ///
    ///
    /// Parameter `fallback_resolver_config`: An optional resolver configuration to use if no other encrypted DNS resolver
    /// is already configured for the query. This will only take effect if
    /// require_encrypted_name_resolution is set to true. If this configuration is
    /// NULL and require_encrypted_name_resolution is set to true, all cleartext
    /// name resolution will be blocked.
    #[doc(alias = "nw_privacy_context_require_encrypted_name_resolution")]
    #[inline]
    pub fn require_encrypted_name_resolution(
        &self,
        require_encrypted_name_resolution: bool,
        fallback_resolver_config: Option<&NWResolverConfig>,
    ) {
        extern "C-unwind" {
            fn nw_privacy_context_require_encrypted_name_resolution(
                privacy_context: &NWPrivacyContext,
                require_encrypted_name_resolution: bool,
                fallback_resolver_config: Option<&NWResolverConfig>,
            );
        }
        unsafe {
            nw_privacy_context_require_encrypted_name_resolution(
                self,
                require_encrypted_name_resolution,
                fallback_resolver_config,
            )
        }
    }

    /// Add a proxy configuration to apply to all connections that participate in this
    /// context. If set on `NW_DEFAULT_PRIVACY_CONTEXT`, this will additionally
    /// apply to other networking APIs used by the calling process.
    ///
    ///
    /// Parameter `privacy_context`: A privacy context to modify. This can include the default privacy context.
    ///
    ///
    /// Parameter `proxy_config`: A proxy configuration object to apply to all connections that use this context.
    #[doc(alias = "nw_privacy_context_add_proxy")]
    #[inline]
    pub fn add_proxy(&self, proxy_config: &NWProxyConfig) {
        extern "C-unwind" {
            fn nw_privacy_context_add_proxy(
                privacy_context: &NWPrivacyContext,
                proxy_config: &NWProxyConfig,
            );
        }
        unsafe { nw_privacy_context_add_proxy(self, proxy_config) }
    }

    /// Clear out any proxies added using `nw_privacy_context_add_proxy`.
    ///
    ///
    /// Parameter `privacy_context`: A privacy context to modify. This can include the default privacy context.
    #[doc(alias = "nw_privacy_context_clear_proxies")]
    #[inline]
    pub fn clear_proxies(&self) {
        extern "C-unwind" {
            fn nw_privacy_context_clear_proxies(privacy_context: &NWPrivacyContext);
        }
        unsafe { nw_privacy_context_clear_proxies(self) }
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_parameters?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_parameters: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_parameters_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_parameters_t = NSObject;

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_protocol_stack?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_protocol_stack: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_protocol_stack_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_protocol_stack_t = NSObject;

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_parameters_configure_protocol_block_t?language=objc)
pub type nw_parameters_configure_protocol_block_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWProtocolOptions>)>;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/network/_nw_parameters_configure_protocol_default_configuration?language=objc)
    pub static _nw_parameters_configure_protocol_default_configuration:
        nw_parameters_configure_protocol_block_t;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/network/_nw_parameters_configure_protocol_disable?language=objc)
    pub static _nw_parameters_configure_protocol_disable: nw_parameters_configure_protocol_block_t;
}

impl NWParameters {
    /// Creates a parameters object that is configured for TLS and TCP. The caller can use
    /// the default configuration for TLS and TCP, or set specific options for each protocol,
    /// or disable TLS.
    ///
    ///
    /// Parameter `configure_tls`: A block to configure TLS. To use the default TLS configuration, pass
    /// NW_PARAMETERS_DEFAULT_CONFIGURATION. To configure specific options, pass a custom
    /// block and operate on the nw_protocol_options_t object. To disable TLS, pass
    /// NW_PARAMETERS_DISABLE_PROTOCOL.
    ///
    ///
    /// Parameter `configure_tcp`: A block to configure TCP. To use the default TCP configuration, pass
    /// NW_PARAMETERS_DEFAULT_CONFIGURATION. To configure specific options, pass a custom
    /// block and operate on the nw_protocol_options_t object. It is invalid to try
    /// to disable TCP using NW_PARAMETERS_DISABLE_PROTOCOL.
    ///
    ///
    /// Returns: Returns an allocated nw_parameters_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    ///
    /// # Safety
    ///
    /// - `configure_tls` must be a valid pointer.
    /// - `configure_tcp` must be a valid pointer.
    #[doc(alias = "nw_parameters_create_secure_tcp")]
    #[inline]
    pub unsafe fn new_secure_tcp(
        configure_tls: nw_parameters_configure_protocol_block_t,
        configure_tcp: nw_parameters_configure_protocol_block_t,
    ) -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_parameters_create_secure_tcp(
                configure_tls: nw_parameters_configure_protocol_block_t,
                configure_tcp: nw_parameters_configure_protocol_block_t,
            ) -> Option<NonNull<NWParameters>>;
        }
        let ret = unsafe { nw_parameters_create_secure_tcp(configure_tls, configure_tcp) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a parameters object that is configured for DTLS and UDP. The caller can use
    /// the default configuration for DTLS and UDP, or set specific options for each protocol,
    /// or disable DTLS.
    ///
    ///
    /// Parameter `configure_dtls`: A block to configure DTLS. To use the default DTLS configuration, pass
    /// NW_PARAMETERS_DEFAULT_CONFIGURATION. To configure specific options, pass a custom
    /// block and operate on the nw_protocol_options_t object. To disable DTLS, pass
    /// NW_PARAMETERS_DISABLE_PROTOCOL.
    ///
    ///
    /// Parameter `configure_udp`: A block to configure UDP. To use the default UDP configuration, pass
    /// NW_PARAMETERS_DEFAULT_CONFIGURATION. To configure specific options, pass a custom
    /// block and operate on the nw_protocol_options_t object. It is invalid to try
    /// to disable UDP using NW_PARAMETERS_DISABLE_PROTOCOL.
    ///
    ///
    /// Returns: Returns an allocated nw_parameters_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    ///
    /// # Safety
    ///
    /// - `configure_dtls` must be a valid pointer.
    /// - `configure_udp` must be a valid pointer.
    #[doc(alias = "nw_parameters_create_secure_udp")]
    #[inline]
    pub unsafe fn new_secure_udp(
        configure_dtls: nw_parameters_configure_protocol_block_t,
        configure_udp: nw_parameters_configure_protocol_block_t,
    ) -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_parameters_create_secure_udp(
                configure_dtls: nw_parameters_configure_protocol_block_t,
                configure_udp: nw_parameters_configure_protocol_block_t,
            ) -> Option<NonNull<NWParameters>>;
        }
        let ret = unsafe { nw_parameters_create_secure_udp(configure_dtls, configure_udp) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a parameters object that is configured for a custom IP protocol.
    /// This allows the caller to create connections and listeners that send
    /// and receive IP datagrams where the protocol header contained by the IP
    /// datagram is identified by the provided protocol number. Protocols already
    /// registered by the system, such as TCP and UDP, will not be allowed.
    ///
    /// Calling processes must hold the "com.apple.developer.networking.custom-protocol"
    /// entitlement.
    ///
    ///
    /// Parameter `custom_ip_protocol_number`: The protocol number identifying a protocol carried by IP, as defined
    /// in RFC 5237.
    ///
    ///
    /// Parameter `configure_ip`: A block to configure IP. To use the default IP configuration, pass
    /// NW_PARAMETERS_DEFAULT_CONFIGURATION. To configure specific options, pass a custom
    /// block and operate on the nw_protocol_options_t object. It is invalid to try
    /// to disable IP using NW_PARAMETERS_DISABLE_PROTOCOL.
    ///
    ///
    /// Returns: Returns an allocated nw_parameters_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    ///
    /// # Safety
    ///
    /// `configure_ip` must be a valid pointer.
    #[doc(alias = "nw_parameters_create_custom_ip")]
    #[inline]
    pub unsafe fn new_custom_ip(
        custom_ip_protocol_number: u8,
        configure_ip: nw_parameters_configure_protocol_block_t,
    ) -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_parameters_create_custom_ip(
                custom_ip_protocol_number: u8,
                configure_ip: nw_parameters_configure_protocol_block_t,
            ) -> Option<NonNull<NWParameters>>;
        }
        let ret =
            unsafe { nw_parameters_create_custom_ip(custom_ip_protocol_number, configure_ip) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a parameters object that is configured for QUIC. The caller must
    /// pass in a block to configure options.
    ///
    ///
    /// Parameter `configure_quic`: A block to configure QUIC. The caller must pass a custom
    /// block to configure the QUIC options.
    ///
    ///
    /// Returns: Returns an allocated nw_parameters_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    ///
    /// # Safety
    ///
    /// `configure_quic` must be a valid pointer.
    #[doc(alias = "nw_parameters_create_quic")]
    #[inline]
    pub unsafe fn new_quic(
        configure_quic: nw_parameters_configure_protocol_block_t,
    ) -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_parameters_create_quic(
                configure_quic: nw_parameters_configure_protocol_block_t,
            ) -> Option<NonNull<NWParameters>>;
        }
        let ret = unsafe { nw_parameters_create_quic(configure_quic) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates default parameters for use with application services.
    ///
    ///
    /// Returns: Returns an allocated nw_parameters_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    #[doc(alias = "nw_parameters_create_application_service")]
    #[inline]
    pub fn new_application_service() -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_parameters_create_application_service() -> Option<NonNull<NWParameters>>;
        }
        let ret = unsafe { nw_parameters_create_application_service() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a generic parameters object. Note that in order to use parameters
    /// with an nw_connection_t or an nw_listener_t, the parameters must have protocols
    /// added into the default nw_protocol_stack_t. Clients using standard protocol
    /// configurations should use nw_parameters_create_secure_tcp() or
    /// nw_parameters_create_secure_udp().
    ///
    ///
    /// Returns: Returns an allocated nw_parameters_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    #[doc(alias = "nw_parameters_create")]
    #[inline]
    pub fn new() -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_parameters_create() -> Option<NonNull<NWParameters>>;
        }
        let ret = unsafe { nw_parameters_create() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a deep copy of a parameters object that can be modified.
    ///
    ///
    /// Parameter `parameters`: The existing parameters object to copy
    ///
    ///
    /// Returns: Returns a newly allocated nw_parameters_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_parameters_copy")]
    #[inline]
    pub fn copy(&self) -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_parameters_copy(parameters: &NWParameters) -> Option<NonNull<NWParameters>>;
        }
        let ret = unsafe { nw_parameters_copy(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Set a privacy context on the parameters, which will be associated
    /// with connections and listeners. The privacy context allows
    /// using separate caches for different sets of connections, as well as
    /// restricting how connection-specific information is logged and shared
    /// on the network.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `privacy_context`: The privacy context to associate with connections and listeners that use
    /// these parameters.
    #[doc(alias = "nw_parameters_set_privacy_context")]
    #[inline]
    pub fn set_privacy_context(&self, privacy_context: &NWPrivacyContext) {
        extern "C-unwind" {
            fn nw_parameters_set_privacy_context(
                parameters: &NWParameters,
                privacy_context: &NWPrivacyContext,
            );
        }
        unsafe { nw_parameters_set_privacy_context(self, privacy_context) }
    }
}

/// Attribution values can be used to indicate who determined the network content being accessed.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_parameters_attribution_t?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_parameters_attribution_t(pub u8);
impl nw_parameters_attribution_t {
    #[doc(alias = "nw_parameters_attribution_developer")]
    pub const developer: Self = Self(1);
    #[doc(alias = "nw_parameters_attribution_user")]
    pub const user: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_parameters_attribution_t {
    const ENCODING: Encoding = u8::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_parameters_attribution_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWParameters {
    /// In order to help differentiate communication with domains requested by the user from those requested by the
    /// developer, attribution may be used. Attribution defaults to nw_parameters_attribution_developer. Setting
    /// attribution to nw_parameters_attribution_user indicates that the networking performed using these parameters
    /// is directed to content specified by the user, not the developer.
    ///
    ///
    /// Parameter `parameters`: The parameters to modify.
    ///
    ///
    /// Parameter `attribution`: The entity to attribute the network operations to.
    #[doc(alias = "nw_parameters_set_attribution")]
    #[inline]
    pub fn set_attribution(&self, attribution: nw_parameters_attribution_t) {
        extern "C-unwind" {
            fn nw_parameters_set_attribution(
                parameters: &NWParameters,
                attribution: nw_parameters_attribution_t,
            );
        }
        unsafe { nw_parameters_set_attribution(self, attribution) }
    }

    /// Returns the attribution set on the parameters.
    ///
    ///
    /// Parameter `parameters`: The parameters to check.
    ///
    ///
    /// Returns: Returns the attribution property of the parameters.
    #[doc(alias = "nw_parameters_get_attribution")]
    #[inline]
    pub fn attribution(&self) -> nw_parameters_attribution_t {
        extern "C-unwind" {
            fn nw_parameters_get_attribution(
                parameters: &NWParameters,
            ) -> nw_parameters_attribution_t;
        }
        unsafe { nw_parameters_get_attribution(self) }
    }

    /// Require any connections or listeners using these parameters to use
    /// the provided network interface, or none if NULL is passed.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `interface`: The interface to require for connections or listeners, or NULL to
    /// allow any interface.
    #[doc(alias = "nw_parameters_require_interface")]
    #[inline]
    pub fn require_interface(&self, interface: Option<&NWInterface>) {
        extern "C-unwind" {
            fn nw_parameters_require_interface(
                parameters: &NWParameters,
                interface: Option<&NWInterface>,
            );
        }
        unsafe { nw_parameters_require_interface(self, interface) }
    }

    /// Access the required network interface set on the parameters.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns the interface that is required by the parameters, or
    /// NULL if no interface is required.
    #[doc(alias = "nw_parameters_copy_required_interface")]
    #[inline]
    pub fn required_interface(&self) -> Option<NWRetained<NWInterface>> {
        extern "C-unwind" {
            fn nw_parameters_copy_required_interface(
                parameters: &NWParameters,
            ) -> Option<NonNull<NWInterface>>;
        }
        let ret = unsafe { nw_parameters_copy_required_interface(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Prohibit any connections or listeners using these parameters from using
    /// the provided network interface.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `interface`: The interface to prohibit for connections or listeners.
    #[doc(alias = "nw_parameters_prohibit_interface")]
    #[inline]
    pub fn prohibit_interface(&self, interface: &NWInterface) {
        extern "C-unwind" {
            fn nw_parameters_prohibit_interface(parameters: &NWParameters, interface: &NWInterface);
        }
        unsafe { nw_parameters_prohibit_interface(self, interface) }
    }

    /// Clear any interfaces that had been prohibited.
    ///
    ///
    /// Parameter `parameters`: The parameters object to modify
    #[doc(alias = "nw_parameters_clear_prohibited_interfaces")]
    #[inline]
    pub fn clear_prohibited_interfaces(&self) {
        extern "C-unwind" {
            fn nw_parameters_clear_prohibited_interfaces(parameters: &NWParameters);
        }
        unsafe { nw_parameters_clear_prohibited_interfaces(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_parameters_iterate_interfaces_block_t?language=objc)
pub type nw_parameters_iterate_interfaces_block_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWInterface>) -> bool>;

impl NWParameters {
    /// List all prohibited network interfaces.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Parameter `iterate_block`: A block that will return the interfaces prohibited by the parameters. Returning
    /// true from the block will continue to iterate, and returning false will stop
    /// iterating.
    ///
    /// # Safety
    ///
    /// `iterate_block` must be a valid pointer.
    #[doc(alias = "nw_parameters_iterate_prohibited_interfaces")]
    #[inline]
    pub unsafe fn iterate_prohibited_interfaces(
        &self,
        iterate_block: nw_parameters_iterate_interfaces_block_t,
    ) {
        extern "C-unwind" {
            fn nw_parameters_iterate_prohibited_interfaces(
                parameters: &NWParameters,
                iterate_block: nw_parameters_iterate_interfaces_block_t,
            );
        }
        unsafe { nw_parameters_iterate_prohibited_interfaces(self, iterate_block) }
    }

    /// Require any connections or listeners using these parameters to use
    /// the provided network interface type.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `interface_type`: The interface type to require for connections or listeners.
    #[doc(alias = "nw_parameters_set_required_interface_type")]
    #[inline]
    pub fn set_required_interface_type(&self, interface_type: nw_interface_type_t) {
        extern "C-unwind" {
            fn nw_parameters_set_required_interface_type(
                parameters: &NWParameters,
                interface_type: nw_interface_type_t,
            );
        }
        unsafe { nw_parameters_set_required_interface_type(self, interface_type) }
    }

    /// Access the required network interface type set on the parameters.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns the interface type that is required by the parameters, or
    /// nw_interface_type_other_t if no interface type is required.
    #[doc(alias = "nw_parameters_get_required_interface_type")]
    #[inline]
    pub fn required_interface_type(&self) -> nw_interface_type_t {
        extern "C-unwind" {
            fn nw_parameters_get_required_interface_type(
                parameters: &NWParameters,
            ) -> nw_interface_type_t;
        }
        unsafe { nw_parameters_get_required_interface_type(self) }
    }

    /// Prohibit any connections or listeners using these parameters from using
    /// the provided network interface type.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `interface_type`: The interface type to prohibit for connections or listeners.
    #[doc(alias = "nw_parameters_prohibit_interface_type")]
    #[inline]
    pub fn prohibit_interface_type(&self, interface_type: nw_interface_type_t) {
        extern "C-unwind" {
            fn nw_parameters_prohibit_interface_type(
                parameters: &NWParameters,
                interface_type: nw_interface_type_t,
            );
        }
        unsafe { nw_parameters_prohibit_interface_type(self, interface_type) }
    }

    /// Clear any interface types that had been prohibited.
    ///
    ///
    /// Parameter `parameters`: The parameters object to modify
    #[doc(alias = "nw_parameters_clear_prohibited_interface_types")]
    #[inline]
    pub fn clear_prohibited_interface_types(&self) {
        extern "C-unwind" {
            fn nw_parameters_clear_prohibited_interface_types(parameters: &NWParameters);
        }
        unsafe { nw_parameters_clear_prohibited_interface_types(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_parameters_iterate_interface_types_block_t?language=objc)
pub type nw_parameters_iterate_interface_types_block_t =
    *mut block2::DynBlock<dyn Fn(nw_interface_type_t) -> bool>;

impl NWParameters {
    /// List all prohibited network interface types.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Parameter `iterate_block`: A block that will return the interface types prohibited by the parameters. Returning
    /// true from the block will continue to iterate, and returning false will stop
    /// iterating.
    ///
    /// # Safety
    ///
    /// `iterate_block` must be a valid pointer.
    #[doc(alias = "nw_parameters_iterate_prohibited_interface_types")]
    #[inline]
    pub unsafe fn iterate_prohibited_interface_types(
        &self,
        iterate_block: nw_parameters_iterate_interface_types_block_t,
    ) {
        extern "C-unwind" {
            fn nw_parameters_iterate_prohibited_interface_types(
                parameters: &NWParameters,
                iterate_block: nw_parameters_iterate_interface_types_block_t,
            );
        }
        unsafe { nw_parameters_iterate_prohibited_interface_types(self, iterate_block) }
    }

    /// Prohibit any connections or listeners using these parameters from using
    /// a network interface that is considered expensive by the system.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `prohibit_expensive`: If true, prohibit the use of any expensive interfaces. If false,
    /// allow expensive interfaces. Defaults to false.
    #[doc(alias = "nw_parameters_set_prohibit_expensive")]
    #[inline]
    pub fn set_prohibit_expensive(&self, prohibit_expensive: bool) {
        extern "C-unwind" {
            fn nw_parameters_set_prohibit_expensive(
                parameters: &NWParameters,
                prohibit_expensive: bool,
            );
        }
        unsafe { nw_parameters_set_prohibit_expensive(self, prohibit_expensive) }
    }

    /// Check if the parameters prohibit expensive interfaces.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns true if expensive interfaces are prohibited, or
    /// false otherwise.
    #[doc(alias = "nw_parameters_get_prohibit_expensive")]
    #[inline]
    pub fn prohibit_expensive(&self) -> bool {
        extern "C-unwind" {
            fn nw_parameters_get_prohibit_expensive(parameters: &NWParameters) -> bool;
        }
        unsafe { nw_parameters_get_prohibit_expensive(self) }
    }

    /// Prohibit any connections or listeners using these parameters from using
    /// a network interface that is considered constrained by the system.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `prohibit_constrained`: If true, prohibit the use of any constrained interfaces. If false,
    /// allow constrained interfaces. Defaults to false.
    #[doc(alias = "nw_parameters_set_prohibit_constrained")]
    #[inline]
    pub fn set_prohibit_constrained(&self, prohibit_constrained: bool) {
        extern "C-unwind" {
            fn nw_parameters_set_prohibit_constrained(
                parameters: &NWParameters,
                prohibit_constrained: bool,
            );
        }
        unsafe { nw_parameters_set_prohibit_constrained(self, prohibit_constrained) }
    }

    /// Check if the parameters prohibit constrained interfaces.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns true if constrained interfaces are prohibited, or
    /// false otherwise.
    #[doc(alias = "nw_parameters_get_prohibit_constrained")]
    #[inline]
    pub fn prohibit_constrained(&self) -> bool {
        extern "C-unwind" {
            fn nw_parameters_get_prohibit_constrained(parameters: &NWParameters) -> bool;
        }
        unsafe { nw_parameters_get_prohibit_constrained(self) }
    }

    /// Explicitly allow connectivity over ultra-constrained interfaces. Without
    /// this being set, connections are not allowed to use these interfaces.
    ///
    ///
    /// Parameter `parameters`: The parameters to modify.
    ///
    ///
    /// Parameter `allow_ultra_constrained`: Whether or not ultra-constrained interfaces are allowed.
    #[doc(alias = "nw_parameters_set_allow_ultra_constrained")]
    #[inline]
    pub fn set_allow_ultra_constrained(&self, allow_ultra_constrained: bool) {
        extern "C-unwind" {
            fn nw_parameters_set_allow_ultra_constrained(
                parameters: &NWParameters,
                allow_ultra_constrained: bool,
            );
        }
        unsafe { nw_parameters_set_allow_ultra_constrained(self, allow_ultra_constrained) }
    }

    /// Check if the parameters explicitly allow connectivity over
    /// ultra-constrained interfaces.
    ///
    ///
    /// Parameter `parameters`: The parameters to check.
    ///
    ///
    /// Returns: Returns whether or not ultra-constrained interfaces are allowed.
    #[doc(alias = "nw_parameters_get_allow_ultra_constrained")]
    #[inline]
    pub fn allow_ultra_constrained(&self) -> bool {
        extern "C-unwind" {
            fn nw_parameters_get_allow_ultra_constrained(parameters: &NWParameters) -> bool;
        }
        unsafe { nw_parameters_get_allow_ultra_constrained(self) }
    }

    /// Allow any connections using these parameters to reuse
    /// local addresses already in use by other connections.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `reuse_local_address`: If true, allow the reuse of local addresses. If false,
    /// disallow the reuse of local addresses. Defaults to false.
    #[doc(alias = "nw_parameters_set_reuse_local_address")]
    #[inline]
    pub fn set_reuse_local_address(&self, reuse_local_address: bool) {
        extern "C-unwind" {
            fn nw_parameters_set_reuse_local_address(
                parameters: &NWParameters,
                reuse_local_address: bool,
            );
        }
        unsafe { nw_parameters_set_reuse_local_address(self, reuse_local_address) }
    }

    /// Check if the parameters allow local address reuse.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns true if local address reuse is allowed, or
    /// false otherwise.
    #[doc(alias = "nw_parameters_get_reuse_local_address")]
    #[inline]
    pub fn reuse_local_address(&self) -> bool {
        extern "C-unwind" {
            fn nw_parameters_get_reuse_local_address(parameters: &NWParameters) -> bool;
        }
        unsafe { nw_parameters_get_reuse_local_address(self) }
    }

    /// Specify a specific endpoint to use as the local endpoint.
    /// For connections, this will be used to initiate traffic;
    /// for listeners, this will be used for receiving incoming
    /// connections.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `local_endpoint`: The endpoint to set as the local endpoint. Pass NULL to
    /// clear the local endpoint.
    #[doc(alias = "nw_parameters_set_local_endpoint")]
    #[inline]
    pub fn set_local_endpoint(&self, local_endpoint: Option<&NWEndpoint>) {
        extern "C-unwind" {
            fn nw_parameters_set_local_endpoint(
                parameters: &NWParameters,
                local_endpoint: Option<&NWEndpoint>,
            );
        }
        unsafe { nw_parameters_set_local_endpoint(self, local_endpoint) }
    }

    /// Extract the local endpoint set on the connection.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Returns: Returns the endpoint that is set in the parameters, or
    /// NULL if no local endpoint is set.
    #[doc(alias = "nw_parameters_copy_local_endpoint")]
    #[inline]
    pub fn local_endpoint(&self) -> Option<NWRetained<NWEndpoint>> {
        extern "C-unwind" {
            fn nw_parameters_copy_local_endpoint(
                parameters: &NWParameters,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_parameters_copy_local_endpoint(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Allow the inclusion of peer-to-peer interfaces when
    /// listening or establishing outbound connections. This parameter
    /// will not take effect if a specific interface is required.
    /// This parameter is applicable when advertising a Bonjour service
    /// on a listener, or connecting to a Bonjour service.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `include_peer_to_peer`: If true, allow advertising, resolving, and connecting over
    /// peer-to-peer interfaces. Defaults to false.
    #[doc(alias = "nw_parameters_set_include_peer_to_peer")]
    #[inline]
    pub fn set_include_peer_to_peer(&self, include_peer_to_peer: bool) {
        extern "C-unwind" {
            fn nw_parameters_set_include_peer_to_peer(
                parameters: &NWParameters,
                include_peer_to_peer: bool,
            );
        }
        unsafe { nw_parameters_set_include_peer_to_peer(self, include_peer_to_peer) }
    }

    /// Check if the parameters allow the inclusion of
    /// peer-to-peer interfaces.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns true if peer-to-peer interfaces are allowed,
    /// or false otherwise.
    #[doc(alias = "nw_parameters_get_include_peer_to_peer")]
    #[inline]
    pub fn include_peer_to_peer(&self) -> bool {
        extern "C-unwind" {
            fn nw_parameters_get_include_peer_to_peer(parameters: &NWParameters) -> bool;
        }
        unsafe { nw_parameters_get_include_peer_to_peer(self) }
    }

    /// Use fast open for an outbound connection, which may be done at any
    /// protocol level. Use of fast open requires that the caller send
    /// idempotent data on the connection before the connection may move
    /// into the ready state. As a side effect, this may implicitly enable
    /// fast open or early data for protocols in the stack, even if they did not
    /// have fast open explicitly enabled on them (such as the option to enable
    /// TCP Fast Open).
    ///
    /// NOTE: Use of this API may have security implications for application data.
    /// In particular, TLS early data is replayable by a network attacker. Callers must
    /// account for this when sending data before the handshake is confirmed. See
    /// RFC 8446 for more information. Callers MUST NOT enable fast open without
    /// a specific application profile that defines its use.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `fast_open_enabled`: If true, indicate that fast open is requested and that idempotent data
    /// MUST be sent by the caller on the connection. If false,
    /// disallow the fast open at the top level protocol. Defaults to false.
    #[doc(alias = "nw_parameters_set_fast_open_enabled")]
    #[inline]
    pub fn set_fast_open_enabled(&self, fast_open_enabled: bool) {
        extern "C-unwind" {
            fn nw_parameters_set_fast_open_enabled(
                parameters: &NWParameters,
                fast_open_enabled: bool,
            );
        }
        unsafe { nw_parameters_set_fast_open_enabled(self, fast_open_enabled) }
    }

    /// Check if the parameters allow the use of fast open for the top level
    /// protocol.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns true if fast open is allowed for the top level protocol, or
    /// false otherwise.
    #[doc(alias = "nw_parameters_get_fast_open_enabled")]
    #[inline]
    pub fn fast_open_enabled(&self) -> bool {
        extern "C-unwind" {
            fn nw_parameters_get_fast_open_enabled(parameters: &NWParameters) -> bool;
        }
        unsafe { nw_parameters_get_fast_open_enabled(self) }
    }
}

/// The network service class represents the network queuing priority to use
/// for traffic generated by a connection.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_service_class_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_service_class_t(pub c_uint);
impl nw_service_class_t {
    #[doc(alias = "nw_service_class_best_effort")]
    pub const best_effort: Self = Self(0);
    #[doc(alias = "nw_service_class_background")]
    pub const background: Self = Self(1);
    #[doc(alias = "nw_service_class_interactive_video")]
    pub const interactive_video: Self = Self(2);
    #[doc(alias = "nw_service_class_interactive_voice")]
    pub const interactive_voice: Self = Self(3);
    #[doc(alias = "nw_service_class_responsive_data")]
    pub const responsive_data: Self = Self(4);
    #[doc(alias = "nw_service_class_signaling")]
    pub const signaling: Self = Self(5);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_service_class_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_service_class_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWParameters {
    /// Set the data service class to use for connections.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `service_class`: The service class value to use for connections. Defaults to nw_service_class_best_effort.
    #[doc(alias = "nw_parameters_set_service_class")]
    #[inline]
    pub fn set_service_class(&self, service_class: nw_service_class_t) {
        extern "C-unwind" {
            fn nw_parameters_set_service_class(
                parameters: &NWParameters,
                service_class: nw_service_class_t,
            );
        }
        unsafe { nw_parameters_set_service_class(self, service_class) }
    }

    /// Check the service class configured on the parameters.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns the effective service class configured on the parameters.
    #[doc(alias = "nw_parameters_get_service_class")]
    #[inline]
    pub fn service_class(&self) -> nw_service_class_t {
        extern "C-unwind" {
            fn nw_parameters_get_service_class(parameters: &NWParameters) -> nw_service_class_t;
        }
        unsafe { nw_parameters_get_service_class(self) }
    }
}

/// Multipath services represent the modes of multipath usage that are
/// allowed for connections.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_multipath_service_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_multipath_service_t(pub c_uint);
impl nw_multipath_service_t {
    #[doc(alias = "nw_multipath_service_disabled")]
    pub const disabled: Self = Self(0);
    #[doc(alias = "nw_multipath_service_handover")]
    pub const handover: Self = Self(1);
    #[doc(alias = "nw_multipath_service_interactive")]
    pub const interactive: Self = Self(2);
    #[doc(alias = "nw_multipath_service_aggregate")]
    pub const aggregate: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_multipath_service_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_multipath_service_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWParameters {
    /// Set the multipath service to use for connections.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `multipath_service`: The multipath service value to use for connections. Defaults to nw_multipath_service_disabled.
    #[doc(alias = "nw_parameters_set_multipath_service")]
    #[inline]
    pub fn set_multipath_service(&self, multipath_service: nw_multipath_service_t) {
        extern "C-unwind" {
            fn nw_parameters_set_multipath_service(
                parameters: &NWParameters,
                multipath_service: nw_multipath_service_t,
            );
        }
        unsafe { nw_parameters_set_multipath_service(self, multipath_service) }
    }

    /// Check the multipath service mode configured on the parameters.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns the multipath service configured on the parameters.
    #[doc(alias = "nw_parameters_get_multipath_service")]
    #[inline]
    pub fn multipath_service(&self) -> nw_multipath_service_t {
        extern "C-unwind" {
            fn nw_parameters_get_multipath_service(
                parameters: &NWParameters,
            ) -> nw_multipath_service_t;
        }
        unsafe { nw_parameters_get_multipath_service(self) }
    }

    /// Retrieve the default protocol stack from a parameters object.
    /// Every parameters object will have a default protocol stack. For
    /// parameters created with a convenience initializer, this protocol
    /// stack will be pre-populated. For parameters created with the generic
    /// initializers, the stack will be empty.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns an nw_protocol_stack_t object that can be inspected and modified.
    #[doc(alias = "nw_parameters_copy_default_protocol_stack")]
    #[inline]
    pub fn default_protocol_stack(&self) -> NWRetained<NWProtocolStack> {
        extern "C-unwind" {
            fn nw_parameters_copy_default_protocol_stack(
                parameters: &NWParameters,
            ) -> Option<NonNull<NWProtocolStack>>;
        }
        let ret = unsafe { nw_parameters_copy_default_protocol_stack(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

impl NWProtocolStack {
    /// Prepend an application-layer protocol onto the top of a protocol stack.
    ///
    ///
    /// Parameter `stack`: The protocol stack to modify
    ///
    ///
    /// Parameter `protocol`: The protocol options to add to the stack, which contain the definition of the
    /// protocol to add.
    #[doc(alias = "nw_protocol_stack_prepend_application_protocol")]
    #[inline]
    pub fn prepend_application_protocol(&self, protocol: &NWProtocolOptions) {
        extern "C-unwind" {
            fn nw_protocol_stack_prepend_application_protocol(
                stack: &NWProtocolStack,
                protocol: &NWProtocolOptions,
            );
        }
        unsafe { nw_protocol_stack_prepend_application_protocol(self, protocol) }
    }

    /// Remove all application-layer protocols from a protocol stack.
    ///
    ///
    /// Parameter `stack`: The protocol stack to modify
    #[doc(alias = "nw_protocol_stack_clear_application_protocols")]
    #[inline]
    pub fn clear_application_protocols(&self) {
        extern "C-unwind" {
            fn nw_protocol_stack_clear_application_protocols(stack: &NWProtocolStack);
        }
        unsafe { nw_protocol_stack_clear_application_protocols(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_protocol_stack_iterate_protocols_block_t?language=objc)
pub type nw_protocol_stack_iterate_protocols_block_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWProtocolOptions>)>;

impl NWProtocolStack {
    /// List all application protocols attached to a protocol stack.
    ///
    ///
    /// Parameter `stack`: The protocol stack to check
    ///
    ///
    /// Parameter `iterate_block`: A block that will return the protocols attached to the stack.
    ///
    /// # Safety
    ///
    /// `iterate_block` must be a valid pointer.
    #[doc(alias = "nw_protocol_stack_iterate_application_protocols")]
    #[inline]
    pub unsafe fn iterate_application_protocols(
        &self,
        iterate_block: nw_protocol_stack_iterate_protocols_block_t,
    ) {
        extern "C-unwind" {
            fn nw_protocol_stack_iterate_application_protocols(
                stack: &NWProtocolStack,
                iterate_block: nw_protocol_stack_iterate_protocols_block_t,
            );
        }
        unsafe { nw_protocol_stack_iterate_application_protocols(self, iterate_block) }
    }

    /// Access the transport-layer protocol used in a protocol stack.
    ///
    ///
    /// Parameter `stack`: The protocol stack to check
    ///
    ///
    /// Returns: Returns the transport protocol currently set in the protocol stack,
    /// or NULL if no transport protocol is set.
    #[doc(alias = "nw_protocol_stack_copy_transport_protocol")]
    #[inline]
    pub fn transport_protocol(&self) -> Option<NWRetained<NWProtocolOptions>> {
        extern "C-unwind" {
            fn nw_protocol_stack_copy_transport_protocol(
                stack: &NWProtocolStack,
            ) -> Option<NonNull<NWProtocolOptions>>;
        }
        let ret = unsafe { nw_protocol_stack_copy_transport_protocol(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Set the transport-layer protocol to use for a protocol stack.
    ///
    ///
    /// Parameter `stack`: The protocol stack to modify
    ///
    ///
    /// Parameter `protocol`: The protocol options to set into the stack, which contain the definition of the
    /// protocol.
    #[doc(alias = "nw_protocol_stack_set_transport_protocol")]
    #[inline]
    pub fn set_transport_protocol(&self, protocol: &NWProtocolOptions) {
        extern "C-unwind" {
            fn nw_protocol_stack_set_transport_protocol(
                stack: &NWProtocolStack,
                protocol: &NWProtocolOptions,
            );
        }
        unsafe { nw_protocol_stack_set_transport_protocol(self, protocol) }
    }

    /// Access the internet-layer protocol used in a protocol stack.
    ///
    ///
    /// Parameter `stack`: The protocol stack to check
    ///
    ///
    /// Returns: Returns the internet protocol currently set in the protocol stack,
    /// or NULL if no internet protocol is set. Note that this will generally
    /// be NULL, unless a specific IP family is being selected.
    #[doc(alias = "nw_protocol_stack_copy_internet_protocol")]
    #[inline]
    pub fn internet_protocol(&self) -> Option<NWRetained<NWProtocolOptions>> {
        extern "C-unwind" {
            fn nw_protocol_stack_copy_internet_protocol(
                stack: &NWProtocolStack,
            ) -> Option<NonNull<NWProtocolOptions>>;
        }
        let ret = unsafe { nw_protocol_stack_copy_internet_protocol(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }
}

impl NWParameters {
    /// Set to true to limit inbound connections to peers attached to the
    /// local link only. Defaults to false.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `local_only`: True to limit connections to the local link only.
    #[doc(alias = "nw_parameters_set_local_only")]
    #[inline]
    pub fn set_local_only(&self, local_only: bool) {
        extern "C-unwind" {
            fn nw_parameters_set_local_only(parameters: &NWParameters, local_only: bool);
        }
        unsafe { nw_parameters_set_local_only(self, local_only) }
    }

    /// Indicates whether or not the parameters limit connections to the local
    /// link only.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns true if the parameters limit inbound connections to the local link.
    #[doc(alias = "nw_parameters_get_local_only")]
    #[inline]
    pub fn local_only(&self) -> bool {
        extern "C-unwind" {
            fn nw_parameters_get_local_only(parameters: &NWParameters) -> bool;
        }
        unsafe { nw_parameters_get_local_only(self) }
    }

    /// Set to true to attempt connections without using proxies, only using any configured proxies if the connections
    /// cannot otherwise be completed. Defaults to false.
    ///
    ///
    /// Parameter `parameters`: The parameters to modify.
    ///
    ///
    /// Parameter `prefer_no_proxy`: True to cause connections to be attempted without proxies.
    #[doc(alias = "nw_parameters_set_prefer_no_proxy")]
    #[inline]
    pub fn set_prefer_no_proxy(&self, prefer_no_proxy: bool) {
        extern "C-unwind" {
            fn nw_parameters_set_prefer_no_proxy(parameters: &NWParameters, prefer_no_proxy: bool);
        }
        unsafe { nw_parameters_set_prefer_no_proxy(self, prefer_no_proxy) }
    }

    /// Indicates whether or not the parameters cause connections to be attempted without proxies, only using proxies
    /// if connections cannot otherwise be completed.
    ///
    ///
    /// Parameter `parameters`: The parameters to get the property from.
    ///
    ///
    /// Returns: Returns true if the parameters cause connections to be attempted without proxies, only using proxies if
    /// connections cannot otherwise be completed.
    #[doc(alias = "nw_parameters_get_prefer_no_proxy")]
    #[inline]
    pub fn prefer_no_proxy(&self) -> bool {
        extern "C-unwind" {
            fn nw_parameters_get_prefer_no_proxy(parameters: &NWParameters) -> bool;
        }
        unsafe { nw_parameters_get_prefer_no_proxy(self) }
    }
}

/// Expired DNS behavior defines whether or not a connection will allow the use
/// of expired DNS answers during connection establishment.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_parameters_expired_dns_behavior_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_parameters_expired_dns_behavior_t(pub c_uint);
impl nw_parameters_expired_dns_behavior_t {
    #[doc(alias = "nw_parameters_expired_dns_behavior_default")]
    pub const default: Self = Self(0);
    #[doc(alias = "nw_parameters_expired_dns_behavior_allow")]
    pub const allow: Self = Self(1);
    #[doc(alias = "nw_parameters_expired_dns_behavior_prohibit")]
    pub const prohibit: Self = Self(2);
    /// This should only be set for hostnames whose resolutions are not expected to change across networks.
    #[doc(alias = "nw_parameters_expired_dns_behavior_persistent")]
    pub const persistent: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_parameters_expired_dns_behavior_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_parameters_expired_dns_behavior_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWParameters {
    /// Allow or prohibit the use of expired DNS answers during connection establishment.
    /// If allowed, a DNS answer that was previously returned may be re-used for new
    /// connections even after the answers are considered expired. A query for fresh answers
    /// will be sent in parallel, and the fresh answers will be used as alternate addresses
    /// in case the expired answers do not result in successful connections.
    ///
    /// By default, this value is nw_parameters_expired_dns_behavior_default, which allows
    /// the system to determine if it is appropriate to use expired answers.
    ///
    ///
    /// Parameter `parameters`: The parameters to modify.
    ///
    ///
    /// Parameter `expired_dns_behavior`: Allow, prohibit, or use system default behavior for expired DNS answers.
    #[doc(alias = "nw_parameters_set_expired_dns_behavior")]
    #[inline]
    pub fn set_expired_dns_behavior(
        &self,
        expired_dns_behavior: nw_parameters_expired_dns_behavior_t,
    ) {
        extern "C-unwind" {
            fn nw_parameters_set_expired_dns_behavior(
                parameters: &NWParameters,
                expired_dns_behavior: nw_parameters_expired_dns_behavior_t,
            );
        }
        unsafe { nw_parameters_set_expired_dns_behavior(self, expired_dns_behavior) }
    }

    /// Check the effective expired DNS behavior of a connection.
    /// See nw_parameters_set_expired_dns_behavior() for a discussion on the use of expired
    /// DNS answers.
    ///
    ///
    /// Parameter `parameters`: The parameters to check.
    ///
    ///
    /// Returns: Returns the current effective expired DNS answer behavior.
    #[doc(alias = "nw_parameters_get_expired_dns_behavior")]
    #[inline]
    pub fn expired_dns_behavior(&self) -> nw_parameters_expired_dns_behavior_t {
        extern "C-unwind" {
            fn nw_parameters_get_expired_dns_behavior(
                parameters: &NWParameters,
            ) -> nw_parameters_expired_dns_behavior_t;
        }
        unsafe { nw_parameters_get_expired_dns_behavior(self) }
    }

    /// Require to do or not to do DNSSEC validation when resolving the endpoint, before
    /// making a connection.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure.
    ///
    ///
    /// Parameter `requires_dnssec_validation`: A boolean value that indicates if DNSSEC validation should be required
    /// when doing DNS resolution for the endpoint.
    ///
    ///
    /// DNSSEC validation only takes effect if making a connection to an
    /// endpoint that requires domain name resolution, such as:
    /// <code>
    /// nw_endpoint_type_host
    /// </code>
    /// <code>
    /// nw_endpoint_type_url
    /// </code>
    ///
    /// 1. If this property is not set or is set to false on the parameters, DNSSEC
    /// validation will not be required.
    ///
    /// 2. If this property is set to true and no additional DNSSEC
    /// configuration is set on the parameters, the default behavior will be
    /// followed: Only DNSSEC secure and DNSSEC insecure resolved result will be
    /// used to establish a connection.
    ///
    /// 3. If this property is set to true and additional DNSSEC configuration
    /// is set on the parameters, the behavior specified by that configuration
    /// will be followed.
    #[doc(alias = "nw_parameters_set_requires_dnssec_validation")]
    #[inline]
    pub fn set_requires_dnssec_validation(&self, requires_dnssec_validation: bool) {
        extern "C-unwind" {
            fn nw_parameters_set_requires_dnssec_validation(
                parameters: &NWParameters,
                requires_dnssec_validation: bool,
            );
        }
        unsafe { nw_parameters_set_requires_dnssec_validation(self, requires_dnssec_validation) }
    }

    /// Check if DNSSEC validation is required.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check.
    ///
    ///
    /// Returns: Returns true if DNSSEC validation is required, false otherwise.
    #[doc(alias = "nw_parameters_requires_dnssec_validation")]
    #[inline]
    pub fn requires_dnssec_validation(&self) -> bool {
        extern "C-unwind" {
            fn nw_parameters_requires_dnssec_validation(parameters: &NWParameters) -> bool;
        }
        unsafe { nw_parameters_requires_dnssec_validation(self) }
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_browse_descriptor?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_browse_descriptor: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_descriptor_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_browse_descriptor_t = NSObject;

impl NWBrowseDescriptor {
    /// Creates a new browse descriptor object on a Bonjour service type and
    /// domain.
    ///
    ///
    /// Parameter `type`: A Bonjour service type.
    ///
    ///
    /// Parameter `domain`: An optional Bonjour service domain. If the domain is unspecified, the
    /// default domains for browsing will be used.
    ///
    ///
    /// Returns: An instantiated browse descriptor object.
    ///
    /// # Safety
    ///
    /// - `type` must be a valid pointer.
    /// - `domain` must be a valid pointer or null.
    #[doc(alias = "nw_browse_descriptor_create_bonjour_service")]
    #[inline]
    pub unsafe fn new_bonjour_service(
        r#type: NonNull<c_char>,
        domain: *const c_char,
    ) -> NWRetained<NWBrowseDescriptor> {
        extern "C-unwind" {
            fn nw_browse_descriptor_create_bonjour_service(
                r#type: NonNull<c_char>,
                domain: *const c_char,
            ) -> Option<NonNull<NWBrowseDescriptor>>;
        }
        let ret = unsafe { nw_browse_descriptor_create_bonjour_service(r#type, domain) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Returns the service type of a browse descriptor.
    ///
    ///
    /// Parameter `descriptor`: A browse descriptor object.
    ///
    ///
    /// Returns: The service type.
    #[doc(alias = "nw_browse_descriptor_get_bonjour_service_type")]
    #[inline]
    pub fn bonjour_service_type(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_browse_descriptor_get_bonjour_service_type(
                descriptor: &NWBrowseDescriptor,
            ) -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_browse_descriptor_get_bonjour_service_type(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Returns the service domain of a browse descriptor, or NULL if NULL was
    /// provided while creating the descriptor.
    ///
    ///
    /// Parameter `descriptor`: A browse descriptor object.
    ///
    ///
    /// Returns: The service domain.
    #[doc(alias = "nw_browse_descriptor_get_bonjour_service_domain")]
    #[inline]
    pub fn bonjour_service_domain(&self) -> *const c_char {
        extern "C-unwind" {
            fn nw_browse_descriptor_get_bonjour_service_domain(
                descriptor: &NWBrowseDescriptor,
            ) -> *const c_char;
        }
        unsafe { nw_browse_descriptor_get_bonjour_service_domain(self) }
    }

    /// Set a flag to allow or prohibit the browser from querying for TXT records
    /// while browsing. This flag should only be set if the client needs information
    /// from the TXT record during browsing, and may increase network traffic. By
    /// default, the browser will not automatically query for TXT records.
    ///
    ///
    /// Parameter `descriptor`: The browse descriptor object.
    ///
    ///
    /// Parameter `include_txt_record`: A flag indicating whether results should include a TXT record. If true,
    /// the browser will query for TXT records. If false, the browser will not
    /// query for TXT records.
    #[doc(alias = "nw_browse_descriptor_set_include_txt_record")]
    #[inline]
    pub fn set_include_txt_record(&self, include_txt_record: bool) {
        extern "C-unwind" {
            fn nw_browse_descriptor_set_include_txt_record(
                descriptor: &NWBrowseDescriptor,
                include_txt_record: bool,
            );
        }
        unsafe { nw_browse_descriptor_set_include_txt_record(self, include_txt_record) }
    }

    /// Check whether the browser is allowed to query for TXT records.
    ///
    ///
    /// Parameter `descriptor`: The browse descriptor to check.
    ///
    ///
    /// Returns: Whether the browser is allowed to query for TXT records.
    #[doc(alias = "nw_browse_descriptor_get_include_txt_record")]
    #[inline]
    pub fn include_txt_record(&self) -> bool {
        extern "C-unwind" {
            fn nw_browse_descriptor_get_include_txt_record(descriptor: &NWBrowseDescriptor)
                -> bool;
        }
        unsafe { nw_browse_descriptor_get_include_txt_record(self) }
    }

    /// Creates a browse descriptor for application service discovery.
    ///
    ///
    /// Parameter `application_service_name`: The service name to browse for.
    ///
    ///
    /// Returns: An instantiated browse descriptor object.
    ///
    /// # Safety
    ///
    /// `application_service_name` must be a valid pointer.
    #[doc(alias = "nw_browse_descriptor_create_application_service")]
    #[inline]
    pub unsafe fn new_application_service(
        application_service_name: NonNull<c_char>,
    ) -> NWRetained<NWBrowseDescriptor> {
        extern "C-unwind" {
            fn nw_browse_descriptor_create_application_service(
                application_service_name: NonNull<c_char>,
            ) -> Option<NonNull<NWBrowseDescriptor>>;
        }
        let ret =
            unsafe { nw_browse_descriptor_create_application_service(application_service_name) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Returns the service name of an application service browse descriptor.
    ///
    ///
    /// Parameter `descriptor`: A browse descriptor object.
    ///
    ///
    /// Returns: The service name.
    #[doc(alias = "nw_browse_descriptor_get_application_service_name")]
    #[inline]
    pub fn application_service_name(&self) -> *const c_char {
        extern "C-unwind" {
            fn nw_browse_descriptor_get_application_service_name(
                descriptor: &NWBrowseDescriptor,
            ) -> *const c_char;
        }
        unsafe { nw_browse_descriptor_get_application_service_name(self) }
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_browse_result?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_browse_result: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_browse_result_t = NSObject;

/// A nw_browse_result_change_t describes all changes that occurred between
/// two browse results. Call nw_browse_result_get_changes() to get the
/// changes between an old and a new browse result.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_t?language=objc)
pub type nw_browse_result_change_t = u64;

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_invalid?language=objc)
pub const nw_browse_result_change_invalid: c_uint = 0x00;
/// are identical.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_identical?language=objc)
pub const nw_browse_result_change_identical: c_uint = 0x01;
/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_result_added?language=objc)
pub const nw_browse_result_change_result_added: c_uint = 0x02;
/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_result_removed?language=objc)
pub const nw_browse_result_change_result_removed: c_uint = 0x04;
/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_interface_added?language=objc)
pub const nw_browse_result_change_interface_added: c_uint = 0x08;
/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_interface_removed?language=objc)
pub const nw_browse_result_change_interface_removed: c_uint = 0x10;
/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_txt_record_changed?language=objc)
pub const nw_browse_result_change_txt_record_changed: c_uint = 0x20;

impl NWBrowseResult {
    /// Copies the endpoint associated with the browse result object.
    ///
    ///
    /// Parameter `result`: The browse result object.
    ///
    ///
    /// Returns: The associated endpoint.
    #[doc(alias = "nw_browse_result_copy_endpoint")]
    #[inline]
    pub fn endpoint(&self) -> NWRetained<NWEndpoint> {
        extern "C-unwind" {
            fn nw_browse_result_copy_endpoint(
                result: &NWBrowseResult,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_browse_result_copy_endpoint(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Determines the set of all changes that occurred between an old and a new
    /// browse result. For example, if the return value of this function matches
    /// with nw_browse_result_change_interface_added and nw_browse_result_change_txt_record_changed,
    /// the caller can expect new_result to include a new interface and an updated
    /// txt record that was not present in old_result.
    ///
    ///
    /// Parameter `old_result`: The old result.
    ///
    ///
    /// Parameter `new_result`: The new result.
    ///
    ///
    /// Returns: A nw_browse_result_change_t describing all changes that occurred.
    #[doc(alias = "nw_browse_result_get_changes")]
    #[inline]
    pub fn changes(&self, new_result: Option<&NWBrowseResult>) -> nw_browse_result_change_t {
        extern "C-unwind" {
            fn nw_browse_result_get_changes(
                old_result: Option<&NWBrowseResult>,
                new_result: Option<&NWBrowseResult>,
            ) -> nw_browse_result_change_t;
        }
        unsafe { nw_browse_result_get_changes(self, new_result) }
    }

    /// Returns the number of interfaces on this browse result.
    ///
    ///
    /// Parameter `result`: The browse result object.
    ///
    ///
    /// Returns: The number of interfaces available.
    #[doc(alias = "nw_browse_result_get_interfaces_count")]
    #[inline]
    pub fn interfaces_count(&self) -> usize {
        extern "C-unwind" {
            fn nw_browse_result_get_interfaces_count(result: &NWBrowseResult) -> usize;
        }
        unsafe { nw_browse_result_get_interfaces_count(self) }
    }

    /// Copies the TXT record object from the browse result.
    ///
    ///
    /// Parameter `result`: The browse result object.
    ///
    ///
    /// Returns: A copy of the TXT record object, or NULL if the browse result does not
    /// have an associated TXT record.
    #[doc(alias = "nw_browse_result_copy_txt_record_object")]
    #[inline]
    pub fn txt_record_object(&self) -> Option<NWRetained<NWTxtRecord>> {
        extern "C-unwind" {
            fn nw_browse_result_copy_txt_record_object(
                result: &NWBrowseResult,
            ) -> Option<NonNull<NWTxtRecord>>;
        }
        let ret = unsafe { nw_browse_result_copy_txt_record_object(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }
}

/// A block that can be applied to every interface in the browse result.
///
///
/// Parameter `interface`: The interface object.
///
///
/// Returns: A boolean value that indicating if enumeration should continue.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_enumerate_interface_t?language=objc)
pub type nw_browse_result_enumerate_interface_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWInterface>) -> bool>;

impl NWBrowseResult {
    /// Enumerates the list of interfaces on this browse result.
    ///
    ///
    /// Parameter `result`: The browse result object.
    ///
    ///
    /// Parameter `enumerator`: The enumerator block.
    ///
    /// # Safety
    ///
    /// `enumerator` must be a valid pointer.
    #[doc(alias = "nw_browse_result_enumerate_interfaces")]
    #[inline]
    pub unsafe fn enumerate_interfaces(&self, enumerator: nw_browse_result_enumerate_interface_t) {
        extern "C-unwind" {
            fn nw_browse_result_enumerate_interfaces(
                result: &NWBrowseResult,
                enumerator: nw_browse_result_enumerate_interface_t,
            );
        }
        unsafe { nw_browse_result_enumerate_interfaces(self, enumerator) }
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_error?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_error: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_error_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_error_t = NSObject;

/// The enumeration of network error domains.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_error_domain_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_error_domain_t(pub c_uint);
impl nw_error_domain_t {
    #[doc(alias = "nw_error_domain_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_error_domain_posix")]
    pub const posix: Self = Self(1);
    #[doc(alias = "nw_error_domain_dns")]
    pub const dns: Self = Self(2);
    #[doc(alias = "nw_error_domain_tls")]
    pub const tls: Self = Self(3);
    #[doc(alias = "nw_error_domain_wifi_aware")]
    pub const wifi_aware: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_error_domain_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_error_domain_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWError {
    /// Given a reference to a nw_error, returns the error domain.
    ///
    ///
    /// Parameter `error`: A reference to the nw_error.
    ///
    ///
    /// Returns: The error domain.
    #[doc(alias = "nw_error_get_error_domain")]
    #[inline]
    pub fn error_domain(&self) -> nw_error_domain_t {
        extern "C-unwind" {
            fn nw_error_get_error_domain(error: &NWError) -> nw_error_domain_t;
        }
        unsafe { nw_error_get_error_domain(self) }
    }

    /// Given a reference to a nw_error, returns the error code.
    ///
    ///
    /// Parameter `error`: A reference to the nw_error.
    ///
    ///
    /// Returns: The error code.
    #[doc(alias = "nw_error_get_error_code")]
    #[inline]
    pub fn error_code(&self) -> c_int {
        extern "C-unwind" {
            fn nw_error_get_error_code(error: &NWError) -> c_int;
        }
        unsafe { nw_error_get_error_code(self) }
    }
}

extern "C" {
    /// CFErrorRef domain corresponding to nw_error_domain_posix.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/network/knwerrordomainposix?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kNWErrorDomainPOSIX: &'static CFString;
}

extern "C" {
    /// CFErrorRef domain corresponding to nw_error_domain_posix.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/network/knwerrordomaindns?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kNWErrorDomainDNS: &'static CFString;
}

extern "C" {
    /// CFErrorRef domain corresponding to nw_error_domain_tls.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/network/knwerrordomaintls?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kNWErrorDomainTLS: &'static CFString;
}

extern "C" {
    /// CFErrorRef domain corresponding to nw_error_domain_wifi_aware.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/network/knwerrordomainwifiaware?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kNWErrorDomainWiFiAware: &'static CFString;
}

impl NWError {
    /// Given a reference to nw_error, returns a CFErrorRef representing the same error.
    ///
    ///
    /// Parameter `error`: A reference to the nw_error.
    ///
    ///
    /// Returns: The CFErrorRef. The caller is responsible for calling CFRelease on the returned value.
    #[doc(alias = "nw_error_copy_cf_error")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub fn cf_error(&self) -> CFRetained<CFError> {
        extern "C-unwind" {
            fn nw_error_copy_cf_error(error: &NWError) -> Option<NonNull<CFError>>;
        }
        let ret = unsafe { nw_error_copy_cf_error(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_browser?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_browser: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_browser_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_browser_t = NSObject;

/// Browser states sent by nw_browser_set_state_changed_handler.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_browser_state_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_browser_state_t(pub c_uint);
impl nw_browser_state_t {
    /// This state will never be delivered in the browser's state update
    /// handler and can be treated as an unexpected value.
    #[doc(alias = "nw_browser_state_invalid")]
    pub const invalid: Self = Self(0);
    /// endpoint updates. All callbacks from the browse_results_changed_handler
    /// occur when the browser is in this state.
    #[doc(alias = "nw_browser_state_ready")]
    pub const ready: Self = Self(1);
    /// You should not try to call nw_browser_start() on the browser to restart
    /// it. Instead, cancel the browser and create a new browser object.
    #[doc(alias = "nw_browser_state_failed")]
    pub const failed: Self = Self(2);
    /// the caller. You should not try to call nw_browser_start() on the
    /// browser to restart it. Instead, create a new browser object.
    #[doc(alias = "nw_browser_state_cancelled")]
    pub const cancelled: Self = Self(3);
    /// Results will not be delivered until the browser moves into the ready
    /// state. A browser can move from the ready state into the waiting state.
    /// The associated error indicates why the browser is unable to browse.
    #[doc(alias = "nw_browser_state_waiting")]
    pub const waiting: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_browser_state_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_browser_state_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWBrowser {
    /// Creates a new browser object, which can be used to browse for results
    /// matching a browse descriptor.
    ///
    ///
    /// Parameter `descriptor`: A browse descriptor object that describes the type of service for which
    /// to browse.
    ///
    ///
    /// Parameter `parameters`: Optional parameters to use for the new browser. If NULL, an empty parameters
    /// object is created internally.
    ///
    ///
    /// Returns: An instantiated browser object.
    #[doc(alias = "nw_browser_create")]
    #[inline]
    pub fn new(
        descriptor: &NWBrowseDescriptor,
        parameters: Option<&NWParameters>,
    ) -> NWRetained<NWBrowser> {
        extern "C-unwind" {
            fn nw_browser_create(
                descriptor: &NWBrowseDescriptor,
                parameters: Option<&NWParameters>,
            ) -> Option<NonNull<NWBrowser>>;
        }
        let ret = unsafe { nw_browser_create(descriptor, parameters) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Sets the client callback queue, on which blocks for events will
    /// be scheduled. This must be done before calling nw_browser_start().
    ///
    ///
    /// Parameter `browser`: The browser object.
    ///
    ///
    /// Parameter `queue`: The client's callback queue.
    #[doc(alias = "nw_browser_set_queue")]
    #[inline]
    pub fn set_queue(&self, queue: &DispatchQueue) {
        extern "C-unwind" {
            fn nw_browser_set_queue(browser: &NWBrowser, queue: &DispatchQueue);
        }
        unsafe { nw_browser_set_queue(self, queue) }
    }
}

/// A block called to notify the user of any browse results that changed. To get
/// the specific list of changes that occurred, call nw_browse_result_get_changes()
/// with the old and new result.
///
///
/// Parameter `old_result`: The old value of the browse result. This value was previously provided to
/// an invocation of the browse_results_changed_handler().
///
///
/// Parameter `new_result`: The new value of the browse result. This is a new instance of the result
/// and replaces old_result.
///
///
/// Parameter `batch_complete`: A flag indicating if this is the last change in this batch. If
/// batch_complete is true, the browser has no more immediate changes to
/// report to the user, who should perform any pending UI updates. If
/// batch_complete is false, the browser has more updates queued, which will
/// be delivered in subsequent invocations of the browse_results_changed_handler().
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_browser_browse_results_changed_handler_t?language=objc)
pub type nw_browser_browse_results_changed_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWBrowseResult>, NonNull<NWBrowseResult>, bool)>;

impl NWBrowser {
    /// Sets a callback handler to be invoked when the browser gets an update
    /// for changed browse results. This function must be called before starting
    /// the browser and must not be called after starting the browser.
    ///
    ///
    /// Parameter `browser`: The browser object.
    ///
    ///
    /// Parameter `handler`: The callback handler that fires when the browser gets an update for a
    /// changed browse result.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_browser_set_browse_results_changed_handler")]
    #[inline]
    pub unsafe fn set_browse_results_changed_handler(
        &self,
        handler: nw_browser_browse_results_changed_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_browser_set_browse_results_changed_handler(
                browser: &NWBrowser,
                handler: nw_browser_browse_results_changed_handler_t,
            );
        }
        unsafe { nw_browser_set_browse_results_changed_handler(self, handler) }
    }
}

/// A block called when the browser changes state.
///
///
/// Parameter `state`: The new state of the browser.
///
///
/// Parameter `error`: An optional error that is associated with the new state. For example, if the
/// browser encounters a DNS error, the callback will pass nw_browser_state_failed
/// as the new state and the DNS error as the error.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_browser_state_changed_handler_t?language=objc)
pub type nw_browser_state_changed_handler_t =
    *mut block2::DynBlock<dyn Fn(nw_browser_state_t, *mut NWError)>;

impl NWBrowser {
    /// Sets the state changed handler. For clients that need to perform cleanup
    /// when the browser has been cancelled, the nw_browser_state_cancelled state
    /// will be delivered last. This function must be called before starting the
    /// browser and must not be called after starting the browser.
    ///
    ///
    /// Parameter `browser`: The browser object.
    ///
    ///
    /// Parameter `state_changed_handler`: The state changed handler to call when the browser state changes.
    /// Pass NULL to remove the event handler.
    ///
    /// # Safety
    ///
    /// `state_changed_handler` must be a valid pointer or null.
    #[doc(alias = "nw_browser_set_state_changed_handler")]
    #[inline]
    pub unsafe fn set_state_changed_handler(
        &self,
        state_changed_handler: nw_browser_state_changed_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_browser_set_state_changed_handler(
                browser: &NWBrowser,
                state_changed_handler: nw_browser_state_changed_handler_t,
            );
        }
        unsafe { nw_browser_set_state_changed_handler(self, state_changed_handler) }
    }

    /// Starts the browser, which begins browsing for available endpoints.
    /// You must call nw_browser_set_queue() before starting the browser.
    ///
    ///
    /// Parameter `browser`: The browser object.
    #[doc(alias = "nw_browser_start")]
    #[inline]
    pub fn start(&self) {
        extern "C-unwind" {
            fn nw_browser_start(browser: &NWBrowser);
        }
        unsafe { nw_browser_start(self) }
    }

    /// Cancels the browser. The process of cancellation will be completed
    /// asynchronously, and the final callback event delivered to the caller
    /// will be a state update with a value of nw_browser_state_cancelled.
    /// Once this update is delivered, the caller may clean up any associated
    /// memory or objects.
    ///
    ///
    /// Parameter `browser`: The browser object.
    #[doc(alias = "nw_browser_cancel")]
    #[inline]
    pub fn cancel(&self) {
        extern "C-unwind" {
            fn nw_browser_cancel(browser: &NWBrowser);
        }
        unsafe { nw_browser_cancel(self) }
    }

    /// Returns a copy of the parameters passed to nw_browser_create().
    ///
    ///
    /// Parameter `browser`: The browser object.
    ///
    ///
    /// Returns: Returns an nw_parameters_t object.
    #[doc(alias = "nw_browser_copy_parameters")]
    #[inline]
    pub fn parameters(&self) -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_browser_copy_parameters(browser: &NWBrowser) -> Option<NonNull<NWParameters>>;
        }
        let ret = unsafe { nw_browser_copy_parameters(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Returns a copy of the browse_descriptor passed to nw_browser_create().
    ///
    ///
    /// Parameter `browser`: The browser object.
    ///
    ///
    /// Returns: Returns a copy of the browse_descriptor passed to nw_browser_create().
    #[doc(alias = "nw_browser_copy_browse_descriptor")]
    #[inline]
    pub fn browse_descriptor(&self) -> NWRetained<NWBrowseDescriptor> {
        extern "C-unwind" {
            fn nw_browser_copy_browse_descriptor(
                browser: &NWBrowser,
            ) -> Option<NonNull<NWBrowseDescriptor>>;
        }
        let ret = unsafe { nw_browser_copy_browse_descriptor(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_path?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_path: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_path_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_path_t = NSObject;

/// A network path status indicates if there is a usable route available upon which to
/// send and receive data.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_path_status_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_path_status_t(pub c_uint);
impl nw_path_status_t {
    #[doc(alias = "nw_path_status_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_path_status_satisfied")]
    pub const satisfied: Self = Self(1);
    #[doc(alias = "nw_path_status_unsatisfied")]
    pub const unsatisfied: Self = Self(2);
    #[doc(alias = "nw_path_status_satisfiable")]
    pub const satisfiable: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_path_status_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_path_status_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWPath {
    /// Retrieves the status of a path. The status of a specific path object will never
    /// change, as the path object itself is static. If there is a network change, the
    /// object that generated the path object will generate a new path object.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns the status of the path, or nw_path_status_invalid if the object is NULL.
    #[doc(alias = "nw_path_get_status")]
    #[inline]
    pub fn status(&self) -> nw_path_status_t {
        extern "C-unwind" {
            fn nw_path_get_status(path: &NWPath) -> nw_path_status_t;
        }
        unsafe { nw_path_get_status(self) }
    }
}

/// A network path unsatisfied reason may indicate the reason the path is currently unsatisfied for some conditions.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_path_unsatisfied_reason_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_path_unsatisfied_reason_t(pub c_uint);
impl nw_path_unsatisfied_reason_t {
    #[doc(alias = "nw_path_unsatisfied_reason_not_available")]
    pub const not_available: Self = Self(0);
    #[doc(alias = "nw_path_unsatisfied_reason_cellular_denied")]
    pub const cellular_denied: Self = Self(1);
    #[doc(alias = "nw_path_unsatisfied_reason_wifi_denied")]
    pub const wifi_denied: Self = Self(2);
    #[doc(alias = "nw_path_unsatisfied_reason_local_network_denied")]
    pub const local_network_denied: Self = Self(3);
    #[doc(alias = "nw_path_unsatisfied_reason_vpn_inactive")]
    pub const vpn_inactive: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_path_unsatisfied_reason_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_path_unsatisfied_reason_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWPath {
    /// Retrieves a reason the path is not satisfied. In some cases, the reason helps to
    /// determine why the path is not satisfied. While the path may be unsatisfied for more
    /// than one reason, only the first reason will be given. In many cases, the path may be
    /// unsatisfied with no reason available.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns a reason the path is unsatisfied or nw_path_unsatisfied_reason_not_available if a reason is not available.
    #[doc(alias = "nw_path_get_unsatisfied_reason")]
    #[inline]
    pub fn unsatisfied_reason(&self) -> nw_path_unsatisfied_reason_t {
        extern "C-unwind" {
            fn nw_path_get_unsatisfied_reason(path: &NWPath) -> nw_path_unsatisfied_reason_t;
        }
        unsafe { nw_path_get_unsatisfied_reason(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_path_enumerate_interfaces_block_t?language=objc)
pub type nw_path_enumerate_interfaces_block_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWInterface>) -> bool>;

impl NWPath {
    /// List all interfaces associated with the path.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Parameter `enumerate_block`: A block that will return the interfaces associated with the path. Returning
    /// true from the block will continue to enumerate, and returning false will stop
    /// enumerating.
    ///
    /// # Safety
    ///
    /// `enumerate_block` must be a valid pointer.
    #[doc(alias = "nw_path_enumerate_interfaces")]
    #[inline]
    pub unsafe fn enumerate_interfaces(
        &self,
        enumerate_block: nw_path_enumerate_interfaces_block_t,
    ) {
        extern "C-unwind" {
            fn nw_path_enumerate_interfaces(
                path: &NWPath,
                enumerate_block: nw_path_enumerate_interfaces_block_t,
            );
        }
        unsafe { nw_path_enumerate_interfaces(self, enumerate_block) }
    }

    /// Compares two network path objects and checks if their content is equal.
    /// If they are not equal, they represent two different network states.
    ///
    ///
    /// Parameter `path`: The first path object to compare.
    ///
    ///
    /// Parameter `other_path`: The second path object to compare.
    ///
    ///
    /// Returns: Returns true if the paths are equivalent, or false if there is any difference
    /// between the paths.
    #[doc(alias = "nw_path_is_equal")]
    #[inline]
    pub fn is_equal(&self, other_path: &NWPath) -> bool {
        extern "C-unwind" {
            fn nw_path_is_equal(path: &NWPath, other_path: &NWPath) -> bool;
        }
        unsafe { nw_path_is_equal(self, other_path) }
    }

    /// Checks if the path uses any network interfaces that are considered expensive
    /// to the user, such as, but not limited to, a cellular network.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns true if the path uses any network interface that is considered expensive,
    /// false otherwise.
    #[doc(alias = "nw_path_is_expensive")]
    #[inline]
    pub fn is_expensive(&self) -> bool {
        extern "C-unwind" {
            fn nw_path_is_expensive(path: &NWPath) -> bool;
        }
        unsafe { nw_path_is_expensive(self) }
    }

    /// Checks if the path uses any network interfaces that are considered constrained
    /// to the user.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns true if the path uses any network interface that is considered constrained,
    /// false otherwise.
    #[doc(alias = "nw_path_is_constrained")]
    #[inline]
    pub fn is_constrained(&self) -> bool {
        extern "C-unwind" {
            fn nw_path_is_constrained(path: &NWPath) -> bool;
        }
        unsafe { nw_path_is_constrained(self) }
    }

    /// Checks if the path uses any network interfaces that are considered ultra-constrained.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns true if the path uses any network interface that is considered ultra-constrained,
    /// false otherwise.
    #[doc(alias = "nw_path_is_ultra_constrained")]
    #[inline]
    pub fn is_ultra_constrained(&self) -> bool {
        extern "C-unwind" {
            fn nw_path_is_ultra_constrained(path: &NWPath) -> bool;
        }
        unsafe { nw_path_is_ultra_constrained(self) }
    }

    /// Checks if the path uses a network interface that supports IPv4 connectivity.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns true if the path uses a network interface that supports IPv4,
    /// false otherwise.
    #[doc(alias = "nw_path_has_ipv4")]
    #[inline]
    pub fn has_ipv4(&self) -> bool {
        extern "C-unwind" {
            fn nw_path_has_ipv4(path: &NWPath) -> bool;
        }
        unsafe { nw_path_has_ipv4(self) }
    }

    /// Checks if the path uses a network interface that supports IPv6 connectivity.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns true if the path uses a network interface that supports IPv6,
    /// false otherwise.
    #[doc(alias = "nw_path_has_ipv6")]
    #[inline]
    pub fn has_ipv6(&self) -> bool {
        extern "C-unwind" {
            fn nw_path_has_ipv6(path: &NWPath) -> bool;
        }
        unsafe { nw_path_has_ipv6(self) }
    }

    /// Checks if the path has a DNS server configuration set.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns true if the path has a DNS server configuration set,
    /// false otherwise.
    #[doc(alias = "nw_path_has_dns")]
    #[inline]
    pub fn has_dns(&self) -> bool {
        extern "C-unwind" {
            fn nw_path_has_dns(path: &NWPath) -> bool;
        }
        unsafe { nw_path_has_dns(self) }
    }

    /// Checks if the path uses a network interface with the specified type.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns true if the path uses any network interface with the specified type,
    /// false otherwise.
    #[doc(alias = "nw_path_uses_interface_type")]
    #[inline]
    pub fn uses_interface_type(&self, interface_type: nw_interface_type_t) -> bool {
        extern "C-unwind" {
            fn nw_path_uses_interface_type(
                path: &NWPath,
                interface_type: nw_interface_type_t,
            ) -> bool;
        }
        unsafe { nw_path_uses_interface_type(self, interface_type) }
    }

    /// Retrieve the local endpoint that is being used, if present. If this path
    /// is the path from an nw_connection_t, it represents the address that data
    /// is sent from.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns an endpoint that is assigned as the local endpoint for this path,
    /// or NULL if the path does not have a fixed local endpoint.
    #[doc(alias = "nw_path_copy_effective_local_endpoint")]
    #[inline]
    pub fn effective_local_endpoint(&self) -> Option<NWRetained<NWEndpoint>> {
        extern "C-unwind" {
            fn nw_path_copy_effective_local_endpoint(path: &NWPath) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_path_copy_effective_local_endpoint(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Retrieve the remote endpoint that is being used, if present. If this path
    /// is the path from an nw_connection_t, it represents the address that data
    /// is sent to.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns an endpoint that is assigned as the remote endpoint for this path,
    /// or NULL if the path does not have a fixed remote endpoint.
    #[doc(alias = "nw_path_copy_effective_remote_endpoint")]
    #[inline]
    pub fn effective_remote_endpoint(&self) -> Option<NWRetained<NWEndpoint>> {
        extern "C-unwind" {
            fn nw_path_copy_effective_remote_endpoint(path: &NWPath)
                -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_path_copy_effective_remote_endpoint(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_path_enumerate_gateways_block_t?language=objc)
pub type nw_path_enumerate_gateways_block_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWEndpoint>) -> bool>;

impl NWPath {
    /// List the IP addresses of the routers acting as the gateways for the path.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Parameter `enumerate_block`: A block that will return the gateways associated with the path. Returning
    /// true from the block will continue to enumerate, and returning false will stop
    /// enumerating.
    ///
    /// # Safety
    ///
    /// `enumerate_block` must be a valid pointer.
    #[doc(alias = "nw_path_enumerate_gateways")]
    #[inline]
    pub unsafe fn enumerate_gateways(&self, enumerate_block: nw_path_enumerate_gateways_block_t) {
        extern "C-unwind" {
            fn nw_path_enumerate_gateways(
                path: &NWPath,
                enumerate_block: nw_path_enumerate_gateways_block_t,
            );
        }
        unsafe { nw_path_enumerate_gateways(self, enumerate_block) }
    }
}

/// Link quality measurement is a representation of the expected capabilities of the link layer network
/// attachment. Use this value to tune initial values for algorithms that can scale with the
/// capabilities of the network. Do not use this value to gate connection attempts or to override
/// adjustments that would be made based on actual network performance.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_link_quality_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_link_quality_t(pub c_uint);
impl nw_link_quality_t {
    #[doc(alias = "nw_link_quality_unknown")]
    pub const unknown: Self = Self(0);
    #[doc(alias = "nw_link_quality_minimal")]
    pub const minimal: Self = Self(10);
    #[doc(alias = "nw_link_quality_moderate")]
    pub const moderate: Self = Self(20);
    #[doc(alias = "nw_link_quality_good")]
    pub const good: Self = Self(30);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_link_quality_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_link_quality_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWPath {
    /// Fetches the link quality measurement for the interface.
    /// Link quality measurement is a representation of the expected capabilities of the link layer network
    /// attachment. Use this value to tune initial values for algorithms that can scale with the
    /// capabilities of the network. Do not use this value to gate connection attempts or to override
    /// adjustments that would be made based on actual network performance.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns the link quality measurement of the link layer network attachment.
    /// Returns nw_link_quality_unknown if there is no measurement available.
    #[doc(alias = "nw_path_get_link_quality")]
    #[inline]
    pub fn link_quality(&self) -> nw_link_quality_t {
        extern "C-unwind" {
            fn nw_path_get_link_quality(path: &NWPath) -> nw_link_quality_t;
        }
        unsafe { nw_path_get_link_quality(self) }
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_content_context?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_content_context: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_content_context_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_content_context_t = NSObject;

impl NWContentContext {
    /// Create a context object to represent properties associated with
    /// networking content. If the same context object is associated with multiple
    /// content blobs, then those pieces of content will be considered to be continuations
    /// of the same message.
    ///
    /// Parameter `context_identifier`: A string description of the context
    ///
    /// Returns: Returns a new context context object
    ///
    /// # Safety
    ///
    /// `context_identifier` must be a valid pointer.
    #[doc(alias = "nw_content_context_create")]
    #[inline]
    pub unsafe fn new(context_identifier: NonNull<c_char>) -> NWRetained<NWContentContext> {
        extern "C-unwind" {
            fn nw_content_context_create(
                context_identifier: NonNull<c_char>,
            ) -> Option<NonNull<NWContentContext>>;
        }
        let ret = unsafe { nw_content_context_create(context_identifier) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Access the identifier description.
    ///
    /// Returns: Returns the context's identifier string.
    #[doc(alias = "nw_content_context_get_identifier")]
    #[inline]
    pub fn identifier(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_content_context_get_identifier(
                context: &NWContentContext,
            ) -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_content_context_get_identifier(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Check if this is the final context for a connection. When receiving,
    /// once a final context is complete, the connection is "read closed" and will not
    /// receive more content. See nw_content_context_set_is_final() for a description
    /// of how to set is_final for sending contexts.
    ///
    /// Parameter `context`: The context object
    ///
    /// Returns: Returns true if the context is the final context for a connection.
    #[doc(alias = "nw_content_context_get_is_final")]
    #[inline]
    pub fn is_final(&self) -> bool {
        extern "C-unwind" {
            fn nw_content_context_get_is_final(context: &NWContentContext) -> bool;
        }
        unsafe { nw_content_context_get_is_final(self) }
    }

    /// Mark whether or not this context is the final context for a
    /// connection. When sending, marking a context as final will perform
    /// a "write close" once the context is complete, indicating that no more content
    /// will be sent. As a convenience for sending a final context, use
    /// NW_CONNECTION_FINAL_MESSAGE_CONTEXT.
    ///
    /// Parameter `context`: The context object
    ///
    /// Parameter `is_final`: If set to true, mark the context as the final context to send on a connection.
    #[doc(alias = "nw_content_context_set_is_final")]
    #[inline]
    pub fn set_is_final(&self, is_final: bool) {
        extern "C-unwind" {
            fn nw_content_context_set_is_final(context: &NWContentContext, is_final: bool);
        }
        unsafe { nw_content_context_set_is_final(self, is_final) }
    }

    /// Retrieve the number of milliseconds after which the content will expire.
    /// See nw_content_context_set_expiration_milliseconds for further discussion.
    ///
    /// Parameter `context`: The context object
    ///
    /// Returns: Returns content expiration, or 0 if not set.
    #[doc(alias = "nw_content_context_get_expiration_milliseconds")]
    #[inline]
    pub fn expiration_milliseconds(&self) -> u64 {
        extern "C-unwind" {
            fn nw_content_context_get_expiration_milliseconds(context: &NWContentContext) -> u64;
        }
        unsafe { nw_content_context_get_expiration_milliseconds(self) }
    }

    /// Set an expiration (in milliseconds) after which content may be dropped.
    /// If the expiration time is reached, the content may not be sent. If the value is
    /// 0, there is no expiration for the content. The expiration timer starts when the
    /// content is enqueued using nw_connection_send().
    ///
    /// Parameter `context`: The context object
    ///
    /// Parameter `expiration_milliseconds`: The number of milliseconds after which content will expire
    #[doc(alias = "nw_content_context_set_expiration_milliseconds")]
    #[inline]
    pub fn set_expiration_milliseconds(&self, expiration_milliseconds: u64) {
        extern "C-unwind" {
            fn nw_content_context_set_expiration_milliseconds(
                context: &NWContentContext,
                expiration_milliseconds: u64,
            );
        }
        unsafe { nw_content_context_set_expiration_milliseconds(self, expiration_milliseconds) }
    }

    /// Get the relative priority for the content. See
    /// nw_content_context_set_relative_priority for further discussion.
    ///
    /// Parameter `context`: The context object
    ///
    /// Returns: Returns the relative priority, between 0.0 (lowest priority)
    /// to 1.0 (highest priority). The default value is 0.5.
    #[doc(alias = "nw_content_context_get_relative_priority")]
    #[inline]
    pub fn relative_priority(&self) -> c_double {
        extern "C-unwind" {
            fn nw_content_context_get_relative_priority(context: &NWContentContext) -> c_double;
        }
        unsafe { nw_content_context_get_relative_priority(self) }
    }

    /// Set A relative priority of the content, compared to other
    /// content on the same connection. Priorities range from 0.0 (lowest
    /// priority) to 1.0 (highest priority), where content with higher
    /// priority will scheduled first if all else is equal.
    /// The default value is 0.5.
    ///
    /// Parameter `context`: The context object
    ///
    /// Parameter `relative_priority`: The relative priority of the content, between
    /// 0.0 (lowest priority) to 1.0 (highest priority).
    #[doc(alias = "nw_content_context_set_relative_priority")]
    #[inline]
    pub fn set_relative_priority(&self, relative_priority: c_double) {
        extern "C-unwind" {
            fn nw_content_context_set_relative_priority(
                context: &NWContentContext,
                relative_priority: c_double,
            );
        }
        unsafe { nw_content_context_set_relative_priority(self, relative_priority) }
    }

    /// Set a context as an antecedent to this content context.
    /// The associated content will not be sent until all of its antecedents have been
    /// completed. If any of the antecedents fail with an error, this content will
    /// fail as well.
    ///
    /// Parameter `context`: The context object
    ///
    /// Parameter `antecedent_context`: A context associated with content that should precede
    /// this content.
    #[doc(alias = "nw_content_context_set_antecedent")]
    #[inline]
    pub fn set_antecedent(&self, antecedent_context: Option<&NWContentContext>) {
        extern "C-unwind" {
            fn nw_content_context_set_antecedent(
                context: &NWContentContext,
                antecedent_context: Option<&NWContentContext>,
            );
        }
        unsafe { nw_content_context_set_antecedent(self, antecedent_context) }
    }

    /// Copy the optional content context that must be sent prior to this
    /// content. See nw_content_context_set_antecedent for further discussion.
    ///
    /// Parameter `context`: The context object
    ///
    /// Returns: Returns a context object set as the antecedent, or NULL.
    #[doc(alias = "nw_content_context_copy_antecedent")]
    #[inline]
    pub fn antecedent(&self) -> Option<NWRetained<NWContentContext>> {
        extern "C-unwind" {
            fn nw_content_context_copy_antecedent(
                context: &NWContentContext,
            ) -> Option<NonNull<NWContentContext>>;
        }
        let ret = unsafe { nw_content_context_copy_antecedent(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Set protocol-specific metadata to a parent content context. If
    /// metadata for the same protocol is set multiple times, the most recently
    /// set metadata will be applied.
    ///
    /// Parameter `context`: The context context parent object
    ///
    /// Parameter `protocol_metadata`: The per-protocol metadata context object to set
    #[doc(alias = "nw_content_context_set_metadata_for_protocol")]
    #[inline]
    pub fn set_metadata_for_protocol(&self, protocol_metadata: &NWProtocolMetadata) {
        extern "C-unwind" {
            fn nw_content_context_set_metadata_for_protocol(
                context: &NWContentContext,
                protocol_metadata: &NWProtocolMetadata,
            );
        }
        unsafe { nw_content_context_set_metadata_for_protocol(self, protocol_metadata) }
    }

    /// Copy the per-protocol metadata from a parent content context
    ///
    /// Parameter `context`: The context context parent object
    ///
    /// Parameter `protocol`: The definition identifier of the protocol to retrieve metadata for
    ///
    /// Returns: Returns the metadata registered for the protocol, or NULL if there is none
    #[doc(alias = "nw_content_context_copy_protocol_metadata")]
    #[inline]
    pub fn protocol_metadata(
        &self,
        protocol: &NWProtocolDefinition,
    ) -> Option<NWRetained<NWProtocolMetadata>> {
        extern "C-unwind" {
            fn nw_content_context_copy_protocol_metadata(
                context: &NWContentContext,
                protocol: &NWProtocolDefinition,
            ) -> Option<NonNull<NWProtocolMetadata>>;
        }
        let ret = unsafe { nw_content_context_copy_protocol_metadata(self, protocol) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Access all per-protocol metadata objects from a parent content context
    ///
    /// Parameter `context`: The context context parent object
    ///
    /// Parameter `foreach_block`: A block in which protocol definition and metadata will be sent
    #[doc(alias = "nw_content_context_foreach_protocol_metadata")]
    #[inline]
    pub fn foreach_protocol_metadata(
        &self,
        foreach_block: &block2::DynBlock<
            dyn Fn(NonNull<NWProtocolDefinition>, NonNull<NWProtocolMetadata>),
        >,
    ) {
        extern "C-unwind" {
            fn nw_content_context_foreach_protocol_metadata(
                context: &NWContentContext,
                foreach_block: &block2::DynBlock<
                    dyn Fn(NonNull<NWProtocolDefinition>, NonNull<NWProtocolMetadata>),
                >,
            );
        }
        unsafe { nw_content_context_foreach_protocol_metadata(self, foreach_block) }
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_connection?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_connection: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_connection_t = NSObject;

/// Connection states sent by nw_connection_set_state_changed_handler.
/// States generally progress forward and do not move backwards, with the
/// exception of preparing and waiting, which may alternate before the connection
/// becomes ready or failed.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_state_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_connection_state_t(pub c_uint);
impl nw_connection_state_t {
    /// will never be delivered in the connection's state update handler, and can be treated as
    /// an unexpected value.
    #[doc(alias = "nw_connection_state_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_connection_state_waiting")]
    pub const waiting: Self = Self(1);
    #[doc(alias = "nw_connection_state_preparing")]
    pub const preparing: Self = Self(2);
    #[doc(alias = "nw_connection_state_ready")]
    pub const ready: Self = Self(3);
    #[doc(alias = "nw_connection_state_failed")]
    pub const failed: Self = Self(4);
    #[doc(alias = "nw_connection_state_cancelled")]
    pub const cancelled: Self = Self(5);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_connection_state_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_connection_state_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWConnection {
    /// Creates a networking connection to an endpoint.
    ///
    ///
    /// Parameter `endpoint`: The remote endpoint to connect to.
    ///
    ///
    /// Parameter `parameters`: The parameters to use for the connection. The data mode,
    /// either datagram or stream, must be set.
    ///
    ///
    /// Returns: Returns an allocated nw_connection_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_connection_create")]
    #[inline]
    pub fn new(endpoint: &NWEndpoint, parameters: &NWParameters) -> NWRetained<NWConnection> {
        extern "C-unwind" {
            fn nw_connection_create(
                endpoint: &NWEndpoint,
                parameters: &NWParameters,
            ) -> Option<NonNull<NWConnection>>;
        }
        let ret = unsafe { nw_connection_create(endpoint, parameters) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Retrieves the remote endpoint for a connection.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Returns: Returns an nw_endpoint_t object on success.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_connection_copy_endpoint")]
    #[inline]
    pub fn endpoint(&self) -> NWRetained<NWEndpoint> {
        extern "C-unwind" {
            fn nw_connection_copy_endpoint(
                connection: &NWConnection,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_connection_copy_endpoint(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Retrieves the parameters for a connection.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Returns: Returns an nw_parameters_t object on success.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_connection_copy_parameters")]
    #[inline]
    pub fn parameters(&self) -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_connection_copy_parameters(
                connection: &NWConnection,
            ) -> Option<NonNull<NWParameters>>;
        }
        let ret = unsafe { nw_connection_copy_parameters(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_state_changed_handler_t?language=objc)
pub type nw_connection_state_changed_handler_t =
    *mut block2::DynBlock<dyn Fn(nw_connection_state_t, *mut NWError)>;

impl NWConnection {
    /// Sets the state change handler. For clients that need to perform cleanup when the
    /// connection has been cancelled, the nw_connection_state_cancelled state will
    /// be delivered last.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Parameter `handler`: The state changed handler to call when the connection state changes.
    /// Pass NULL to remove the state changed handler.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_connection_set_state_changed_handler")]
    #[inline]
    pub unsafe fn set_state_changed_handler(&self, handler: nw_connection_state_changed_handler_t) {
        extern "C-unwind" {
            fn nw_connection_set_state_changed_handler(
                connection: &NWConnection,
                handler: nw_connection_state_changed_handler_t,
            );
        }
        unsafe { nw_connection_set_state_changed_handler(self, handler) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_boolean_event_handler_t?language=objc)
pub type nw_connection_boolean_event_handler_t = *mut block2::DynBlock<dyn Fn(bool)>;

impl NWConnection {
    /// Define a callback to be fired when the viability of the connection changes.
    /// This indicates whether or not read and write calls will succeed on a ready
    /// connection.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Parameter `handler`: The event handler to call when the connection viability changes. The value will
    /// be true when the connection is viable, and false otherwise.
    /// Pass NULL to remove the event handler.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_connection_set_viability_changed_handler")]
    #[inline]
    pub unsafe fn set_viability_changed_handler(
        &self,
        handler: nw_connection_boolean_event_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_connection_set_viability_changed_handler(
                connection: &NWConnection,
                handler: nw_connection_boolean_event_handler_t,
            );
        }
        unsafe { nw_connection_set_viability_changed_handler(self, handler) }
    }

    /// Define a callback to be fired when a better path is available or not.
    /// This indicates whether or not a preferred path is available for the
    /// connection.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Parameter `handler`: The event handler to call when the better path availability changes. The value
    /// will be true when a better path is available, and false otherwise.
    /// Pass NULL to remove the event handler.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_connection_set_better_path_available_handler")]
    #[inline]
    pub unsafe fn set_better_path_available_handler(
        &self,
        handler: nw_connection_boolean_event_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_connection_set_better_path_available_handler(
                connection: &NWConnection,
                handler: nw_connection_boolean_event_handler_t,
            );
        }
        unsafe { nw_connection_set_better_path_available_handler(self, handler) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_path_event_handler_t?language=objc)
pub type nw_connection_path_event_handler_t = *mut block2::DynBlock<dyn Fn(NonNull<NWPath>)>;

impl NWConnection {
    /// Define a callback to be fired when the connection's path changes.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Parameter `handler`: The event handler to call when the connection's path changes.
    /// Pass NULL to remove the event handler.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_connection_set_path_changed_handler")]
    #[inline]
    pub unsafe fn set_path_changed_handler(&self, handler: nw_connection_path_event_handler_t) {
        extern "C-unwind" {
            fn nw_connection_set_path_changed_handler(
                connection: &NWConnection,
                handler: nw_connection_path_event_handler_t,
            );
        }
        unsafe { nw_connection_set_path_changed_handler(self, handler) }
    }

    /// Sets the client callback queue, on which blocks for events will
    /// be scheduled. This must be done before calling nw_connection_start().
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Parameter `queue`: The client's dispatch queue.
    #[doc(alias = "nw_connection_set_queue")]
    #[inline]
    pub fn set_queue(&self, queue: &DispatchQueue) {
        extern "C-unwind" {
            fn nw_connection_set_queue(connection: &NWConnection, queue: &DispatchQueue);
        }
        unsafe { nw_connection_set_queue(self, queue) }
    }

    /// Starts the connection, which will cause the connection
    /// to evaluate its path, do resolution, and try to become
    /// readable and writable. Once started, a connection
    /// must be cancelled using nw_connection_cancel() or
    /// nw_connection_force_cancel() when it is no longer needed.
    ///
    ///
    /// Parameter `connection`: The connection object.
    #[doc(alias = "nw_connection_start")]
    #[inline]
    pub fn start(&self) {
        extern "C-unwind" {
            fn nw_connection_start(connection: &NWConnection);
        }
        unsafe { nw_connection_start(self) }
    }

    /// Connections in the waiting state will normally re-attempt
    /// on network changes. Call nw_connection_restart() to force
    /// a connection in the waiting state to retry connection
    /// establishment even without a network change. Calls to restart
    /// for connections that are not in the waiting state will be
    /// ignored.
    ///
    ///
    /// Parameter `connection`: The connection object.
    #[doc(alias = "nw_connection_restart")]
    #[inline]
    pub fn restart(&self) {
        extern "C-unwind" {
            fn nw_connection_restart(connection: &NWConnection);
        }
        unsafe { nw_connection_restart(self) }
    }

    /// Cancel the connection. This will close the connection, and negotiate over the network
    /// if applicable for the protocol. The process of cancellation will be completed
    /// asynchronously, and the final callback event delivered to the caller will be a state
    /// update with a value of nw_connection_state_cancelled. Once this update is delivered, the
    /// caller may clean up any associated memory or objects.
    ///
    /// Outstanding sends and receives will receive errors before the state changes to cancelled.
    /// There is no guarantee that any outstanding sends that have not yet delivered send completion handlers
    /// will send data before the connection is closed.
    ///
    ///
    /// Parameter `connection`: The connection object.
    #[doc(alias = "nw_connection_cancel")]
    #[inline]
    pub fn cancel(&self) {
        extern "C-unwind" {
            fn nw_connection_cancel(connection: &NWConnection);
        }
        unsafe { nw_connection_cancel(self) }
    }

    /// A variant of nw_connection_cancel() that indicates that the protocol stack should
    /// not close gracefully, but close as quickly as possible without negotiation. For example,
    /// a force close would lead to TCP RST packets being sent, as opposed to negotiating with
    /// FIN packets.
    ///
    ///
    /// Parameter `connection`: The connection object.
    #[doc(alias = "nw_connection_force_cancel")]
    #[inline]
    pub fn force_cancel(&self) {
        extern "C-unwind" {
            fn nw_connection_force_cancel(connection: &NWConnection);
        }
        unsafe { nw_connection_force_cancel(self) }
    }

    /// Cancel the currently connected endpoint, causing the connection
    /// to fall through to the next endpoint if available, or fail if no
    /// more endpoints are available. This is primarily useful for connections
    /// which do not have reliable handshakes, such as UDP. If data is sent
    /// on the connection with no response, canceling the current endpoint
    /// will allow another address or interface to be attempted.
    ///
    ///
    /// Parameter `connection`: The connection object.
    #[doc(alias = "nw_connection_cancel_current_endpoint")]
    #[inline]
    pub fn cancel_current_endpoint(&self) {
        extern "C-unwind" {
            fn nw_connection_cancel_current_endpoint(connection: &NWConnection);
        }
        unsafe { nw_connection_cancel_current_endpoint(self) }
    }
}

/// A receive completion is invoked exactly once for a call to nw_connection_receive().
/// The completion indicates that the requested content has been received (in which case
/// the content is delivered), or else an error has occurred.
///
///
/// Parameter `content`: The received content, which has a length constrained by the call to nw_connection_receive().
/// The content may be NULL in two cases: (1) the receive context (logical message) is now complete,
/// and the callback is only delivering the completed event; or, (2) the connection encountered
/// an error and there is no data to deliver. Note that the content may be non-NULL even in the
/// case of an error if there was some data received before the error was encountered. The caller
/// should process all content it receives, and not necessarily ignore data in case of errors.
///
///
/// Parameter `context`: The context (logical message) associated with the received content. This includes protocol metadata
/// that lets the caller introspect information about the received content (such as flags on an IP packet).
/// When the message has been completely received, the context will be delivered along with the
/// is_complete flag.
///
/// For datagram protocols such as UDP, the context represents the properties of a single received
/// datagram.
///
/// For protocols that only have a single context for the entire connection, such as stream protocols
/// like TCP, the context will be marked as "final", which can be accessed with
/// nw_content_context_get_is_final(). Once a final context is marked as complete, the recipient
/// may assume that the connection has been closed in the receiving direction (a "read close"). For
/// TCP, this represents receiving a FIN.
///
///
/// Parameter `is_complete`: An indication that this context (logical message) is now complete. Until this flag is
/// set, the recipient should assume that there may be more bytes to read for this context.
/// Note that even when reading datagrams, as from UDP, the context may be read in multiple
/// chunks if the maximum_length was smaller than the full length of the message.
///
/// If is_complete is marked and the received context is the final context for connection,
/// the caller may assume that the connection has been closed in the receiving direction.
///
///
/// Parameter `error`: An error will be sent if an error was encountered while trying to receive on the connection.
/// There may still be content delivered along with the error, but this content may be shorter
/// than the requested ranges. An error will be sent for any outstanding receive calls when the
/// connection is cancelled.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_receive_completion_t?language=objc)
pub type nw_connection_receive_completion_t =
    *mut block2::DynBlock<dyn Fn(*mut DispatchData, *mut NWContentContext, bool, *mut NWError)>;

impl NWConnection {
    /// Receive data from a connection. This may be called before the connection
    /// is ready, in which case the receive request will be queued until the
    /// connection is ready. The completion handler will be invoked exactly
    /// once for each call, so the client must call this function multiple
    /// times to receive multiple chunks of data. For protocols that
    /// support flow control, such as TCP, calling receive opens the receive
    /// window. If the client stops calling receive, the receive window will
    /// fill up and the remote peer will stop sending.
    ///
    ///
    /// Parameter `connection`: The connection object on which to receive data. The connection should
    /// be in the ready state.
    ///
    ///
    /// Parameter `minimum_incomplete_length`: The minimum length to receive from the connection, until the content
    /// is complete. Content will be delivered when at least the minimum is available,
    /// or the content is complete, whichever comes first.
    ///
    ///
    /// Parameter `maximum_length`: The maximum length to receive from the connection.
    ///
    ///
    /// Parameter `completion`: A callback to be called when content has been received.
    ///
    /// # Safety
    ///
    /// `completion` must be a valid pointer.
    #[doc(alias = "nw_connection_receive")]
    #[inline]
    pub unsafe fn receive(
        &self,
        minimum_incomplete_length: u32,
        maximum_length: u32,
        completion: nw_connection_receive_completion_t,
    ) {
        extern "C-unwind" {
            fn nw_connection_receive(
                connection: &NWConnection,
                minimum_incomplete_length: u32,
                maximum_length: u32,
                completion: nw_connection_receive_completion_t,
            );
        }
        unsafe {
            nw_connection_receive(self, minimum_incomplete_length, maximum_length, completion)
        }
    }

    /// Receive a single atomic message from a connection. The completion
    /// handler will be invoked exactly once for each call, so the client
    /// must call this function multiple times to receive multiple messages.
    ///
    ///
    /// Parameter `connection`: The connection object on which to receive the message. The connection
    /// should be in the ready state.
    ///
    ///
    /// Parameter `completion`: A callback to be called when the message has been received, or an error
    /// has occurred.
    ///
    /// # Safety
    ///
    /// `completion` must be a valid pointer.
    #[doc(alias = "nw_connection_receive_message")]
    #[inline]
    pub unsafe fn receive_message(&self, completion: nw_connection_receive_completion_t) {
        extern "C-unwind" {
            fn nw_connection_receive_message(
                connection: &NWConnection,
                completion: nw_connection_receive_completion_t,
            );
        }
        unsafe { nw_connection_receive_message(self, completion) }
    }
}

/// A send completion is invoked exactly once for a call to nw_connection_send().
/// The completion indicates that the sent content has been processed by the stack
/// (not necessarily that it has left the host), or else an error has occurred during
/// sending.
///
///
/// Parameter `error`: An error will be sent if the associated content could not be fully sent before an
/// error occurred. An error will be sent for any outstanding sends when the connection
/// is cancelled.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_send_completion_t?language=objc)
pub type nw_connection_send_completion_t = *mut block2::DynBlock<dyn Fn(*mut NWError)>;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/network/_nw_connection_send_idempotent_content?language=objc)
    pub static _nw_connection_send_idempotent_content: nw_connection_send_completion_t;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/network/_nw_content_context_default_message?language=objc)
    pub static _nw_content_context_default_message: &'static NWContentContext;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/network/_nw_content_context_final_send?language=objc)
    pub static _nw_content_context_final_send: &'static NWContentContext;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/network/_nw_content_context_default_stream?language=objc)
    pub static _nw_content_context_default_stream: &'static NWContentContext;
}

impl NWConnection {
    /// Send data on a connection. This may be called before the connection is ready,
    /// in which case the send will be enqueued until the connection is ready to send.
    /// This is an asynchronous send and the completion block can be used to
    /// determine when the send is complete. There is nothing preventing a client
    /// from issuing an excessive number of outstanding sends. To minimize memory
    /// footprint and excessive latency as a consequence of buffer bloat, it is
    /// advisable to keep a low number of outstanding sends. The completion block
    /// can be used to pace subsequent sends.
    ///
    ///
    /// Parameter `connection`: The connection object on which to send data.
    ///
    ///
    /// Parameter `content`: A data object to send. This may be NULL only if this send is marking a context
    /// (a message or complete connection) as complete in the sending direction.
    ///
    ///
    /// Parameter `context`: The context associated with the content, which represents a logical message
    /// to be sent on the connection. All content sent within a single context will
    /// be sent as an in-order unit, up until the point that the context is marked
    /// complete (see is_complete). Once a context is marked complete, it may be re-used
    /// as a new logical message. Protocols like TCP that cannot send multiple
    /// independent messages at once (serial streams) will only start processing a new
    /// context once the prior context has been marked complete.
    ///
    /// The context can hold protocol metadata to define how to send content, such
    /// as flags for IP packets.
    ///
    /// The context also can define properties that allow a message to ordered relative
    /// to other messages if multiple messages are queued. These properties include
    /// relative priority, expiration, and antecedent relationships. Some protocols
    /// support re-ordering messages within a single connection. For other protocols
    /// that do not, like TCP, these properties still take effect when enqueuing data
    /// into the stream's send buffer. The ordering of messages applies to the first
    /// calls to send on a given context.
    ///
    /// In order to close a connection on the sending side (a "write close"), send
    /// a context that is marked as "final" and mark is_complete. The convenience definition
    /// NW_CONNECTION_FINAL_MESSAGE_CONTEXT may be used to define the default final context
    /// for a connection. If the caller wants to treat the entire connection as a single
    /// stream, with only one context, set NW_CONNECTION_FINAL_MESSAGE_CONTEXT for all
    /// sends; marking is_complete on the final send call will send a "write close".
    /// Using NW_CONNECTION_DEFAULT_STREAM_CONTEXT has the same behavior as sending
    /// NW_CONNECTION_FINAL_MESSAGE_CONTEXT.
    ///
    /// To send basic datagrams on a connection, use NW_CONNECTION_DEFAULT_MESSAGE_CONTEXT
    /// and pass is_complete as true for each datagram.
    ///
    /// To send data as a single stream on a connection, use NW_CONNECTION_DEFAULT_STREAM_CONTEXT
    /// and pass is_complete as true only to mark the end of the stream.
    ///
    ///
    /// Parameter `is_complete`: A flag indicating if the caller's sending context (logical message) is now complete.
    ///
    /// Until a context is marked complete, content sent for other contexts may not
    /// be sent immediately (if the protocol requires sending bytes serially, like TCP).
    ///
    /// For datagram protocols, like UDP, is_complete indicates that the content represents
    /// a complete datagram.
    ///
    /// When sending directly on streaming protocols like TCP, is_complete can be used to
    /// indicate that the connection should send a "write close" (a TCP FIN) if the sending
    /// context is the final context on the connection. Specifically, to send a "write close",
    /// pass NW_CONNECTION_FINAL_MESSAGE_CONTEXT or NW_CONNECTION_DEFAULT_STREAM_CONTEXT for the
    /// context (or create a custom context and set nw_content_context_set_is_final()), and pass
    /// true for is_complete.
    ///
    ///
    /// Parameter `completion`: A callback to be called when the data has been sent, or an error has occurred.
    /// This callback does not indicate that the remote side has acknowledged the data.
    /// This callback does indicate that the data has either been sent or it has been
    /// enqueued to be sent.
    ///
    /// # Safety
    ///
    /// `completion` must be a valid pointer.
    #[doc(alias = "nw_connection_send")]
    #[inline]
    pub unsafe fn send(
        &self,
        content: Option<&DispatchData>,
        context: &NWContentContext,
        is_complete: bool,
        completion: nw_connection_send_completion_t,
    ) {
        extern "C-unwind" {
            fn nw_connection_send(
                connection: &NWConnection,
                content: Option<&DispatchData>,
                context: &NWContentContext,
                is_complete: bool,
                completion: nw_connection_send_completion_t,
            );
        }
        unsafe { nw_connection_send(self, content, context, is_complete, completion) }
    }

    /// Batch several send and/or receive operations together, to hint to
    /// the connection that multiple send or receive operations are expected
    /// in quick succession.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Parameter `batch_block`: The batch block will be invoked immediately upon calling this function.
    /// The client may call nw_connection_send() or nw_connection_receive()
    /// multiple times within the block, and the connection will attempt to
    /// batch these operations when the block returns.
    ///
    /// # Safety
    ///
    /// `batch_block` must be a valid pointer.
    #[doc(alias = "nw_connection_batch")]
    #[inline]
    pub unsafe fn batch(&self, batch_block: dispatch_block_t) {
        extern "C-unwind" {
            fn nw_connection_batch(connection: &NWConnection, batch_block: dispatch_block_t);
        }
        unsafe { nw_connection_batch(self, batch_block) }
    }

    /// Copy a human-readable description of the connection.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Returns: Returns a human-readable string description of the connection.
    /// The caller must call free() on the string.
    #[doc(alias = "nw_connection_copy_description")]
    #[inline]
    pub fn description(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_connection_copy_description(connection: &NWConnection)
                -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_connection_copy_description(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Copy the current path for a connection. If a connection is
    /// established, this will reflect the connected path.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Returns: Returns a retained path object, or NULL if the connection
    /// has not been started or has been cancelled.
    #[doc(alias = "nw_connection_copy_current_path")]
    #[inline]
    pub fn current_path(&self) -> Option<NWRetained<NWPath>> {
        extern "C-unwind" {
            fn nw_connection_copy_current_path(
                connection: &NWConnection,
            ) -> Option<NonNull<NWPath>>;
        }
        let ret = unsafe { nw_connection_copy_current_path(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Copy the connection-wide metadata for a specific protocol.
    /// This allows the caller to introspect per-protocol state,
    /// only once the connection has been established. This
    /// metadata is also available when receiving data through
    /// the content context.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Parameter `definition`: The protocol definition for which metadata will be returned.
    ///
    ///
    /// Returns: Returns a retained protocol metadata object, or NULL if the connection
    /// has not been established yet or is cancelled.
    #[doc(alias = "nw_connection_copy_protocol_metadata")]
    #[inline]
    pub fn protocol_metadata(
        &self,
        definition: &NWProtocolDefinition,
    ) -> Option<NWRetained<NWProtocolMetadata>> {
        extern "C-unwind" {
            fn nw_connection_copy_protocol_metadata(
                connection: &NWConnection,
                definition: &NWProtocolDefinition,
            ) -> Option<NonNull<NWProtocolMetadata>>;
        }
        let ret = unsafe { nw_connection_copy_protocol_metadata(self, definition) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Check for the maximum datagram size that can be written
    /// on the connection. Any datagrams written should be less
    /// than or equal to this size.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Returns: Returns a datagram size based on the current MTU and the
    /// overhead of the protocols being used.
    #[doc(alias = "nw_connection_get_maximum_datagram_size")]
    #[inline]
    pub fn maximum_datagram_size(&self) -> u32 {
        extern "C-unwind" {
            fn nw_connection_get_maximum_datagram_size(connection: &NWConnection) -> u32;
        }
        unsafe { nw_connection_get_maximum_datagram_size(self) }
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_group_descriptor?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_group_descriptor: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_group_descriptor_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_group_descriptor_t = NSObject;

impl NWGroupDescriptor {
    /// Creates a new group descriptor object based on an endpoint
    /// to which communication will be established using a multiplexing protocol,
    /// represented as an nw_endpoint containing the remote endpoint
    /// to use for communication.
    ///
    ///
    /// Parameter `remote_endpoint`: An endpoint that can be used for communication over a multiplexing protocol.
    ///
    ///
    /// Returns: An instantiated group descriptor object or nil if the specified
    /// endpoint is not valid.
    #[doc(alias = "nw_group_descriptor_create_multiplex")]
    #[inline]
    pub fn new_multiplex(remote_endpoint: &NWEndpoint) -> NWRetained<NWGroupDescriptor> {
        extern "C-unwind" {
            fn nw_group_descriptor_create_multiplex(
                remote_endpoint: &NWEndpoint,
            ) -> Option<NonNull<NWGroupDescriptor>>;
        }
        let ret = unsafe { nw_group_descriptor_create_multiplex(remote_endpoint) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a new group descriptor object based on a multicast group,
    /// represented as an address endpoint.
    ///
    ///
    /// Parameter `multicast_group`: An address endpoint that contains a multicast group to join.
    ///
    ///
    /// Returns: An instantiated group descriptor object or nil if the specified
    /// endpoint is not an address endpoint representing a valid multicast
    /// group.
    #[doc(alias = "nw_group_descriptor_create_multicast")]
    #[inline]
    pub fn new_multicast(multicast_group: &NWEndpoint) -> NWRetained<NWGroupDescriptor> {
        extern "C-unwind" {
            fn nw_group_descriptor_create_multicast(
                multicast_group: &NWEndpoint,
            ) -> Option<NonNull<NWGroupDescriptor>>;
        }
        let ret = unsafe { nw_group_descriptor_create_multicast(multicast_group) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Add an additional endpoint to a given group descriptor.
    ///
    ///
    /// Parameter `descriptor`: A group descriptor.
    ///
    ///
    /// Parameter `endpoint`: An endpoint to add to the group.
    ///
    ///
    /// Returns: Returns true if the endpoint was added, false if the endpoint was
    /// not of a valid type and therefore not added.
    #[doc(alias = "nw_group_descriptor_add_endpoint")]
    #[inline]
    pub fn add_endpoint(&self, endpoint: &NWEndpoint) -> bool {
        extern "C-unwind" {
            fn nw_group_descriptor_add_endpoint(
                descriptor: &NWGroupDescriptor,
                endpoint: &NWEndpoint,
            ) -> bool;
        }
        unsafe { nw_group_descriptor_add_endpoint(self, endpoint) }
    }
}

/// A block called to enumerate the endpoints that are members of a group.
///
///
/// Parameter `endpoint`: A member of a group.
///
///
/// Returns: Returning true from the block will continue enumeration, and returning
/// false will stop enumeration.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_group_descriptor_enumerate_endpoints_block_t?language=objc)
pub type nw_group_descriptor_enumerate_endpoints_block_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWEndpoint>) -> bool>;

impl NWGroupDescriptor {
    /// List all endpoints associated with the group descriptor.
    ///
    ///
    /// Parameter `descriptor`: The group descriptor object to check.
    ///
    ///
    /// Parameter `enumerate_block`: A block to which the endpoints associated with the descriptor will be passed.
    /// Returning true from the block will continue to enumerate, and returning false will stop
    /// enumerating.
    ///
    /// # Safety
    ///
    /// `enumerate_block` must be a valid pointer.
    #[doc(alias = "nw_group_descriptor_enumerate_endpoints")]
    #[inline]
    pub unsafe fn enumerate_endpoints(
        &self,
        enumerate_block: nw_group_descriptor_enumerate_endpoints_block_t,
    ) {
        extern "C-unwind" {
            fn nw_group_descriptor_enumerate_endpoints(
                descriptor: &NWGroupDescriptor,
                enumerate_block: nw_group_descriptor_enumerate_endpoints_block_t,
            );
        }
        unsafe { nw_group_descriptor_enumerate_endpoints(self, enumerate_block) }
    }
}

/// Require a particular source for this multicast group descriptor.
///
///
/// Parameter `multicast_descriptor`: The multicast group descriptor to modify.
///
///
/// Parameter `source`: An endpoint describing the source for this descriptor.
#[inline]
pub extern "C-unwind" fn nw_multicast_group_descriptor_set_specific_source(
    multicast_descriptor: &NWGroupDescriptor,
    source: &NWEndpoint,
) {
    extern "C-unwind" {
        fn nw_multicast_group_descriptor_set_specific_source(
            multicast_descriptor: &NWGroupDescriptor,
            source: &NWEndpoint,
        );
    }
    unsafe { nw_multicast_group_descriptor_set_specific_source(multicast_descriptor, source) }
}

/// Disable receiving unicast traffic for a connection group that is also receiving multicast traffic.
///
///
/// Parameter `multicast_descriptor`: The multicast group descriptor to modify.
///
///
/// Parameter `disable_unicast_traffic`: A boolean indicating if receiving unicast traffic should be disabled.
#[inline]
pub extern "C-unwind" fn nw_multicast_group_descriptor_set_disable_unicast_traffic(
    multicast_descriptor: &NWGroupDescriptor,
    disable_unicast_traffic: bool,
) {
    extern "C-unwind" {
        fn nw_multicast_group_descriptor_set_disable_unicast_traffic(
            multicast_descriptor: &NWGroupDescriptor,
            disable_unicast_traffic: bool,
        );
    }
    unsafe {
        nw_multicast_group_descriptor_set_disable_unicast_traffic(
            multicast_descriptor,
            disable_unicast_traffic,
        )
    }
}

/// Check if receiving unicast traffic has been disabled for a multicast connection group.
///
///
/// Parameter `multicast_descriptor`: The multicast group descriptor to check.
///
///
/// Returns: A boolean indicating if receiving unicast traffic should be disabled.
#[inline]
pub extern "C-unwind" fn nw_multicast_group_descriptor_get_disable_unicast_traffic(
    multicast_descriptor: &NWGroupDescriptor,
) -> bool {
    extern "C-unwind" {
        fn nw_multicast_group_descriptor_get_disable_unicast_traffic(
            multicast_descriptor: &NWGroupDescriptor,
        ) -> bool;
    }
    unsafe { nw_multicast_group_descriptor_get_disable_unicast_traffic(multicast_descriptor) }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_connection_group?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_connection_group: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_group_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_connection_group_t = NSObject;

/// Connection Group states sent by nw_connection_group_set_state_changed_handler.
/// States progress forward and do not move backwards.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_group_state_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_connection_group_state_t(pub c_uint);
impl nw_connection_group_state_t {
    /// This state will never be delivered in the connection group's state update
    /// handler and can be treated as an unexpected value.
    #[doc(alias = "nw_connection_group_state_invalid")]
    pub const invalid: Self = Self(0);
    /// before being able to receive and process incoming messages.
    #[doc(alias = "nw_connection_group_state_waiting")]
    pub const waiting: Self = Self(1);
    /// process incoming messages.
    #[doc(alias = "nw_connection_group_state_ready")]
    pub const ready: Self = Self(2);
    /// You should cancel the connection group and create a new connection group object
    /// if you wish to continue processing incoming messages.
    #[doc(alias = "nw_connection_group_state_failed")]
    pub const failed: Self = Self(3);
    /// the user. You should create a new connection group object if you wish to continue
    /// processing incoming messages.
    #[doc(alias = "nw_connection_group_state_cancelled")]
    pub const cancelled: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_connection_group_state_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_connection_group_state_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWConnectionGroup {
    /// Creates a new connection group object to use for communication with
    /// a group descriptor using protocols described by parameters.
    ///
    ///
    /// Parameter `group_descriptor`: A group descriptor. For example, a descriptor of type nw_group_type_multicast
    /// defines one or more multicast groups to automatically join.
    ///
    ///
    /// Parameter `parameters`: Parameters to use for the new connection group. This includes the protocols that
    /// will be used to delineate complete messages for processing. For multicast
    /// joining, all available interfaces will be joined as prohibited or required.
    ///
    ///
    /// Returns: Returns an allocated nw_connection_group_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_connection_group_create")]
    #[inline]
    pub fn new(
        group_descriptor: &NWGroupDescriptor,
        parameters: &NWParameters,
    ) -> NWRetained<NWConnectionGroup> {
        extern "C-unwind" {
            fn nw_connection_group_create(
                group_descriptor: &NWGroupDescriptor,
                parameters: &NWParameters,
            ) -> Option<NonNull<NWConnectionGroup>>;
        }
        let ret = unsafe { nw_connection_group_create(group_descriptor, parameters) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Gets the group descriptor with which the connection group was created.
    ///
    ///
    /// Parameter `group`: The connection group to check.
    ///
    ///
    /// Returns: Returns the descriptor with which the connection group was created.
    #[doc(alias = "nw_connection_group_copy_descriptor")]
    #[inline]
    pub fn descriptor(&self) -> NWRetained<NWGroupDescriptor> {
        extern "C-unwind" {
            fn nw_connection_group_copy_descriptor(
                group: &NWConnectionGroup,
            ) -> Option<NonNull<NWGroupDescriptor>>;
        }
        let ret = unsafe { nw_connection_group_copy_descriptor(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Returns a copy of the parameters passed to nw_connection_group_create.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Returns: Returns an nw_parameters_t object.
    #[doc(alias = "nw_connection_group_copy_parameters")]
    #[inline]
    pub fn parameters(&self) -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_connection_group_copy_parameters(
                group: &NWConnectionGroup,
            ) -> Option<NonNull<NWParameters>>;
        }
        let ret = unsafe { nw_connection_group_copy_parameters(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Sets the client callback queue, on which blocks for events will
    /// be scheduled. This must be done before calling nw_connection_group_start().
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `queue`: The client's callback queue.
    #[doc(alias = "nw_connection_group_set_queue")]
    #[inline]
    pub fn set_queue(&self, queue: &DispatchQueue) {
        extern "C-unwind" {
            fn nw_connection_group_set_queue(group: &NWConnectionGroup, queue: &DispatchQueue);
        }
        unsafe { nw_connection_group_set_queue(self, queue) }
    }
}

/// A block called when the connection group changes state.
///
///
/// Parameter `state`: The new state of the connection group.
///
///
/// Parameter `error`: An optional error that is associated with the new state.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_group_state_changed_handler_t?language=objc)
pub type nw_connection_group_state_changed_handler_t =
    *mut block2::DynBlock<dyn Fn(nw_connection_group_state_t, *mut NWError)>;

impl NWConnectionGroup {
    /// Sets the state changed handler. For clients that need to perform cleanup
    /// when the connection group has been cancelled, the nw_connection_group_state_cancelled state
    /// will be delivered last. This function must not be called after starting the connection group.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `state_changed_handler`: The state changed handler to call when the connection group state changes.
    /// Pass NULL to remove the event handler.
    ///
    /// # Safety
    ///
    /// `state_changed_handler` must be a valid pointer or null.
    #[doc(alias = "nw_connection_group_set_state_changed_handler")]
    #[inline]
    pub unsafe fn set_state_changed_handler(
        &self,
        state_changed_handler: nw_connection_group_state_changed_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_connection_group_set_state_changed_handler(
                group: &NWConnectionGroup,
                state_changed_handler: nw_connection_group_state_changed_handler_t,
            );
        }
        unsafe { nw_connection_group_set_state_changed_handler(self, state_changed_handler) }
    }
}

/// A block called when a new inbound message arrives at the connection group. A client
/// may reply to this message within the handler or it may choose to save the
/// content context representing this message and provide a response
/// at a later time. If an inbound context is deallocated without providing a response,
/// the message is considered dropped and any internal state associated with the
/// endpoint that sent that message will be removed.
///
///
/// Parameter `content`: The content associated with the body of the inbound message. If there is no
/// body for this message `content` will be `nil`.
///
///
/// Parameter `context`: The content context representing this inbound message.
///
///
/// Parameter `is_complete`: True if the inbound message is complete and any content provided represents
/// the entirety of the inbound message's body. If false, the inbound message context
/// may be converted to a connection associated with this message and read
/// the remainder of the body, or an appropriate error may be selected and sent in
/// response.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_group_receive_handler_t?language=objc)
pub type nw_connection_group_receive_handler_t =
    *mut block2::DynBlock<dyn Fn(*mut DispatchData, NonNull<NWContentContext>, bool)>;

impl NWConnectionGroup {
    /// Sets the handler to be invoked whenever a new inbound message
    /// arrives at the connection group. This function must not be called after starting the connection group.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `maximum_message_size`: The maximum message size that should be delivered as a complete message. Any
    /// inbound messages larger than this size will be delivered as a partial message and
    /// an application may convert the inbound message to an `nw_connection` to read
    /// any remaining data for that message until it is complete.
    ///
    ///
    /// Parameter `reject_oversized_messages`: True if messages larger than maximum_message_size should be treated as errors
    /// and the connection group should automatically reply to such messages. False if the
    /// connection group should deliver such messages as incomplete and allow the application
    /// to inspect the message prior to accepting or rejecting it.
    ///
    ///
    /// Parameter `receive_handler`: The handler to call upon arrival of a new inbound message.
    /// Pass NULL to remove the handler.
    ///
    /// # Safety
    ///
    /// `receive_handler` must be a valid pointer or null.
    #[doc(alias = "nw_connection_group_set_receive_handler")]
    #[inline]
    pub unsafe fn set_receive_handler(
        &self,
        maximum_message_size: u32,
        reject_oversized_messages: bool,
        receive_handler: nw_connection_group_receive_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_connection_group_set_receive_handler(
                group: &NWConnectionGroup,
                maximum_message_size: u32,
                reject_oversized_messages: bool,
                receive_handler: nw_connection_group_receive_handler_t,
            );
        }
        unsafe {
            nw_connection_group_set_receive_handler(
                self,
                maximum_message_size,
                reject_oversized_messages,
                receive_handler,
            )
        }
    }

    /// Starts the connection group, which begins listening for and processing incoming messages.
    /// You must call nw_connection_group_set_queue() and set a receive handler with
    /// nw_connection_group_set_receive_handler() before starting the connection group.
    ///
    ///
    /// Parameter `group`: The connection group object.
    #[doc(alias = "nw_connection_group_start")]
    #[inline]
    pub fn start(&self) {
        extern "C-unwind" {
            fn nw_connection_group_start(group: &NWConnectionGroup);
        }
        unsafe { nw_connection_group_start(self) }
    }

    /// Cancels the connection group. The process of cancellation will be completed
    /// asynchronously, and the final callback event delivered to the caller
    /// will be a state update with a value of nw_connection_group_state_cancelled.
    /// Once this update is delivered, the caller may clean up any associated
    /// memory or objects.
    ///
    ///
    /// Parameter `group`: The connection group object.
    #[doc(alias = "nw_connection_group_cancel")]
    #[inline]
    pub fn cancel(&self) {
        extern "C-unwind" {
            fn nw_connection_group_cancel(group: &NWConnectionGroup);
        }
        unsafe { nw_connection_group_cancel(self) }
    }

    /// Copy the remote endpoint corresponding to a given inbound connection group message.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `context`: A content context representing an inbound message received from this connection group.
    ///
    ///
    /// Returns: Returns the remote endpoint, or nil if the context is not a valid
    /// inbound message received from this connection group.
    #[doc(alias = "nw_connection_group_copy_remote_endpoint_for_message")]
    #[inline]
    pub fn remote_endpoint_for_message(
        &self,
        context: &NWContentContext,
    ) -> Option<NWRetained<NWEndpoint>> {
        extern "C-unwind" {
            fn nw_connection_group_copy_remote_endpoint_for_message(
                group: &NWConnectionGroup,
                context: &NWContentContext,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_connection_group_copy_remote_endpoint_for_message(self, context) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Copy the local endpoint corresponding to a given inbound connection group message.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `context`: A content context representing an inbound message received from this connection group.
    ///
    ///
    /// Returns: Returns the local endpoint, or nil if the context is not a valid
    /// inbound message received from this connection group.
    #[doc(alias = "nw_connection_group_copy_local_endpoint_for_message")]
    #[inline]
    pub fn local_endpoint_for_message(
        &self,
        context: &NWContentContext,
    ) -> Option<NWRetained<NWEndpoint>> {
        extern "C-unwind" {
            fn nw_connection_group_copy_local_endpoint_for_message(
                group: &NWConnectionGroup,
                context: &NWContentContext,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_connection_group_copy_local_endpoint_for_message(self, context) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Copy the path associated with a given inbound connection group message.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `context`: A content context representing an inbound message received from this connection group.
    ///
    ///
    /// Returns: Returns the path associated with the provided message, or nil if the context
    /// is not a valid inbound message received from this connection group.
    #[doc(alias = "nw_connection_group_copy_path_for_message")]
    #[inline]
    pub fn path_for_message(&self, context: &NWContentContext) -> Option<NWRetained<NWPath>> {
        extern "C-unwind" {
            fn nw_connection_group_copy_path_for_message(
                group: &NWConnectionGroup,
                context: &NWContentContext,
            ) -> Option<NonNull<NWPath>>;
        }
        let ret = unsafe { nw_connection_group_copy_path_for_message(self, context) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Copy the metadata corresponding to a given inbound connection group message.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `definition`: The protocol definition for which metadata will be returned.
    ///
    ///
    /// Returns: Returns a retained protocol metadata object, or NULL if not found.
    #[doc(alias = "nw_connection_group_copy_protocol_metadata_for_message")]
    #[inline]
    pub fn protocol_metadata_for_message(
        &self,
        context: &NWContentContext,
        definition: &NWProtocolDefinition,
    ) -> Option<NWRetained<NWProtocolMetadata>> {
        extern "C-unwind" {
            fn nw_connection_group_copy_protocol_metadata_for_message(
                group: &NWConnectionGroup,
                context: &NWContentContext,
                definition: &NWProtocolDefinition,
            ) -> Option<NonNull<NWProtocolMetadata>>;
        }
        let ret = unsafe {
            nw_connection_group_copy_protocol_metadata_for_message(self, context, definition)
        };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Extract a connection corresponding to an inbound message from the
    /// connection group. Once extracted, subsequent messages from this
    /// remote endpoint on this connection will no longer be handled by the
    /// connection group. The connection may be used to read the remainder
    /// of a partial message or to send a large response with support for partial
    /// messages and backpressure.
    /// Any incoming messages from this remote endpoint which were saved from
    /// the receive handler may no longer be valid after a connection is returned.
    /// An extracted connection must have a queue set and be started before it can be used.
    ///
    ///
    /// Parameter `group`: The connection group object from which the context was received. If the context was
    /// not received from this connection group, the extraction will fail.
    ///
    ///
    /// Parameter `context`: A content context representing an inbound message received from this connection group.
    ///
    ///
    /// Returns: Returns the connection associated with the provided message, or nil if the extraction
    /// fails. Extraction will fail if the provided message is not an inbound message from
    /// this connection group.
    #[doc(alias = "nw_connection_group_extract_connection_for_message")]
    #[inline]
    pub fn extract_connection_for_message(
        &self,
        context: &NWContentContext,
    ) -> Option<NWRetained<NWConnection>> {
        extern "C-unwind" {
            fn nw_connection_group_extract_connection_for_message(
                group: &NWConnectionGroup,
                context: &NWContentContext,
            ) -> Option<NonNull<NWConnection>>;
        }
        let ret = unsafe { nw_connection_group_extract_connection_for_message(self, context) };
        ret.map(|ret| unsafe { NWRetained::retain(ret) })
    }

    /// Send data in response to an inbound message received by a connection group.
    ///
    ///
    /// Parameter `group`: The connection group object from which the reply_context was received.
    ///
    ///
    /// Parameter `inbound_message`: The inbound message received by the connection group for which this is a response.
    /// An inbound message may be replied to exactly once.
    ///
    ///
    /// Parameter `outbound_message`: The outbound message to send in response to the message received by the connection group.
    ///
    /// The response context can also hold protocol metadata to define how to
    /// send content, such as flags for IP packets.
    ///
    /// If the context is marked as "final", the  connection group will expect that no further communication is
    /// expected during this connection with the peer and may close the underlying transport.
    /// Subsequent connection attempts from the peer will continue to be delivered as incoming messages.
    ///
    ///
    /// Parameter `content`: A data object to send as the message body. This may be NULL if the outgoing
    /// context represents a metadata only message that contains no body data.
    #[doc(alias = "nw_connection_group_reply")]
    #[inline]
    pub fn reply(
        &self,
        inbound_message: &NWContentContext,
        outbound_message: &NWContentContext,
        content: Option<&DispatchData>,
    ) {
        extern "C-unwind" {
            fn nw_connection_group_reply(
                group: &NWConnectionGroup,
                inbound_message: &NWContentContext,
                outbound_message: &NWContentContext,
                content: Option<&DispatchData>,
            );
        }
        unsafe { nw_connection_group_reply(self, inbound_message, outbound_message, content) }
    }

    /// Extract a connection from the connection group. For a multiplex connection group, this means that
    /// a new stream is opened and the corresponding nw_connection_t object is returned. For non-multiplex
    /// connection groups, a connection to the specified endpoint will be returned if allowed by the group descriptor.
    ///
    /// The connection can be re-inserted into the group later. Once reinserted, the connection group
    /// will handle subsequent messages from this remote endpoint.
    /// An extracted connection must have a queue set and be started before it can be used.
    ///
    ///
    /// Parameter `group`: The connection group object from which to extract a connection.
    ///
    ///
    /// Parameter `endpoint`: The endpoint to use as the remote endpoint for the extracted connection, if applicable.
    /// For connection groups with multiplex group descriptors, this should be nil.
    ///
    ///
    /// Parameter `protocol_options`: The protocol options to apply to the extracted connection. May be nil if not applicable.
    ///
    ///
    /// Returns: Returns the connection from the connection group.
    #[doc(alias = "nw_connection_group_extract_connection")]
    #[inline]
    pub fn extract_connection(
        &self,
        endpoint: Option<&NWEndpoint>,
        protocol_options: Option<&NWProtocolOptions>,
    ) -> Option<NWRetained<NWConnection>> {
        extern "C-unwind" {
            fn nw_connection_group_extract_connection(
                group: &NWConnectionGroup,
                endpoint: Option<&NWEndpoint>,
                protocol_options: Option<&NWProtocolOptions>,
            ) -> Option<NonNull<NWConnection>>;
        }
        let ret =
            unsafe { nw_connection_group_extract_connection(self, endpoint, protocol_options) };
        ret.map(|ret| unsafe { NWRetained::retain(ret) })
    }

    /// Reinsert a connection into a connection group. Once reinserted, the connection group
    /// will handle subsequent messages from this remote endpoint, and any outstanding reads on
    /// the connection will be cancelled.
    ///
    ///
    /// Parameter `group`: The connection group object from which the connection was extracted. If the connection was
    /// not extracted from this connection group, the reinsertion will fail.
    ///
    ///
    /// Parameter `connection`: A connection that was extracted from this connection group.
    ///
    ///
    /// Returns: Returns true if the reinsertion was successful. Reinsertion will fail if the provided connection was
    /// not extracted from this connection group.
    #[doc(alias = "nw_connection_group_reinsert_extracted_connection")]
    #[inline]
    pub fn reinsert_extracted_connection(&self, connection: &NWConnection) -> bool {
        extern "C-unwind" {
            fn nw_connection_group_reinsert_extracted_connection(
                group: &NWConnectionGroup,
                connection: &NWConnection,
            ) -> bool;
        }
        unsafe { nw_connection_group_reinsert_extracted_connection(self, connection) }
    }
}

/// A send completion is invoked exactly once for a call to nw_connection_group_send_message().
/// The completion indicates that the sent content has been processed by the stack
/// (not necessarily that it has left the host), or else an error has occurred during
/// sending.
///
///
/// Parameter `error`: An error will be delivered if the associated content could not be fully sent before an
/// error occurred. An error will be sent for any outstanding sends when the connection
/// is cancelled.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_group_send_completion_t?language=objc)
pub type nw_connection_group_send_completion_t = *mut block2::DynBlock<dyn Fn(*mut NWError)>;

impl NWConnectionGroup {
    /// Send data that is not in response to an inbound message. This outgoing
    /// message will be sent from the local endpoint on which the connection group is
    /// listening for incoming messages.
    ///
    /// This is an asynchronous send and the completion block can be used to
    /// determine when the send is complete. There is nothing preventing a client
    /// from issuing an excessive number of outstanding sends. To minimize memory
    /// footprint and excessive latency as a consequence of buffer bloat, it is
    /// advisable to keep a low number of outstanding sends. The completion block
    /// can be used to pace subsequent sends.
    ///
    ///
    /// Parameter `group`: The connection group object from which to send the outbound data.
    ///
    ///
    /// Parameter `content`: A data object to send as the message body. This may be NULL if the outgoing
    /// context represents a metadata only message that contains no body data.
    ///
    ///
    /// Parameter `endpoint`: The destination endpoint to which the outbound message should be sent. If the
    /// endpoint is NULL, the message will be sent to all members of the group.
    ///
    ///
    /// Parameter `context`: An outbound message to send from the connection group.
    ///
    /// The context can also hold protocol metadata to define how to send content,
    /// such as flags for IP packets.
    ///
    /// If the context is marked as "final", the  connection group will expect that no further communication is
    /// expected during this connection with the peer and may close the underlying transport.
    /// Subsequent connection attempts from the peer will be delivered as incoming messages.
    ///
    ///
    /// Parameter `completion`: A callback to be called when the message has been sent, or an error has occurred.
    /// This callback does not indicate that the remote side has acknowledged the data.
    /// This callback does indicate that the data has either been sent or it has been
    /// enqueued to be sent.
    ///
    /// # Safety
    ///
    /// `completion` must be a valid pointer.
    #[doc(alias = "nw_connection_group_send_message")]
    #[inline]
    pub unsafe fn send_message(
        &self,
        content: Option<&DispatchData>,
        endpoint: Option<&NWEndpoint>,
        context: &NWContentContext,
        completion: nw_connection_group_send_completion_t,
    ) {
        extern "C-unwind" {
            fn nw_connection_group_send_message(
                group: &NWConnectionGroup,
                content: Option<&DispatchData>,
                endpoint: Option<&NWEndpoint>,
                context: &NWContentContext,
                completion: nw_connection_group_send_completion_t,
            );
        }
        unsafe { nw_connection_group_send_message(self, content, endpoint, context, completion) }
    }
}

/// A block called with a new connection when a multiplex group receives a new stream. If a new connection
/// handler is set the user must handle connections received by this handler. There are three possible
/// actions to take and one of these three actions must be taken.
/// 1) Take over the ownership of the connection. In this case, the connection is used by the client to
/// send and receive data as any other connection would be used. The client may insert this
/// connection back into the connection group at a later point if so desired.
/// The connection must have a queue set and be started before it can be used.
/// 2) If you want the connection group to handle this connection, simply insert this connection back into
/// the connection group right away.
/// 3) If you don't want to accept this connection, simply cancel the connection.
///
///
/// Parameter `connection`: The connection representing the new stream on this multiplexing protocol
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_group_new_connection_handler_t?language=objc)
pub type nw_connection_group_new_connection_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWConnection>)>;

impl NWConnectionGroup {
    /// Sets the new connection handler to be invoked whenever a new inbound connection
    /// is received by the connection group. This function must not be called
    /// after starting the connection group.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `new_connection_handler`: The new connection handler to call upon receipt of a new inbound connection.
    /// Pass NULL to remove the handler.
    ///
    /// # Safety
    ///
    /// `new_connection_handler` must be a valid pointer or null.
    #[doc(alias = "nw_connection_group_set_new_connection_handler")]
    #[inline]
    pub unsafe fn set_new_connection_handler(
        &self,
        new_connection_handler: nw_connection_group_new_connection_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_connection_group_set_new_connection_handler(
                group: &NWConnectionGroup,
                new_connection_handler: nw_connection_group_new_connection_handler_t,
            );
        }
        unsafe { nw_connection_group_set_new_connection_handler(self, new_connection_handler) }
    }

    /// Copy the metadata corresponding to a given inbound connection group message.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `definition`: The protocol definition for which metadata will be returned.
    ///
    ///
    /// Returns: Returns a retained protocol metadata object, or NULL if the connection
    /// group has not been established yet or is cancelled.
    #[doc(alias = "nw_connection_group_copy_protocol_metadata")]
    #[inline]
    pub fn protocol_metadata(
        &self,
        definition: &NWProtocolDefinition,
    ) -> Option<NWRetained<NWProtocolMetadata>> {
        extern "C-unwind" {
            fn nw_connection_group_copy_protocol_metadata(
                group: &NWConnectionGroup,
                definition: &NWProtocolDefinition,
            ) -> Option<NonNull<NWProtocolMetadata>>;
        }
        let ret = unsafe { nw_connection_group_copy_protocol_metadata(self, definition) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_establishment_report?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_establishment_report: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_establishment_report_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_establishment_report_t = NSObject;

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_establishment_report_access_block_t?language=objc)
pub type nw_establishment_report_access_block_t =
    *mut block2::DynBlock<dyn Fn(*mut NWEstablishmentReport)>;

impl NWConnection {
    /// Access the establishment report for a connection. The report will be
    /// NULL until the connection is in the "ready" state.
    ///
    /// The callback block will be invoked exactly once on the provided queue.
    ///
    ///
    /// Parameter `connection`: An established connection.
    ///
    ///
    /// Parameter `queue`: The dispatch queue on which to call the access_block.
    ///
    ///
    /// Parameter `access_block`: A block to invoke with the establishment report, which may be NULL if the
    /// connection not ready.
    ///
    /// # Safety
    ///
    /// `access_block` must be a valid pointer.
    #[doc(alias = "nw_connection_access_establishment_report")]
    #[inline]
    pub unsafe fn access_establishment_report(
        &self,
        queue: &DispatchQueue,
        access_block: nw_establishment_report_access_block_t,
    ) {
        extern "C-unwind" {
            fn nw_connection_access_establishment_report(
                connection: &NWConnection,
                queue: &DispatchQueue,
                access_block: nw_establishment_report_access_block_t,
            );
        }
        unsafe { nw_connection_access_establishment_report(self, queue, access_block) }
    }
}

impl NWEstablishmentReport {
    /// Retrieve the duration of the connection's establishment. This is
    /// the total time in milliseconds from when the connection attempt began
    /// until the connection becomes ready, including resolution, proxy
    /// evaluation, and protocol handshakes.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Returns: Returns the number of milliseconds the connection took to establish.
    #[doc(alias = "nw_establishment_report_get_duration_milliseconds")]
    #[inline]
    pub fn duration_milliseconds(&self) -> u64 {
        extern "C-unwind" {
            fn nw_establishment_report_get_duration_milliseconds(
                report: &NWEstablishmentReport,
            ) -> u64;
        }
        unsafe { nw_establishment_report_get_duration_milliseconds(self) }
    }

    /// Retrieve the delay from calling start() after which the successful connection
    /// attempt began. For connections that succeed on the first attempt, this value
    /// will be 0. For connections that move into the "waiting" state, this
    /// value will be greater than 0.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Returns: Returns the number of milliseconds from connection start to the beginning
    /// of the successful connection attempt.
    #[doc(alias = "nw_establishment_report_get_attempt_started_after_milliseconds")]
    #[inline]
    pub fn attempt_started_after_milliseconds(&self) -> u64 {
        extern "C-unwind" {
            fn nw_establishment_report_get_attempt_started_after_milliseconds(
                report: &NWEstablishmentReport,
            ) -> u64;
        }
        unsafe { nw_establishment_report_get_attempt_started_after_milliseconds(self) }
    }

    /// Retrieve the number of connection attempts made before the successful
    /// attempt. For connections that succeed on the first attempt, this value
    /// will be 0. For connections that move into the "waiting" state, this
    /// value will be greater than 0.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Returns: Returns the number of connection attempts made before the successful attempt.
    #[doc(alias = "nw_establishment_report_get_previous_attempt_count")]
    #[inline]
    pub fn previous_attempt_count(&self) -> u32 {
        extern "C-unwind" {
            fn nw_establishment_report_get_previous_attempt_count(
                report: &NWEstablishmentReport,
            ) -> u32;
        }
        unsafe { nw_establishment_report_get_previous_attempt_count(self) }
    }

    /// Check if the connection used a proxy during establishment.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Returns: Returns true if the connection used a proxy, false otherwise.
    #[doc(alias = "nw_establishment_report_get_used_proxy")]
    #[inline]
    pub fn used_proxy(&self) -> bool {
        extern "C-unwind" {
            fn nw_establishment_report_get_used_proxy(report: &NWEstablishmentReport) -> bool;
        }
        unsafe { nw_establishment_report_get_used_proxy(self) }
    }

    /// Check if a proxy configuration applied to the connection,
    /// even if the connection did not end up using a proxy for the
    /// successful attempt.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Returns: Returns true if a proxy configuration applied to the connection,
    /// false otherwise.
    #[doc(alias = "nw_establishment_report_get_proxy_configured")]
    #[inline]
    pub fn proxy_configured(&self) -> bool {
        extern "C-unwind" {
            fn nw_establishment_report_get_proxy_configured(report: &NWEstablishmentReport)
                -> bool;
        }
        unsafe { nw_establishment_report_get_proxy_configured(self) }
    }

    /// Access the endpoint of the proxy used by a connection, if applicable.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Returns: Returns an allocated endpoint object if a proxy was used by the connection,
    /// or NULL if no proxy was used.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    #[doc(alias = "nw_establishment_report_copy_proxy_endpoint")]
    #[inline]
    pub fn proxy_endpoint(&self) -> Option<NWRetained<NWEndpoint>> {
        extern "C-unwind" {
            fn nw_establishment_report_copy_proxy_endpoint(
                report: &NWEstablishmentReport,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_establishment_report_copy_proxy_endpoint(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_resolution_report?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_resolution_report: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_resolution_report_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_resolution_report_t = NSObject;

/// The source of a resolution indicates if the set of endpoints was resolved
/// locally using a cache, or sent a query over the network.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_report_resolution_source_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_report_resolution_source_t(pub c_uint);
impl nw_report_resolution_source_t {
    #[doc(alias = "nw_report_resolution_source_query")]
    pub const query: Self = Self(1);
    #[doc(alias = "nw_report_resolution_source_cache")]
    pub const cache: Self = Self(2);
    #[doc(alias = "nw_report_resolution_source_expired_cache")]
    pub const expired_cache: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_report_resolution_source_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_report_resolution_source_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWResolutionReport {
    /// Check the source of a resolution, such as query or cache.
    ///
    ///
    /// Parameter `resolution_report`: A resolution report.
    ///
    ///
    /// Returns: The source of the resolution (query or cache).
    #[doc(alias = "nw_resolution_report_get_source")]
    #[inline]
    pub fn source(&self) -> nw_report_resolution_source_t {
        extern "C-unwind" {
            fn nw_resolution_report_get_source(
                resolution_report: &NWResolutionReport,
            ) -> nw_report_resolution_source_t;
        }
        unsafe { nw_resolution_report_get_source(self) }
    }

    /// Get the number of milliseconds spent on this resolution step.
    ///
    ///
    /// Parameter `resolution_report`: A resolution report.
    ///
    ///
    /// Returns: The number of milliseconds spent on this resolution step.
    #[doc(alias = "nw_resolution_report_get_milliseconds")]
    #[inline]
    pub fn milliseconds(&self) -> u64 {
        extern "C-unwind" {
            fn nw_resolution_report_get_milliseconds(resolution_report: &NWResolutionReport)
                -> u64;
        }
        unsafe { nw_resolution_report_get_milliseconds(self) }
    }

    /// Get the number of resolved endpoints discovered by the resolution step.
    ///
    ///
    /// Parameter `resolution_report`: A resolution report.
    ///
    ///
    /// Returns: The number of resolved endpoints discovered by the resolution step.
    #[doc(alias = "nw_resolution_report_get_endpoint_count")]
    #[inline]
    pub fn endpoint_count(&self) -> u32 {
        extern "C-unwind" {
            fn nw_resolution_report_get_endpoint_count(
                resolution_report: &NWResolutionReport,
            ) -> u32;
        }
        unsafe { nw_resolution_report_get_endpoint_count(self) }
    }

    /// Copy the resolved endpoint that led to a successful connection.
    ///
    ///
    /// Parameter `resolution_report`: A resolution report.
    ///
    ///
    /// Returns: The resolved endpoint that led to a successful connection.
    #[doc(alias = "nw_resolution_report_copy_successful_endpoint")]
    #[inline]
    pub fn successful_endpoint(&self) -> NWRetained<NWEndpoint> {
        extern "C-unwind" {
            fn nw_resolution_report_copy_successful_endpoint(
                resolution_report: &NWResolutionReport,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_resolution_report_copy_successful_endpoint(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Copy first resolved endpoint attempted, which may be the same as the successful endpoint.
    ///
    ///
    /// Parameter `resolution_report`: A resolution report.
    ///
    ///
    /// Returns: The first resolved endpoint attempted.
    #[doc(alias = "nw_resolution_report_copy_preferred_endpoint")]
    #[inline]
    pub fn preferred_endpoint(&self) -> NWRetained<NWEndpoint> {
        extern "C-unwind" {
            fn nw_resolution_report_copy_preferred_endpoint(
                resolution_report: &NWResolutionReport,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_resolution_report_copy_preferred_endpoint(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

/// The protocol used for endpoint resolution.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_report_resolution_protocol_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_report_resolution_protocol_t(pub c_uint);
impl nw_report_resolution_protocol_t {
    #[doc(alias = "nw_report_resolution_protocol_unknown")]
    pub const unknown: Self = Self(0);
    #[doc(alias = "nw_report_resolution_protocol_udp")]
    pub const udp: Self = Self(1);
    #[doc(alias = "nw_report_resolution_protocol_tcp")]
    pub const tcp: Self = Self(2);
    #[doc(alias = "nw_report_resolution_protocol_tls")]
    pub const tls: Self = Self(3);
    #[doc(alias = "nw_report_resolution_protocol_https")]
    pub const https: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_report_resolution_protocol_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_report_resolution_protocol_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWResolutionReport {
    /// Check the protocol used for endpoint resolution.
    ///
    ///
    /// Parameter `resolution_report`: A resolution report.
    ///
    ///
    /// Returns: The protocol used for endpoint resolution.
    #[doc(alias = "nw_resolution_report_get_protocol")]
    #[inline]
    pub fn protocol(&self) -> nw_report_resolution_protocol_t {
        extern "C-unwind" {
            fn nw_resolution_report_get_protocol(
                resolution_report: &NWResolutionReport,
            ) -> nw_report_resolution_protocol_t;
        }
        unsafe { nw_resolution_report_get_protocol(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_report_resolution_enumerator_t?language=objc)
pub type nw_report_resolution_enumerator_t = *mut block2::DynBlock<
    dyn Fn(
        nw_report_resolution_source_t,
        u64,
        u32,
        NonNull<NWEndpoint>,
        NonNull<NWEndpoint>,
    ) -> bool,
>;

impl NWEstablishmentReport {
    /// Enumerate the steps of connection establishment that involved endpoint
    /// resolution, such as DNS hostname resolution and Bonjour service resolution.
    /// The provided block will be called inline zero or more times.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Parameter `enumerate_block`: A block to be invoked zero or more times, once for each step of resolution
    /// used during connection establishment.
    ///
    /// The values passed to the enumerator are:
    /// - source: The source of the resolution (query or cache).
    /// - milliseconds: The number of milliseconds spent on this resolution step.
    /// - endpoint_count: The number of resolved endpoints discovered by the resolution step.
    /// - successful_endpoint: The resolved endpoint that led to a successful connection.
    /// - preferred_endpoint: The first resolved endpoint attempted, which may be the same as the successful_endpoint.
    ///
    /// Returning true from the block indicates that the enumeration should continue.
    /// Returning false indicates that the enumeration should stop.
    ///
    /// # Safety
    ///
    /// `enumerate_block` must be a valid pointer.
    #[doc(alias = "nw_establishment_report_enumerate_resolutions")]
    #[inline]
    pub unsafe fn enumerate_resolutions(&self, enumerate_block: nw_report_resolution_enumerator_t) {
        extern "C-unwind" {
            fn nw_establishment_report_enumerate_resolutions(
                report: &NWEstablishmentReport,
                enumerate_block: nw_report_resolution_enumerator_t,
            );
        }
        unsafe { nw_establishment_report_enumerate_resolutions(self, enumerate_block) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_report_resolution_report_enumerator_t?language=objc)
pub type nw_report_resolution_report_enumerator_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWResolutionReport>) -> bool>;

impl NWEstablishmentReport {
    /// Enumerate the steps of connection establishment that involved endpoint
    /// resolution, such as DNS hostname resolution and Bonjour service resolution.
    /// This variant provides resolution report objects, which allow more detailed
    /// access to information.
    ///
    /// The provided block will be called inline zero or more times.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Parameter `enumerate_block`: A block to be invoked zero or more times, once for each step of resolution
    /// used during connection establishment. Each block contains a nw_resolution_report_t.
    ///
    /// Returning true from the block indicates that the enumeration should continue.
    /// Returning false indicates that the enumeration should stop.
    ///
    /// # Safety
    ///
    /// `enumerate_block` must be a valid pointer.
    #[doc(alias = "nw_establishment_report_enumerate_resolution_reports")]
    #[inline]
    pub unsafe fn enumerate_resolution_reports(
        &self,
        enumerate_block: nw_report_resolution_report_enumerator_t,
    ) {
        extern "C-unwind" {
            fn nw_establishment_report_enumerate_resolution_reports(
                report: &NWEstablishmentReport,
                enumerate_block: nw_report_resolution_report_enumerator_t,
            );
        }
        unsafe { nw_establishment_report_enumerate_resolution_reports(self, enumerate_block) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_report_protocol_enumerator_t?language=objc)
pub type nw_report_protocol_enumerator_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWProtocolDefinition>, u64, u64) -> bool>;

impl NWEstablishmentReport {
    /// Enumerate the protocols used in the established connection.
    /// The provided block will be called inline zero or more times.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Parameter `enumerate_block`: A block to be invoked zero or more times, once for each protocol
    /// used in the established connection.
    ///
    /// The values passed to the enumerator are:
    /// - protocol: The protocol definition.
    /// - handshake_milliseconds: The number of milliseconds spent on the protocol's handshake.
    /// - handshake_rtt_milliseconds: The round trip time in milliseconds measured by the protocol's handshake.
    ///
    /// Returning true from the block indicates that the enumeration should continue.
    /// Returning false indicates that the enumeration should stop.
    ///
    /// # Safety
    ///
    /// `enumerate_block` must be a valid pointer.
    #[doc(alias = "nw_establishment_report_enumerate_protocols")]
    #[inline]
    pub unsafe fn enumerate_protocols(&self, enumerate_block: nw_report_protocol_enumerator_t) {
        extern "C-unwind" {
            fn nw_establishment_report_enumerate_protocols(
                report: &NWEstablishmentReport,
                enumerate_block: nw_report_protocol_enumerator_t,
            );
        }
        unsafe { nw_establishment_report_enumerate_protocols(self, enumerate_block) }
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_data_transfer_report?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_data_transfer_report: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_data_transfer_report_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_data_transfer_report_t = NSObject;

impl NWConnection {
    /// Create a new data transfer report on a connection. Multiple
    /// reports may be created for a single connection. The report begins
    /// capturing data when the connection becomes ready, or when the
    /// report is created (whichever occurs last).
    ///
    /// Call nw_data_transfer_report_collect() to complete collection of
    /// report, after which point the details of the report will be available.
    ///
    ///
    /// Parameter `connection`: A connection object, in or before the ready state.
    ///
    ///
    /// Returns: Returns an allocated nw_data_transfer_report_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_connection_create_new_data_transfer_report")]
    #[inline]
    pub fn new_data_transfer_report(&self) -> NWRetained<NWDataTransferReport> {
        extern "C-unwind" {
            fn nw_connection_create_new_data_transfer_report(
                connection: &NWConnection,
            ) -> Option<NonNull<NWDataTransferReport>>;
        }
        let ret = unsafe { nw_connection_create_new_data_transfer_report(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

/// The state of a Data Transfer Report indicates whether or not the contents
/// have been collected, and are ready to be accessed.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_data_transfer_report_state_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_data_transfer_report_state_t(pub c_uint);
impl nw_data_transfer_report_state_t {
    #[doc(alias = "nw_data_transfer_report_state_collecting")]
    pub const collecting: Self = Self(1);
    #[doc(alias = "nw_data_transfer_report_state_collected")]
    pub const collected: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_data_transfer_report_state_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_data_transfer_report_state_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWDataTransferReport {
    /// Access the state of a data transfer report. Once a report
    /// is "collected", individual fields may be read.
    ///
    ///
    /// Parameter `report`: A data transfer report to check.
    ///
    ///
    /// Returns: Returns the current state of the data transfer report.
    #[doc(alias = "nw_data_transfer_report_get_state")]
    #[inline]
    pub fn state(&self) -> nw_data_transfer_report_state_t {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_state(
                report: &NWDataTransferReport,
            ) -> nw_data_transfer_report_state_t;
        }
        unsafe { nw_data_transfer_report_get_state(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_data_transfer_report_collect_block_t?language=objc)
pub type nw_data_transfer_report_collect_block_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWDataTransferReport>)>;

impl NWDataTransferReport {
    /// Mark a data transfer report as complete, and request collection of
    /// values. Once the report has been collected, the callback block
    /// will be invoked exactly once on the provided dispatch queue.
    ///
    /// If a connection is cancelled or fails prior to the report being collected,
    /// the report will automatically be collected. Calling
    /// nw_data_transfer_report_collect() will be redundant but not harmful.
    ///
    ///
    /// Parameter `report`: A data transfer report to check.
    ///
    ///
    /// Parameter `queue`: The dispatch queue on which to call the collect_block.
    ///
    ///
    /// Parameter `collect_block`: A block to invoke once the report has been collected.
    ///
    /// # Safety
    ///
    /// `collect_block` must be a valid pointer.
    #[doc(alias = "nw_data_transfer_report_collect")]
    #[inline]
    pub unsafe fn collect(
        &self,
        queue: &DispatchQueue,
        collect_block: nw_data_transfer_report_collect_block_t,
    ) {
        extern "C-unwind" {
            fn nw_data_transfer_report_collect(
                report: &NWDataTransferReport,
                queue: &DispatchQueue,
                collect_block: nw_data_transfer_report_collect_block_t,
            );
        }
        unsafe { nw_data_transfer_report_collect(self, queue, collect_block) }
    }
}

extern "C" {
    /// Pass NW_ALL_PATHS to data transfer report accessors to sum
    /// values across paths where applicable. For values that cannot
    /// sum, the value of the primary path is used.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/network/_nw_data_transfer_report_all_paths?language=objc)
    pub static _nw_data_transfer_report_all_paths: u32;
}

impl NWDataTransferReport {
    /// Retrieve the duration of the data transfer report. This is a length
    /// of time in milliseconds which can be used to calculate throughput
    /// when compared to application and transport byte counts.
    ///
    /// The start time is calculated from when the report was created, or the connection
    /// became ready if the connection was not ready when the report was created.
    /// The duration ends when the report is collected, or the connection fails
    /// or is cancelled.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Returns: Returns the duration of the data transport report in milliseconds, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_duration_milliseconds")]
    #[inline]
    pub fn duration_milliseconds(&self) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_duration_milliseconds(
                report: &NWDataTransferReport,
            ) -> u64;
        }
        unsafe { nw_data_transfer_report_get_duration_milliseconds(self) }
    }

    /// Retrieve the number of paths used by the connection for the
    /// duration of the report. Any value greater than or equal to 0 and
    /// less than this count may be used as a "path_index" for retrieving
    /// specific details from the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Returns: Returns the number of paths used by the connection, which
    /// limits the value of the "path_index" parameter used in other report
    /// functions. Returns 0 if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_path_count")]
    #[inline]
    pub fn path_count(&self) -> u32 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_path_count(report: &NWDataTransferReport) -> u32;
        }
        unsafe { nw_data_transfer_report_get_path_count(self) }
    }

    /// Retrieve the number of IP packets received on a given path for the
    /// duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of IP packets received, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_received_ip_packet_count")]
    #[inline]
    pub fn received_ip_packet_count(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_received_ip_packet_count(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe { nw_data_transfer_report_get_received_ip_packet_count(self, path_index) }
    }

    /// Retrieve the number of IP packets sent on a given path for the
    /// duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of IP packets sent, or 0 if the report is not
    /// in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_sent_ip_packet_count")]
    #[inline]
    pub fn sent_ip_packet_count(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_sent_ip_packet_count(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe { nw_data_transfer_report_get_sent_ip_packet_count(self, path_index) }
    }

    /// Retrieve the number of transport protocol bytes (such as TCP stream bytes)
    /// received on a given path for the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of transport protocol bytes received, or 0 if the
    /// report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_received_transport_byte_count")]
    #[inline]
    pub fn received_transport_byte_count(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_received_transport_byte_count(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe { nw_data_transfer_report_get_received_transport_byte_count(self, path_index) }
    }

    /// Retrieve the number of duplicate transport protocol bytes (such as
    /// duplicate TCP bytes) received on a given path for the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of duplicate transport protocol bytes received, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_received_transport_duplicate_byte_count")]
    #[inline]
    pub fn received_transport_duplicate_byte_count(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_received_transport_duplicate_byte_count(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe {
            nw_data_transfer_report_get_received_transport_duplicate_byte_count(self, path_index)
        }
    }

    /// Retrieve the number of out-of-order transport protocol bytes (such as
    /// out-of-order TCP bytes) received on a given path for the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of out-of-order transport protocol bytes received, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_received_transport_out_of_order_byte_count")]
    #[inline]
    pub fn received_transport_out_of_order_byte_count(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_received_transport_out_of_order_byte_count(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe {
            nw_data_transfer_report_get_received_transport_out_of_order_byte_count(self, path_index)
        }
    }

    /// Retrieve the number of transport protocol bytes (such as TCP stream bytes)
    /// sent on a given path for the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of transport protocol bytes sent, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_sent_transport_byte_count")]
    #[inline]
    pub fn sent_transport_byte_count(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_sent_transport_byte_count(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe { nw_data_transfer_report_get_sent_transport_byte_count(self, path_index) }
    }

    /// Retrieve the number of retransmitted transport protocol bytes (such as
    /// retransmitted TCP bytes) sent on a given path for the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of retransmitted transport protocol bytes sent, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count")]
    #[inline]
    pub fn sent_transport_retransmitted_byte_count(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe {
            nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(self, path_index)
        }
    }

    /// Retrieve the smoothed average for the transport protocol's round trip time
    /// (RTT) on a given path for the duration of the report, measured in milliseconds.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// For non-multipath connections, pass 0 as the path index to access
    /// the single path. Passing NW_ALL_PATHS for this function is
    /// equivalent to passing 0.
    ///
    ///
    /// Returns: Returns the smoothed RTT as measured by the transport protocol, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds")]
    #[inline]
    pub fn transport_smoothed_rtt_milliseconds(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe { nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds(self, path_index) }
    }

    /// Retrieve the minimum (best) round trip time (RTT) on a given path for
    /// the duration of the report, measured in milliseconds.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// For non-multipath connections, pass 0 as the path index to access
    /// the single path. Passing NW_ALL_PATHS for this function is
    /// equivalent to passing 0.
    ///
    ///
    /// Returns: Returns the minimum RTT as measured by the transport protocol, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_transport_minimum_rtt_milliseconds")]
    #[inline]
    pub fn transport_minimum_rtt_milliseconds(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_transport_minimum_rtt_milliseconds(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe { nw_data_transfer_report_get_transport_minimum_rtt_milliseconds(self, path_index) }
    }

    /// Retrieve the variance of the round trip time (RTT) on a given path for
    /// the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// For non-multipath connections, pass 0 as the path index to access
    /// the single path. Passing NW_ALL_PATHS for this function is
    /// equivalent to passing 0.
    ///
    ///
    /// Returns: Returns the RTT variance as measured by the transport protocol, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_transport_rtt_variance")]
    #[inline]
    pub fn transport_rtt_variance(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_transport_rtt_variance(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe { nw_data_transfer_report_get_transport_rtt_variance(self, path_index) }
    }

    /// Retrieve the number of application bytes received on a given
    /// path for the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of application bytes received, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_received_application_byte_count")]
    #[inline]
    pub fn received_application_byte_count(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_received_application_byte_count(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe { nw_data_transfer_report_get_received_application_byte_count(self, path_index) }
    }

    /// Retrieve the number of application bytes sent on a given
    /// path for the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of application bytes sent, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_sent_application_byte_count")]
    #[inline]
    pub fn sent_application_byte_count(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_sent_application_byte_count(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe { nw_data_transfer_report_get_sent_application_byte_count(self, path_index) }
    }

    /// Retrieve the interface used for data transfer for a given
    /// path used by a connection.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function is
    /// equivalent to passing 0.
    ///
    ///
    /// Returns: Returns a retained nw_interface_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails if the report is not yet collected.
    #[doc(alias = "nw_data_transfer_report_copy_path_interface")]
    #[inline]
    pub fn path_interface(&self, path_index: u32) -> NWRetained<NWInterface> {
        extern "C-unwind" {
            fn nw_data_transfer_report_copy_path_interface(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> Option<NonNull<NWInterface>>;
        }
        let ret = unsafe { nw_data_transfer_report_copy_path_interface(self, path_index) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Retrieve the radio type used for data transfer for a given
    /// path used by a connection.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function is
    /// equivalent to passing 0.
    ///
    ///
    /// Returns: Returns the radio type used for the specified path.
    /// Returns nw_interface_radio_type_unknown on failure.
    /// Fails if the report is not yet collected.
    #[doc(alias = "nw_data_transfer_report_get_path_radio_type")]
    #[inline]
    pub fn path_radio_type(&self, path_index: u32) -> nw_interface_radio_type_t {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_path_radio_type(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> nw_interface_radio_type_t;
        }
        unsafe { nw_data_transfer_report_get_path_radio_type(self, path_index) }
    }
}

/// Channel states sent by nw_ethernet_channel_set_state_changed_handler.
/// States generally progress forward and do not move backwards, with the
/// exception of preparing and waiting, which may alternate before the channel
/// becomes ready or failed.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ethernet_channel_state_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_ethernet_channel_state_t(pub c_uint);
impl nw_ethernet_channel_state_t {
    /// will never be delivered in the channel's state update handler, and can be treated as
    /// an unexpected value.
    #[doc(alias = "nw_ethernet_channel_state_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_ethernet_channel_state_waiting")]
    pub const waiting: Self = Self(1);
    #[doc(alias = "nw_ethernet_channel_state_preparing")]
    pub const preparing: Self = Self(2);
    #[doc(alias = "nw_ethernet_channel_state_ready")]
    pub const ready: Self = Self(3);
    #[doc(alias = "nw_ethernet_channel_state_failed")]
    pub const failed: Self = Self(4);
    #[doc(alias = "nw_ethernet_channel_state_cancelled")]
    pub const cancelled: Self = Self(5);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ethernet_channel_state_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ethernet_channel_state_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWEthernetChannel {
    /// Creates an Ethernet channel with a custom EtherType.
    ///
    ///
    /// Parameter `ether_type`: The custom EtherType to be used for all Ethernet frames in this channel. The
    /// EtherType is the two-octet field in an Ethernet frame, indicating the protocol
    /// encapsulated in the payload of the frame.  This parameter is in little-endian
    /// byte order.  Only custom EtherType values are supported. This parameter cannot
    /// be an EtherType already handled by the system, such as IPv4, IPv6, ARP, VLAN Tag,
    /// or 802.1x.
    ///
    /// Calling processes must hold the "com.apple.developer.networking.custom-protocol"
    /// entitlement.
    ///
    ///
    /// Parameter `interface`: The interface on which this custom Ethernet channel will be allowed.
    ///
    ///
    /// Returns: Returns an allocated nw_ethernet_channel_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_ethernet_channel_create")]
    #[inline]
    pub fn new(ether_type: u16, interface: &NWInterface) -> NWRetained<NWEthernetChannel> {
        extern "C-unwind" {
            fn nw_ethernet_channel_create(
                ether_type: u16,
                interface: &NWInterface,
            ) -> Option<NonNull<NWEthernetChannel>>;
        }
        let ret = unsafe { nw_ethernet_channel_create(ether_type, interface) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates an Ethernet channel with a custom EtherType and networking parameters
    ///
    ///
    /// Parameter `ether_type`: The custom EtherType to be used for all Ethernet frames in this channel. The
    /// EtherType is the two-octet field in an Ethernet frame, indicating the protocol
    /// encapsulated in the payload of the frame.  This parameter is in little-endian
    /// byte order.  Only custom EtherType values are supported. This parameter cannot
    /// be an EtherType already handled by the system, such as IPv4, IPv6, ARP, VLAN Tag,
    /// or 802.1x.
    ///
    /// Calling processes must hold the "com.apple.developer.networking.custom-protocol"
    /// entitlement.
    ///
    ///
    /// Parameter `interface`: The interface on which this custom Ethernet channel will be allowed.
    ///
    ///
    /// Parameter `parameters`: nw_parameters_t that allows caller to specify networking parameters such as custom context and queue.
    ///
    ///
    /// Returns: Returns an allocated nw_ethernet_channel_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_ethernet_channel_create_with_parameters")]
    #[inline]
    pub fn with_parameters(
        ether_type: u16,
        interface: &NWInterface,
        parameters: &NWParameters,
    ) -> NWRetained<NWEthernetChannel> {
        extern "C-unwind" {
            fn nw_ethernet_channel_create_with_parameters(
                ether_type: u16,
                interface: &NWInterface,
                parameters: &NWParameters,
            ) -> Option<NonNull<NWEthernetChannel>>;
        }
        let ret = unsafe {
            nw_ethernet_channel_create_with_parameters(ether_type, interface, parameters)
        };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

/// A state change handler to handle state changes.
///
///
/// Parameter `state`: The current state.
///
///
/// Parameter `error`: error if present, indicates the reason of the failure.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ethernet_channel_state_changed_handler_t?language=objc)
pub type nw_ethernet_channel_state_changed_handler_t =
    *mut block2::DynBlock<dyn Fn(nw_ethernet_channel_state_t, *mut NWError)>;

impl NWEthernetChannel {
    /// Sets the state change handler. For clients that need to perform cleanup when the
    /// channel has been cancelled, the nw_ethernet_channel_state_cancelled state will
    /// be delivered last.
    ///
    ///
    /// Parameter `ethernet_channel`: The ethernet_channel object.
    ///
    ///
    /// Parameter `handler`: The state changed handler to call when the channel state changes.
    /// Pass NULL to remove the state changed handler.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_ethernet_channel_set_state_changed_handler")]
    #[inline]
    pub unsafe fn set_state_changed_handler(
        &self,
        handler: nw_ethernet_channel_state_changed_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_ethernet_channel_set_state_changed_handler(
                ethernet_channel: &NWEthernetChannel,
                handler: nw_ethernet_channel_state_changed_handler_t,
            );
        }
        unsafe { nw_ethernet_channel_set_state_changed_handler(self, handler) }
    }

    /// Sets the client callback queue, on which blocks for events will
    /// be scheduled. This must be done before calling nw_ethernet_channel_start().
    ///
    ///
    /// Parameter `ethernet_channel`: The ethernet_channel object.
    ///
    ///
    /// Parameter `queue`: The client's dispatch queue.
    #[doc(alias = "nw_ethernet_channel_set_queue")]
    #[inline]
    pub fn set_queue(&self, queue: &DispatchQueue) {
        extern "C-unwind" {
            fn nw_ethernet_channel_set_queue(
                ethernet_channel: &NWEthernetChannel,
                queue: &DispatchQueue,
            );
        }
        unsafe { nw_ethernet_channel_set_queue(self, queue) }
    }

    /// Returns the maximum payload size that can be written
    /// on the channel. Any payloads written must be less than
    /// or equal to this size.  Payloads exceeding this size will be
    /// dropped by 'nw_ethernet_channel_send()'.
    ///
    ///
    /// Parameter `ethernet_channel`: The ethernet_channel object.
    ///
    ///
    /// Returns: Returns a payload size based on the current MTU of the channel.
    #[doc(alias = "nw_ethernet_channel_get_maximum_payload_size")]
    #[inline]
    pub fn maximum_payload_size(&self) -> u32 {
        extern "C-unwind" {
            fn nw_ethernet_channel_get_maximum_payload_size(
                ethernet_channel: &NWEthernetChannel,
            ) -> u32;
        }
        unsafe { nw_ethernet_channel_get_maximum_payload_size(self) }
    }

    /// Starts the Ethernet channel, which will cause the channel to evaluate
    /// its path, and try to become readable and writable.
    ///
    ///
    /// Parameter `ethernet_channel`: The ethernet_channel object.
    #[doc(alias = "nw_ethernet_channel_start")]
    #[inline]
    pub fn start(&self) {
        extern "C-unwind" {
            fn nw_ethernet_channel_start(ethernet_channel: &NWEthernetChannel);
        }
        unsafe { nw_ethernet_channel_start(self) }
    }

    /// Cancel the Ethernet channel. This will close the channel. The process of cancellation will be
    /// completed asynchronously, and the final callback event delivered to the caller will be
    /// a state update with a value of nw_ethernet_channel_state_cancelled. Once this update is
    /// delivered, the caller may clean up any associated memory or objects.
    ///
    /// Outstanding sends and receives will receive errors before the state changes to cancelled.
    /// There is no guarantee that any outstanding sends that have not yet delivered
    /// completion handlers will send data before the channel is closed.
    ///
    ///
    /// Parameter `ethernet_channel`: The ethernet_channel object.
    #[doc(alias = "nw_ethernet_channel_cancel")]
    #[inline]
    pub fn cancel(&self) {
        extern "C-unwind" {
            fn nw_ethernet_channel_cancel(ethernet_channel: &NWEthernetChannel);
        }
        unsafe { nw_ethernet_channel_cancel(self) }
    }
}

/// This receive handler is invoked when a frame of the set EtherType is received from the Ethernet
/// channel.
///
///
/// Parameter `content`: The received Ethernet payload, which has a length constrained by the maximum Ethernet frame size
/// of 1518 minus Ethernet header size of (18/14 bytes with/without vlan tag).
///
///
/// Parameter `vlan_tag`: The vlan tag of the frame, 0 if there is no vlan tag.  This parameter is in little-endian
/// byte order.
///
///
/// Parameter `local_address`: The local Ethernet address in the received Ethernet frame header.
///
///
/// Parameter `remote_address`: The remote Ethernet address in the received Ethernet frame header.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ethernet_channel_receive_handler_t?language=objc)
pub type nw_ethernet_channel_receive_handler_t = *mut block2::DynBlock<
    dyn Fn(NonNull<DispatchData>, u16, nw_ethernet_address_t, nw_ethernet_address_t),
>;

impl NWEthernetChannel {
    /// Sets the Ethernet channel receive handler. Should be called before nw_ethernet_channel_start.
    ///
    ///
    /// Parameter `ethernet_channel`: The Ethernet channel object.
    ///
    ///
    /// Parameter `handler`: The event handler to call when the Ethernet channel receives a new frame.
    /// Pass NULL to remove the receive handler.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_ethernet_channel_set_receive_handler")]
    #[inline]
    pub unsafe fn set_receive_handler(&self, handler: nw_ethernet_channel_receive_handler_t) {
        extern "C-unwind" {
            fn nw_ethernet_channel_set_receive_handler(
                ethernet_channel: &NWEthernetChannel,
                handler: nw_ethernet_channel_receive_handler_t,
            );
        }
        unsafe { nw_ethernet_channel_set_receive_handler(self, handler) }
    }
}

/// A send completion is invoked exactly once for a call to nw_ethernet_channel_send().
/// The completion indicates that the sent Ethernet frame has been processed by the stack
/// (not necessarily that it has left the host), or else an error has occurred during
/// sending.
///
///
/// Parameter `error`: An error will be sent if the associated frame could not be fully sent before an
/// error occurred. An error will be sent for any outstanding sends when the channel
/// is cancelled.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ethernet_channel_send_completion_t?language=objc)
pub type nw_ethernet_channel_send_completion_t = *mut block2::DynBlock<dyn Fn(*mut NWError)>;

impl NWEthernetChannel {
    /// Send an Ethernet frame on a channel.  This must be called after the channel
    /// becomes ready.  This is an asynchronous send and the completion block can be used
    /// to determine when the send is complete.
    ///
    ///
    /// Parameter `ethernet_channel`: The ethernet_channel object on which to send frame.
    ///
    ///
    /// Parameter `content`: An Ethernet payload to send.
    ///
    ///
    /// Parameter `vlan_tag`: The vlan tag of the frame.  If vlan_tag is specified, the 802.1Q tag will be included.
    /// TPID will be set to 0x8100 followed by the specified 16-bit vlan_tag (only the highest
    /// 3-bit class of service field is supported.  The remaining 13 bits must be set to zero).
    /// Pass 0 to omit the vlan tag for this frame.
    ///
    ///
    /// Parameter `remote_address`: Remote Ethernet address for this Ethernet frame.  This is a required parameter.
    /// Note that the local Ethernet address will be the Ethernet address of the specified
    /// interface of this Ethernet channel.
    ///
    ///
    /// Parameter `completion`: A callback to be called when the data has been sent, or an error has occurred.
    /// This callback does not indicate that the remote side has acknowledged the data.
    /// This callback does indicate that the data has been sent.
    ///
    /// # Safety
    ///
    /// - `remote_address` Array TODO.
    /// - `completion` must be a valid pointer.
    #[doc(alias = "nw_ethernet_channel_send")]
    #[inline]
    pub unsafe fn send(
        &self,
        content: &DispatchData,
        vlan_tag: u16,
        remote_address: nw_ethernet_address_t,
        completion: nw_ethernet_channel_send_completion_t,
    ) {
        extern "C-unwind" {
            fn nw_ethernet_channel_send(
                ethernet_channel: &NWEthernetChannel,
                content: &DispatchData,
                vlan_tag: u16,
                remote_address: nw_ethernet_address_t,
                completion: nw_ethernet_channel_send_completion_t,
            );
        }
        unsafe { nw_ethernet_channel_send(self, content, vlan_tag, remote_address, completion) }
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_framer?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_framer: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_framer_t = NSObject;

/// A framer message is an instance of protocol metadata associated
/// with the definition of a framer, created by nw_framer_create_definition().
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nwframermessage?language=objc)
#[doc(alias = "nw_framer_message_t")]
pub type NWFramerMessage = NWProtocolMetadata;

/// Create an instance of a framer message on which per-
/// message options can be configured when sending data
/// on a connection. This is intended to be used by the
/// application above the connection to send message data
/// down to the framer protocol instance.
///
///
/// Parameter `definition`: The framer protocol definition, as retrieved from
/// nw_protocol_options_copy_definition() on the framer options.
///
///
/// Returns: Returns a retained protocol metadata object.
#[inline]
pub extern "C-unwind" fn nw_framer_protocol_create_message(
    definition: &NWProtocolDefinition,
) -> NWRetained<NWFramerMessage> {
    extern "C-unwind" {
        fn nw_framer_protocol_create_message(
            definition: &NWProtocolDefinition,
        ) -> Option<NonNull<NWFramerMessage>>;
    }
    let ret = unsafe { nw_framer_protocol_create_message(definition) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

impl NWProtocolMetadata {
    /// Checks if a protocol metadata object is a framer protocol
    /// message. This indicates whether or not it is compatible
    /// with the framer message setters and accessors.
    ///
    ///
    /// Parameter `metadata`: The protocol metadata to check.
    ///
    ///
    /// Returns: Returns true if the metadata is associated with a framer
    /// protocol definition, false otherwise.
    #[doc(alias = "nw_protocol_metadata_is_framer_message")]
    #[inline]
    pub fn is_framer_message(&self) -> bool {
        extern "C-unwind" {
            fn nw_protocol_metadata_is_framer_message(metadata: &NWProtocolMetadata) -> bool;
        }
        unsafe { nw_protocol_metadata_is_framer_message(self) }
    }
}

impl NWFramer {
    /// Create a framer message, given a framer instance. This
    /// is intended to be used within the implementation of
    /// the framer protocol to create messages that are delivered
    /// as input to the application.
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Returns: Returns a retained framer message object.
    #[doc(alias = "nw_framer_message_create")]
    #[inline]
    pub fn message_create(&self) -> NWRetained<NWFramerMessage> {
        extern "C-unwind" {
            fn nw_framer_message_create(framer: &NWFramer) -> Option<NonNull<NWFramerMessage>>;
        }
        let ret = unsafe { nw_framer_message_create(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

/// A block to be invoked when a value stored in a framer message is disposed.
/// If the value was created using malloc(), for example, it should be freed here.
///
///
/// Parameter `value`: A pointer to the stored message value.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_message_dispose_value_t?language=objc)
pub type nw_framer_message_dispose_value_t = *mut block2::DynBlock<dyn Fn(NonNull<c_void>)>;

extern "C-unwind" {
    /// Set a key-value pair on a framer message, with a custom
    /// dispose function for the value.
    ///
    ///
    /// Parameter `message`: The framer message object.
    ///
    ///
    /// Parameter `key`: The string key to identify the value.
    ///
    ///
    /// Parameter `value`: A pointer to the value to store.
    ///
    ///
    /// Parameter `dispose_value`: A block to invoke to dispose the stored value.
    ///
    /// # Safety
    ///
    /// - `key` must be a valid pointer.
    /// - `value` must be a valid pointer or null.
    /// - `dispose_value` must be a valid pointer or null.
    pub fn nw_framer_message_set_value(
        message: &NWFramerMessage,
        key: NonNull<c_char>,
        value: *mut c_void,
        dispose_value: nw_framer_message_dispose_value_t,
    );
}

extern "C-unwind" {
    /// Access the value with a key on a framer message.
    ///
    ///
    /// Parameter `message`: The framer message object.
    ///
    ///
    /// Parameter `key`: The string key to identify the value.
    ///
    ///
    /// Parameter `access_value`: A block to invoke inline with the pointer to the stored value.
    /// This pointer may be NULL if no value is stored for the key.
    ///
    ///
    /// Returns: Returns the boolean value returned by the access_value block,
    /// or else false if the parameters were invalid.
    ///
    /// # Safety
    ///
    /// `key` must be a valid pointer.
    pub fn nw_framer_message_access_value(
        message: &NWFramerMessage,
        key: NonNull<c_char>,
        access_value: &block2::DynBlock<dyn Fn(*const c_void) -> bool>,
    ) -> bool;
}

extern "C-unwind" {
    /// Set a key-value pair on a framer message, where the
    /// value is a reference-counted object.
    ///
    ///
    /// Parameter `message`: The framer message object.
    ///
    ///
    /// Parameter `key`: The string key to identify the value.
    ///
    ///
    /// Parameter `value`: A reference counted object to store.
    ///
    /// # Safety
    ///
    /// - `key` must be a valid pointer.
    /// - `value` should be of the correct type.
    #[cfg(feature = "objc2")]
    pub fn nw_framer_message_set_object_value(
        message: &NWFramerMessage,
        key: NonNull<c_char>,
        value: Option<&AnyObject>,
    );
}

/// Copy the stored object value using a key on a framer message.
///
///
/// Parameter `message`: The framer message object.
///
///
/// Parameter `key`: The string key to identify the value.
///
///
/// Returns: Returns a reference counted object with a +1 reference count,
/// or NULL if no value was found for the specified key.
///
/// # Safety
///
/// `key` must be a valid pointer.
#[cfg(feature = "objc2")]
#[inline]
pub unsafe extern "C-unwind" fn nw_framer_message_copy_object_value(
    message: &NWFramerMessage,
    key: NonNull<c_char>,
) -> Option<Retained<AnyObject>> {
    extern "C-unwind" {
        fn nw_framer_message_copy_object_value(
            message: &NWFramerMessage,
            key: NonNull<c_char>,
        ) -> *mut AnyObject;
    }
    let ret = unsafe { nw_framer_message_copy_object_value(message, key) };
    unsafe { Retained::from_raw(ret) }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_start_result_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_framer_start_result_t(pub c_uint);
impl nw_framer_start_result_t {
    #[doc(alias = "nw_framer_start_result_ready")]
    pub const ready: Self = Self(1);
    #[doc(alias = "nw_framer_start_result_will_mark_ready")]
    pub const will_mark_ready: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_framer_start_result_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_framer_start_result_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A block to be invoked when starting a new instance of the framer
/// protocol. This may occur more than once for a single nw_connection.
///
///
/// Parameter `framer`: A new instance of the framer protocol. This handle should be used
/// to set callbacks, such as with nw_framer_set_input_handler()
/// and nw_framer_set_output_handler(); and to perform actions, such
/// as nw_framer_deliver_input() and nw_framer_write_output().
///
///
/// Returns: Return whether or not the start should implicitly mark the protocol
/// as "ready" using nw_framer_start_result_ready, or that the protocol
/// will call nw_framer_mark_ready() later using
/// nw_framer_start_result_will_mark_ready.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_start_handler_t?language=objc)
pub type nw_framer_start_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWFramer>) -> nw_framer_start_result_t>;

/// Create a protocol definition for a custom framer protocol.
///
///
/// Parameter `identifier`: A string identifier used to name this framer protocol. This does not
/// define uniqueness, and is primarily used for logging and debugging.
///
///
/// Parameter `flags`: Flags to describe extended options on framer protocol behavior,
/// all prefixed with "NW_FRAMER_CREATE_FLAGS_".
///
///
/// Parameter `start_handler`: A block to be invoked when starting a new instance of the framer
/// protocol. This may occur more than once for a single nw_connection.
///
///
/// Returns: Returns a retained protocol definition that can be used with protocol
/// options and metadata.
///
/// # Safety
///
/// - `identifier` must be a valid pointer.
/// - `start_handler` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn nw_framer_create_definition(
    identifier: NonNull<c_char>,
    flags: u32,
    start_handler: nw_framer_start_handler_t,
) -> NWRetained<NWProtocolDefinition> {
    extern "C-unwind" {
        fn nw_framer_create_definition(
            identifier: NonNull<c_char>,
            flags: u32,
            start_handler: nw_framer_start_handler_t,
        ) -> Option<NonNull<NWProtocolDefinition>>;
    }
    let ret = unsafe { nw_framer_create_definition(identifier, flags, start_handler) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Create protocol options from a framer definition. This object can
/// be added to an nw_protocol_stack_t to be used in an nw_connection_t
/// or an nw_listener_t.
///
///
/// Parameter `framer_definition`: A protocol definition created with nw_framer_create_definition().
///
///
/// Returns: Returns a retained protocol options object to add into a protocol
/// stack.
#[inline]
pub extern "C-unwind" fn nw_framer_create_options(
    framer_definition: &NWProtocolDefinition,
) -> NWRetained<NWProtocolOptions> {
    extern "C-unwind" {
        fn nw_framer_create_options(
            framer_definition: &NWProtocolDefinition,
        ) -> Option<NonNull<NWProtocolOptions>>;
    }
    let ret = unsafe { nw_framer_create_options(framer_definition) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Set a key-value pair on framer options, where the
    /// value is a reference-counted object.
    ///
    ///
    /// Parameter `options`: The framer options object.
    ///
    ///
    /// Parameter `key`: The string key to identify the value.
    ///
    ///
    /// Parameter `value`: A reference counted object to store.
    ///
    /// # Safety
    ///
    /// - `key` must be a valid pointer.
    /// - `value` should be of the correct type.
    #[cfg(feature = "objc2")]
    pub fn nw_framer_options_set_object_value(
        options: &NWProtocolOptions,
        key: NonNull<c_char>,
        value: Option<&AnyObject>,
    );
}

/// Copy the stored object value using a key on framer options.
///
///
/// Parameter `options`: The framer options object.
///
///
/// Parameter `key`: The string key to identify the value.
///
///
/// Returns: Returns a reference counted object with a +1 reference count,
/// or NULL if no value was found for the specified key.
///
/// # Safety
///
/// `key` must be a valid pointer.
#[cfg(feature = "objc2")]
#[inline]
pub unsafe extern "C-unwind" fn nw_framer_options_copy_object_value(
    options: &NWProtocolOptions,
    key: NonNull<c_char>,
) -> Option<Retained<AnyObject>> {
    extern "C-unwind" {
        fn nw_framer_options_copy_object_value(
            options: &NWProtocolOptions,
            key: NonNull<c_char>,
        ) -> *mut AnyObject;
    }
    let ret = unsafe { nw_framer_options_copy_object_value(options, key) };
    unsafe { Retained::from_raw(ret) }
}

/// A handler block to be invoked whenever new input
/// data is available to be parsed. When this block is
/// run, the implementation should call functions like
/// nw_framer_parse_input() and nw_framer_deliver_input().
///
/// Each invocation represents new data being available
/// to read from the network. This data may be insufficient
/// to complete a message, or may contain multiple messages.
/// Implementations are expected to try to parse messages
/// in a loop until parsing fails to read enough to continue.
///
///
/// Parameter `framer`: The instance of the framer protocol.
///
///
/// Returns: Return a hint of the number of bytes that should be present
/// before invoking this handler again. Returning 0 indicates
/// that the handler should be invoked once any data is available.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_input_handler_t?language=objc)
pub type nw_framer_input_handler_t = *mut block2::DynBlock<dyn Fn(NonNull<NWFramer>) -> usize>;

impl NWFramer {
    /// Set a handler block to be invoked whenever new input
    /// data is available to be parsed. When this block is
    /// run, the implementation should call functions like
    /// nw_framer_parse_input() and nw_framer_deliver_input().
    ///
    /// Input events are edge triggered. The input_handler block
    /// should continue to call nw_framer_parse_input()
    /// until nw_framer_parse_input() can no longer produce
    /// enough bytes to satisfy the request, or the protocol
    /// needs to wait for some other event to continue processing
    /// later.
    ///
    /// This setter is required, and must only be set from within
    /// the invocation of a nw_framer_start_handler_t.
    ///
    ///
    /// Parameter `framer`: The framer instance object, passed via the
    /// nw_framer_start_handler_t block.
    ///
    ///
    /// Parameter `input_handler`: The block to invoke whenever new input data is available.
    ///
    /// # Safety
    ///
    /// `input_handler` must be a valid pointer.
    #[doc(alias = "nw_framer_set_input_handler")]
    #[inline]
    pub unsafe fn set_input_handler(&self, input_handler: nw_framer_input_handler_t) {
        extern "C-unwind" {
            fn nw_framer_set_input_handler(
                framer: &NWFramer,
                input_handler: nw_framer_input_handler_t,
            );
        }
        unsafe { nw_framer_set_input_handler(self, input_handler) }
    }
}

/// A handler block to be invoked whenever an output
/// message is ready to be sent. When this block is
/// run, the implementation should call functions like
/// nw_framer_parse_output() and nw_framer_write_output().
///
/// Each invocation represents a single complete or partial
/// message that is being sent. The implementation is
/// expected to write this message or let it be dropped
/// in this handler.
///
///
/// Parameter `framer`: The instance of the framer protocol.
///
///
/// Parameter `message`: The framer message being sent.
///
///
/// Parameter `message_length`: The length of the data associated with this message send.
/// If the message is not complete, the length represents the
/// partial message length being sent, which may be smaller
/// than the complete message length.
///
///
/// Parameter `is_complete`: A boolean indicating whether or not the message is now complete.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_output_handler_t?language=objc)
pub type nw_framer_output_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWFramer>, NonNull<NWFramerMessage>, usize, bool)>;

impl NWFramer {
    /// Set a handler block to be invoked whenever an output
    /// message is ready to be sent. When this block is
    /// run, the implementation should call functions like
    /// nw_framer_parse_output() and nw_framer_write_output().
    ///
    /// This setter is required, and must only be set from within
    /// the invocation of a nw_framer_start_handler_t.
    ///
    ///
    /// Parameter `framer`: The framer instance object, passed via the
    /// nw_framer_start_handler_t block.
    ///
    ///
    /// Parameter `output_handler`: The block to invoke whenever a new output message is ready
    /// to be sent.
    ///
    /// # Safety
    ///
    /// `output_handler` must be a valid pointer.
    #[doc(alias = "nw_framer_set_output_handler")]
    #[inline]
    pub unsafe fn set_output_handler(&self, output_handler: nw_framer_output_handler_t) {
        extern "C-unwind" {
            fn nw_framer_set_output_handler(
                framer: &NWFramer,
                output_handler: nw_framer_output_handler_t,
            );
        }
        unsafe { nw_framer_set_output_handler(self, output_handler) }
    }
}

/// A handler block to be invoked whenever the wakeup timer
/// set via nw_framer_schedule_wakeup() fires. This is intended to
/// be used for sending keepalives or other control traffic.
///
///
/// Parameter `framer`: The instance of the framer protocol.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_wakeup_handler_t?language=objc)
pub type nw_framer_wakeup_handler_t = *mut block2::DynBlock<dyn Fn(NonNull<NWFramer>)>;

impl NWFramer {
    /// Set a handler block to be invoked whenever the wakeup timer
    /// set via nw_framer_schedule_wakeup() fires. This is intended to
    /// be used for sending keepalives or other control traffic.
    ///
    /// This setter is optional, and must only be set from within
    /// the invocation of a nw_framer_start_handler_t.
    ///
    ///
    /// Parameter `framer`: The framer instance object, passed via the
    /// nw_framer_start_handler_t block.
    ///
    ///
    /// Parameter `wakeup_handler`: The block to invoke whenever the timeout set by
    /// nw_framer_schedule_wakeup() is reached.
    ///
    /// # Safety
    ///
    /// `wakeup_handler` must be a valid pointer.
    #[doc(alias = "nw_framer_set_wakeup_handler")]
    #[inline]
    pub unsafe fn set_wakeup_handler(&self, wakeup_handler: nw_framer_wakeup_handler_t) {
        extern "C-unwind" {
            fn nw_framer_set_wakeup_handler(
                framer: &NWFramer,
                wakeup_handler: nw_framer_wakeup_handler_t,
            );
        }
        unsafe { nw_framer_set_wakeup_handler(self, wakeup_handler) }
    }
}

/// A handler block to be invoked when the connection
/// is being disconnected, to allow the framer implementation
/// a chance to send any final data.
///
///
/// Parameter `framer`: The instance of the framer protocol.
///
///
/// Returns: Return true if the framer is done and the connection
/// can be fully disconnected, or false the stop should
/// be delayed. If false, the implementation must later
/// call nw_framer_mark_failed_with_error().
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_stop_handler_t?language=objc)
pub type nw_framer_stop_handler_t = *mut block2::DynBlock<dyn Fn(NonNull<NWFramer>) -> bool>;

impl NWFramer {
    /// Set a handler block to be invoked when the connection
    /// is being disconnected, to allow the framer implementation
    /// a chance to send any final data.
    ///
    /// This setter is optional, and must only be set from within
    /// the invocation of a nw_framer_start_handler_t.
    ///
    ///
    /// Parameter `framer`: The framer instance object, passed via the
    /// nw_framer_start_handler_t block.
    ///
    ///
    /// Parameter `stop_handler`: The block to invoke when the connection is disconnected.
    ///
    /// # Safety
    ///
    /// `stop_handler` must be a valid pointer.
    #[doc(alias = "nw_framer_set_stop_handler")]
    #[inline]
    pub unsafe fn set_stop_handler(&self, stop_handler: nw_framer_stop_handler_t) {
        extern "C-unwind" {
            fn nw_framer_set_stop_handler(
                framer: &NWFramer,
                stop_handler: nw_framer_stop_handler_t,
            );
        }
        unsafe { nw_framer_set_stop_handler(self, stop_handler) }
    }
}

/// A handler block to be invoked when the protocol stack
/// is being torn down and deallocated. This is the opportunity
/// for the framer implementation to release any state it may
/// have saved.
///
///
/// Parameter `framer`: The instance of the framer protocol.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_cleanup_handler_t?language=objc)
pub type nw_framer_cleanup_handler_t = *mut block2::DynBlock<dyn Fn(NonNull<NWFramer>)>;

impl NWFramer {
    /// Set a handler block to be invoked when the protocol stack
    /// is being torn down and deallocated. This is the opportunity
    /// for the framer implementation to release any state it may
    /// have saved.
    ///
    /// This setter is optional, and must only be set from within
    /// the invocation of a nw_framer_start_handler_t.
    ///
    ///
    /// Parameter `framer`: The framer instance object, passed via the
    /// nw_framer_start_handler_t block.
    ///
    ///
    /// Parameter `cleanup_handler`: The block to invoke when the protocol stack is being deallocated.
    ///
    /// # Safety
    ///
    /// `cleanup_handler` must be a valid pointer.
    #[doc(alias = "nw_framer_set_cleanup_handler")]
    #[inline]
    pub unsafe fn set_cleanup_handler(&self, cleanup_handler: nw_framer_cleanup_handler_t) {
        extern "C-unwind" {
            fn nw_framer_set_cleanup_handler(
                framer: &NWFramer,
                cleanup_handler: nw_framer_cleanup_handler_t,
            );
        }
        unsafe { nw_framer_set_cleanup_handler(self, cleanup_handler) }
    }

    /// Mark the connection associated with the framer instance
    /// as ready (see nw_connection_state_ready). This is intended
    /// to be used by protocols that require a handshake before being
    /// able to send application data. This should only be called
    /// if the return value to the nw_framer_start_handler_t block
    /// was nw_framer_start_result_will_call_ready.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    #[doc(alias = "nw_framer_mark_ready")]
    #[inline]
    pub fn mark_ready(&self) {
        extern "C-unwind" {
            fn nw_framer_mark_ready(framer: &NWFramer);
        }
        unsafe { nw_framer_mark_ready(self) }
    }

    /// Dynamically add a protocol to a connection establishment
    /// attempt "above" the framer protocol. This means that the
    /// protocol above will start running once the framer becomes
    /// ready by calling nw_framer_mark_ready(). This can only
    /// be used with framers that return a value of
    /// nw_framer_start_result_will_call_ready to their start
    /// handlers. An example of using this functionality is
    /// adding a security protocol, like TLS, above a framer
    /// once that framer completes its initial handshake.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `protocol_options`: Protocol options for an application protocol to dynamically
    /// add "above" the framer.
    ///
    ///
    /// Returns: Returns true if the protocol was successfully added,
    /// or false it it could not be added. This will fail if
    /// the framer is already marked ready.
    #[doc(alias = "nw_framer_prepend_application_protocol")]
    #[inline]
    pub fn prepend_application_protocol(&self, protocol_options: &NWProtocolOptions) -> bool {
        extern "C-unwind" {
            fn nw_framer_prepend_application_protocol(
                framer: &NWFramer,
                protocol_options: &NWProtocolOptions,
            ) -> bool;
        }
        unsafe { nw_framer_prepend_application_protocol(self, protocol_options) }
    }

    /// Mark the connection associated with the framer instance
    /// as failed (see nw_connection_state_failed).
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `error_code`: An error code to describe why the connection failed.
    #[doc(alias = "nw_framer_mark_failed_with_error")]
    #[inline]
    pub fn mark_failed_with_error(&self, error_code: c_int) {
        extern "C-unwind" {
            fn nw_framer_mark_failed_with_error(framer: &NWFramer, error_code: c_int);
        }
        unsafe { nw_framer_mark_failed_with_error(self, error_code) }
    }
}

/// A completion block that is invoked inline to parse available
/// bytes, either input or output. This is the way a framer can
/// access the underlying buffer for data being sent or received.
/// The block has a side effect of advancing the parsing cursor
/// by the number of bytes specified in the return value.
///
///
/// Parameter `buffer`: The buffer of bytes being sent or received.
///
///
/// Parameter `buffer_length`: The number of valid bytes in buffer.
///
///
/// Parameter `is_complete`: The boolean indicating if this section of the buffer indicates
/// the end of a message or stream.
///
///
/// Returns: Return the number of bytes by which to advance the input or
/// output cursor. For example, if nw_framer_parse_input() is called
/// and the completion returns 0, calling nw_framer_parse_input() again
/// will allow the implementation to start parsing again at the same
/// start location. However, if the completion returns 10, the next
/// call to nw_framer_parse_input() will return bytes starting from 10
/// bytes beyond the previous call.
///
/// The cursors also define the offsets at which data being delivered
/// or written using nw_framer_deliver_input_no_copy() and
/// nw_framer_write_output_no_copy() will start.
///
/// The returned value for incrementing the cursor may be larger than
/// the length of the buffer just parsed. This allows an implementation
/// to "skip" ahead by a number of bytes if it knows it does not
/// need to parse more.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_parse_completion_t?language=objc)
pub type nw_framer_parse_completion_t =
    *mut block2::DynBlock<dyn Fn(*mut u8, usize, bool) -> usize>;

impl NWFramer {
    /// Parse currently available input from the location of the input
    /// cursor in the stream or message being parsed.
    ///
    /// The parse completion block will always be invoked inline exactly once.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `minimum_incomplete_length`: The minimum number of bytes to parse. If this amount is
    /// not available, the parse completion block will be invoked
    /// with 0 bytes.
    ///
    ///
    /// Parameter `maximum_length`: The maximum number of bytes to parse as a contiguous buffer.
    /// If temp_buffer is not NULL, then this represents the length
    /// of valid bytes in temp_buffer.
    ///
    ///
    /// Parameter `temp_buffer`: A buffer provided by the caller to copy parse bytes into.
    /// If it is not NULL, it must have at least maximum_length bytes
    /// available, and any parsed bytes will be copied into the buffer.
    /// Any data stored in temp_buffer will be overwritten.
    /// If it is NULL, the buffer provided in the completion will not
    /// copy unless a copy is required to provide the minimum bytes
    /// as a contiguous buffer. The temp_buffer allows the caller to
    /// guarantee alignment properties of the buffer it parses.
    ///
    ///
    /// Parameter `parse`: The completion that provides the bytes to parse, which will
    /// be called exactly once.
    ///
    ///
    /// Returns: Returns true if the parse succeeded, or false if not enough
    /// bytes were available.
    ///
    /// # Safety
    ///
    /// - `temp_buffer` must be a valid pointer or null.
    /// - `parse` must be a valid pointer.
    #[doc(alias = "nw_framer_parse_input")]
    #[inline]
    pub unsafe fn parse_input(
        &self,
        minimum_incomplete_length: usize,
        maximum_length: usize,
        temp_buffer: *mut u8,
        parse: nw_framer_parse_completion_t,
    ) -> bool {
        extern "C-unwind" {
            fn nw_framer_parse_input(
                framer: &NWFramer,
                minimum_incomplete_length: usize,
                maximum_length: usize,
                temp_buffer: *mut u8,
                parse: nw_framer_parse_completion_t,
            ) -> bool;
        }
        unsafe {
            nw_framer_parse_input(
                self,
                minimum_incomplete_length,
                maximum_length,
                temp_buffer,
                parse,
            )
        }
    }

    /// Deliver arbitrary data to the application. This is intended to
    /// deliver any data that is generated or transformed by the
    /// protocol instance. It will incur a copy of bytes.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `input_buffer`: The bytes to deliver to the application. This must be non-NULL.
    /// If an empty message needs to be delivered, use
    /// nw_framer_deliver_input_no_copy().
    ///
    ///
    /// Parameter `input_length`: The length of input_buffer. This must be non-zero.
    ///
    ///
    /// Parameter `message`: The message to associate with the received data.
    ///
    ///
    /// Parameter `is_complete`: A boolean indicating whether or not this data represents
    /// the end of the message.
    ///
    /// # Safety
    ///
    /// `input_buffer` must be a valid pointer.
    #[doc(alias = "nw_framer_deliver_input")]
    #[inline]
    pub unsafe fn deliver_input(
        &self,
        input_buffer: NonNull<u8>,
        input_length: usize,
        message: &NWFramerMessage,
        is_complete: bool,
    ) {
        extern "C-unwind" {
            fn nw_framer_deliver_input(
                framer: &NWFramer,
                input_buffer: NonNull<u8>,
                input_length: usize,
                message: &NWFramerMessage,
                is_complete: bool,
            );
        }
        unsafe { nw_framer_deliver_input(self, input_buffer, input_length, message, is_complete) }
    }

    /// Deliver bytes directly to the application without any
    /// transformation or copy. The bytes will start at the current
    /// input cursor used for parsing, and will implicitly advance
    /// the cursor by the length being delivered.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `input_length`: The number of input bytes to deliver. This will advance
    /// the parsing cursor by the specified number of bytes.
    ///
    /// The length may be 0, which can be used to indicate the
    /// end of the message if is_complete is set.
    ///
    ///
    /// Parameter `message`: The message to associate with the received data.
    ///
    ///
    /// Parameter `is_complete`: A boolean indicating whether or not this data represents
    /// the end of the message.
    ///
    ///
    /// Returns: Returns true if the input was delivered immediately, or
    /// false if it will be delivered once more bytes become available.
    #[doc(alias = "nw_framer_deliver_input_no_copy")]
    #[inline]
    pub fn deliver_input_no_copy(
        &self,
        input_length: usize,
        message: &NWFramerMessage,
        is_complete: bool,
    ) -> bool {
        extern "C-unwind" {
            fn nw_framer_deliver_input_no_copy(
                framer: &NWFramer,
                input_length: usize,
                message: &NWFramerMessage,
                is_complete: bool,
            ) -> bool;
        }
        unsafe { nw_framer_deliver_input_no_copy(self, input_length, message, is_complete) }
    }

    /// Mark the input side of the framer as a pass-through, which
    /// means the framer will not be notified of any further input
    /// data.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    #[doc(alias = "nw_framer_pass_through_input")]
    #[inline]
    pub fn pass_through_input(&self) {
        extern "C-unwind" {
            fn nw_framer_pass_through_input(framer: &NWFramer);
        }
        unsafe { nw_framer_pass_through_input(self) }
    }

    /// Parse currently available output from a message from the location
    /// of the output cursor in the message being parsed.
    ///
    /// The parse completion block will always be invoked inline exactly once.
    ///
    /// This function must only be called from within the output handler
    /// set with nw_framer_set_output_handler().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `minimum_incomplete_length`: The minimum number of bytes to parse. If this amount is
    /// not available, the parse completion block will be invoked
    /// with 0 bytes.
    ///
    ///
    /// Parameter `maximum_length`: The maximum number of bytes to parse as a contiguous buffer.
    /// If temp_buffer is not NULL, then this represents the length
    /// of valid bytes in temp_buffer.
    ///
    ///
    /// Parameter `temp_buffer`: A buffer provided by the caller to copy parse bytes into.
    /// If it is not NULL, it must have at least maximum_length bytes
    /// available, and any parsed bytes will be copied into the buffer.
    /// Any data stored in temp_buffer will be overwritten.
    /// If it is NULL, the buffer provided in the completion will not
    /// copy unless a copy is required to provide the minimum bytes
    /// as a contiguous buffer. The temp_buffer allows the caller to
    /// guarantee alignment properties of the buffer it parses.
    ///
    ///
    /// Parameter `parse`: The completion that provides the bytes to parse, which will
    /// be called exactly once.
    ///
    ///
    /// Returns: Returns true if the parse succeeded, or false if not enough
    /// bytes were available.
    ///
    /// # Safety
    ///
    /// - `temp_buffer` must be a valid pointer or null.
    /// - `parse` must be a valid pointer.
    #[doc(alias = "nw_framer_parse_output")]
    #[inline]
    pub unsafe fn parse_output(
        &self,
        minimum_incomplete_length: usize,
        maximum_length: usize,
        temp_buffer: *mut u8,
        parse: nw_framer_parse_completion_t,
    ) -> bool {
        extern "C-unwind" {
            fn nw_framer_parse_output(
                framer: &NWFramer,
                minimum_incomplete_length: usize,
                maximum_length: usize,
                temp_buffer: *mut u8,
                parse: nw_framer_parse_completion_t,
            ) -> bool;
        }
        unsafe {
            nw_framer_parse_output(
                self,
                minimum_incomplete_length,
                maximum_length,
                temp_buffer,
                parse,
            )
        }
    }

    /// Write arbitrary bytes as part of an outbound message. This
    /// is intended to be used for adding headers around application
    /// data, or writing any other data that is generated or transformed
    /// by the protocol instance. It does not pass along data directly
    /// from the application.
    ///
    /// This variant will copy bytes.
    ///
    /// This function may be called as part of any framer callback,
    /// not just the output handler.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `output_buffer`: The bytes to write.
    ///
    ///
    /// Parameter `output_length`: The length of output_buffer.
    ///
    /// # Safety
    ///
    /// `output_buffer` must be a valid pointer.
    #[doc(alias = "nw_framer_write_output")]
    #[inline]
    pub unsafe fn write_output(&self, output_buffer: NonNull<u8>, output_length: usize) {
        extern "C-unwind" {
            fn nw_framer_write_output(
                framer: &NWFramer,
                output_buffer: NonNull<u8>,
                output_length: usize,
            );
        }
        unsafe { nw_framer_write_output(self, output_buffer, output_length) }
    }

    /// Write arbitrary bytes as part of an outbound message. This
    /// is intended to be used for adding headers around application
    /// data, or writing any other data that is generated or transformed
    /// by the protocol instance. It does not pass along data directly
    /// from the application.
    ///
    /// This variant is the same as nw_framer_write_output(), but allows
    /// the implementation to pass its buffer as a dispatch_data_t to
    /// avoid a copy.
    ///
    /// This function may be called as part of any framer callback,
    /// not just the output handler.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `output_data`: A dispatch_data_t to write.
    #[doc(alias = "nw_framer_write_output_data")]
    #[inline]
    pub fn write_output_data(&self, output_data: &DispatchData) {
        extern "C-unwind" {
            fn nw_framer_write_output_data(framer: &NWFramer, output_data: &DispatchData);
        }
        unsafe { nw_framer_write_output_data(self, output_data) }
    }

    /// Write bytes directly from the application without any
    /// transformation or copy. The bytes will start at the current
    /// output cursor used for parsing, and will implicitly advance
    /// the cursor by the length being written.
    ///
    /// This function must only be called from within the output handler
    /// set with nw_framer_set_output_handler().
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `output_length`: The number of application bytes to write. This will advance
    /// the parsing cursor by the specified number of bytes.
    ///
    ///
    /// Returns: Returns true if the write could be completed, otherwise
    /// false if the call was made from an invalid context
    /// or with an invalid number of bytes.
    #[doc(alias = "nw_framer_write_output_no_copy")]
    #[inline]
    pub fn write_output_no_copy(&self, output_length: usize) -> bool {
        extern "C-unwind" {
            fn nw_framer_write_output_no_copy(framer: &NWFramer, output_length: usize) -> bool;
        }
        unsafe { nw_framer_write_output_no_copy(self, output_length) }
    }

    /// Mark the output side of the framer as a pass-through, which
    /// means the framer will not be notified of any further output
    /// data.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    #[doc(alias = "nw_framer_pass_through_output")]
    #[inline]
    pub fn pass_through_output(&self) {
        extern "C-unwind" {
            fn nw_framer_pass_through_output(framer: &NWFramer);
        }
        unsafe { nw_framer_pass_through_output(self) }
    }

    /// Schedule a wakeup on the framer instance for a number of
    /// milliseconds into the future. If this is called multiple
    /// times before the timeout is reached, the new value replaces
    /// the previous value.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `milliseconds`: The number of milliseconds into the future at which to
    /// invoke the wakeup handler. Pass the reserved value
    /// NW_FRAMER_WAKEUP_TIME_FOREVER to push the wakeup timer
    /// out to "forever", effectively unscheduling the timer.
    #[doc(alias = "nw_framer_schedule_wakeup")]
    #[inline]
    pub fn schedule_wakeup(&self, milliseconds: u64) {
        extern "C-unwind" {
            fn nw_framer_schedule_wakeup(framer: &NWFramer, milliseconds: u64);
        }
        unsafe { nw_framer_schedule_wakeup(self, milliseconds) }
    }
}

/// A block to perform actions on a framer's scheduling context.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_block_t?language=objc)
pub type nw_framer_block_t = *mut block2::DynBlock<dyn Fn()>;

impl NWFramer {
    /// Schedule a block asynchronously on the framer instance. This
    /// must be used anytime the caller wants to perform any other
    /// action on the framer instance while not directly in the call stack
    /// of a callback from the framer.
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `async_block`: A block to execute on the correct scheduling context for the
    /// framer instance.
    ///
    /// # Safety
    ///
    /// `async_block` must be a valid pointer.
    #[doc(alias = "nw_framer_async")]
    #[inline]
    pub unsafe fn r#async(&self, async_block: nw_framer_block_t) {
        extern "C-unwind" {
            fn nw_framer_async(framer: &NWFramer, async_block: nw_framer_block_t);
        }
        unsafe { nw_framer_async(self, async_block) }
    }

    /// Access the remote endpoint being used for a given
    /// instance of a framer.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance.
    ///
    ///
    /// Returns: Returns a retained endpoint object representing
    /// the remote side of a connection.
    #[doc(alias = "nw_framer_copy_remote_endpoint")]
    #[inline]
    pub fn remote_endpoint(&self) -> NWRetained<NWEndpoint> {
        extern "C-unwind" {
            fn nw_framer_copy_remote_endpoint(framer: &NWFramer) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_framer_copy_remote_endpoint(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Access the local endpoint being used for a given
    /// instance of a framer.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance.
    ///
    ///
    /// Returns: Returns a retained endpoint object representing
    /// the local side of a connection.
    #[doc(alias = "nw_framer_copy_local_endpoint")]
    #[inline]
    pub fn local_endpoint(&self) -> NWRetained<NWEndpoint> {
        extern "C-unwind" {
            fn nw_framer_copy_local_endpoint(framer: &NWFramer) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_framer_copy_local_endpoint(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Access the parameters being used for a given
    /// instance of a framer.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance.
    ///
    ///
    /// Returns: Returns a retained parameters object.
    #[doc(alias = "nw_framer_copy_parameters")]
    #[inline]
    pub fn parameters(&self) -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_framer_copy_parameters(framer: &NWFramer) -> Option<NonNull<NWParameters>>;
        }
        let ret = unsafe { nw_framer_copy_parameters(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Access the protocol options being used for a given
    /// instance of a framer.
    ///
    ///
    /// Parameter `framer`: The framer instance.
    ///
    ///
    /// Returns: Returns a retained protocol options object.
    #[doc(alias = "nw_framer_copy_options")]
    #[inline]
    pub fn options(&self) -> NWRetained<NWProtocolOptions> {
        extern "C-unwind" {
            fn nw_framer_copy_options(framer: &NWFramer) -> Option<NonNull<NWProtocolOptions>>;
        }
        let ret = unsafe { nw_framer_copy_options(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

/// Access the definition of the default system protocol implementation
/// of IP (Internet Protocol). This protocol can be used
/// as part of a connection's protocol stack as the internet protocol.
///
///
/// Returns: Returns a retained protocol definition object.
#[inline]
pub extern "C-unwind" fn nw_protocol_copy_ip_definition() -> NWRetained<NWProtocolDefinition> {
    extern "C-unwind" {
        fn nw_protocol_copy_ip_definition() -> Option<NonNull<NWProtocolDefinition>>;
    }
    let ret = unsafe { nw_protocol_copy_ip_definition() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// A specific version of the Internet Protocol.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ip_version_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_ip_version_t(pub c_uint);
impl nw_ip_version_t {
    #[doc(alias = "nw_ip_version_any")]
    pub const any: Self = Self(0);
    #[doc(alias = "nw_ip_version_4")]
    pub const v4: Self = Self(4);
    #[doc(alias = "nw_ip_version_6")]
    pub const v6: Self = Self(6);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ip_version_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ip_version_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Specify a single version of the Internet Protocol to allow.
/// Setting this value will constrain which address endpoints can
/// be used, and will filter DNS results during connection establishment.
///
///
/// Parameter `options`: An IP protocol options object.
///
///
/// Parameter `version`: A specific, restricted IP version.
#[inline]
pub extern "C-unwind" fn nw_ip_options_set_version(
    options: &NWProtocolOptions,
    version: nw_ip_version_t,
) {
    extern "C-unwind" {
        fn nw_ip_options_set_version(options: &NWProtocolOptions, version: nw_ip_version_t);
    }
    unsafe { nw_ip_options_set_version(options, version) }
}

/// Configure the IP hop limit (or 'TTL' for IPv4).
///
///
/// Parameter `options`: An IP protocol options object.
///
///
/// Parameter `hop_limit`: The hop limit to set on outgoing IP packets.
#[inline]
pub extern "C-unwind" fn nw_ip_options_set_hop_limit(options: &NWProtocolOptions, hop_limit: u8) {
    extern "C-unwind" {
        fn nw_ip_options_set_hop_limit(options: &NWProtocolOptions, hop_limit: u8);
    }
    unsafe { nw_ip_options_set_hop_limit(options, hop_limit) }
}

/// Configure IP to use the minimum MTU value, which
/// is 1280 bytes for IPv6. This value has no effect for
/// IPv4.
///
///
/// Parameter `options`: An IP protocol options object.
///
///
/// Parameter `use_minimum_mtu`: A boolean indicating that the IP should use
/// its minimum MTU value.
#[inline]
pub extern "C-unwind" fn nw_ip_options_set_use_minimum_mtu(
    options: &NWProtocolOptions,
    use_minimum_mtu: bool,
) {
    extern "C-unwind" {
        fn nw_ip_options_set_use_minimum_mtu(options: &NWProtocolOptions, use_minimum_mtu: bool);
    }
    unsafe { nw_ip_options_set_use_minimum_mtu(options, use_minimum_mtu) }
}

/// Configure IP to disable fragmentation on outgoing
/// packets.
///
///
/// Parameter `options`: An IP protocol options object.
///
///
/// Parameter `disable_fragmentation`: A boolean indicating that the IP should use
/// disable fragmentation on outgoing packets.
#[inline]
pub extern "C-unwind" fn nw_ip_options_set_disable_fragmentation(
    options: &NWProtocolOptions,
    disable_fragmentation: bool,
) {
    extern "C-unwind" {
        fn nw_ip_options_set_disable_fragmentation(
            options: &NWProtocolOptions,
            disable_fragmentation: bool,
        );
    }
    unsafe { nw_ip_options_set_disable_fragmentation(options, disable_fragmentation) }
}

/// Configure IP to calculate receive time for inbound
/// packets.
///
///
/// Parameter `options`: An IP protocol options object.
///
///
/// Parameter `calculate_receive_time`: A boolean indicating that the IP packets
/// should mark their receive time in IP metadata.
#[inline]
pub extern "C-unwind" fn nw_ip_options_set_calculate_receive_time(
    options: &NWProtocolOptions,
    calculate_receive_time: bool,
) {
    extern "C-unwind" {
        fn nw_ip_options_set_calculate_receive_time(
            options: &NWProtocolOptions,
            calculate_receive_time: bool,
        );
    }
    unsafe { nw_ip_options_set_calculate_receive_time(options, calculate_receive_time) }
}

/// Preference for local addresses selection.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ip_local_address_preference_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_ip_local_address_preference_t(pub c_uint);
impl nw_ip_local_address_preference_t {
    #[doc(alias = "nw_ip_local_address_preference_default")]
    pub const default: Self = Self(0);
    #[doc(alias = "nw_ip_local_address_preference_temporary")]
    pub const temporary: Self = Self(1);
    #[doc(alias = "nw_ip_local_address_preference_stable")]
    pub const stable: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ip_local_address_preference_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ip_local_address_preference_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Specify a preference for how to select local addresses for outbound
/// connections.
///
///
/// Parameter `options`: An IP protocol options object.
///
///
/// Parameter `preference`: Preference for how to select local addresses.
#[inline]
pub extern "C-unwind" fn nw_ip_options_set_local_address_preference(
    options: &NWProtocolOptions,
    preference: nw_ip_local_address_preference_t,
) {
    extern "C-unwind" {
        fn nw_ip_options_set_local_address_preference(
            options: &NWProtocolOptions,
            preference: nw_ip_local_address_preference_t,
        );
    }
    unsafe { nw_ip_options_set_local_address_preference(options, preference) }
}

/// If a multicast packet is sent to a group to which the sending host itself
/// belongs (on the outgoing interface), a copy of the datagram is, by default,
/// looped back by the IP layer for local delivery.
/// Setting the disable_multicast_loopback option disables this behavior and,
/// if set, multicast packets will not be looped back to the sender.
/// Only applies to multicast packets.
///
///
/// Parameter `options`: An IP protocol options object.
///
///
/// Parameter `disable_multicast_loopback`: If multicast loopback should be disabled.
#[inline]
pub extern "C-unwind" fn nw_ip_options_set_disable_multicast_loopback(
    options: &NWProtocolOptions,
    disable_multicast_loopback: bool,
) {
    extern "C-unwind" {
        fn nw_ip_options_set_disable_multicast_loopback(
            options: &NWProtocolOptions,
            disable_multicast_loopback: bool,
        );
    }
    unsafe { nw_ip_options_set_disable_multicast_loopback(options, disable_multicast_loopback) }
}

/// Create an instance of IP metadata that can be used
/// to configure per-packet options when sending data
/// on a connection.
///
///
/// Returns: Returns a retained protocol metadata object.
#[inline]
pub extern "C-unwind" fn nw_ip_create_metadata() -> NWRetained<NWProtocolMetadata> {
    extern "C-unwind" {
        fn nw_ip_create_metadata() -> Option<NonNull<NWProtocolMetadata>>;
    }
    let ret = unsafe { nw_ip_create_metadata() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

impl NWProtocolMetadata {
    /// Checks if a protocol metadata object is compatible with the
    /// accessors defined in this file for the default system
    /// implementation of IP.
    ///
    ///
    /// Returns: Returns true if the metadata is for the default system IP,
    /// false otherwise.
    #[doc(alias = "nw_protocol_metadata_is_ip")]
    #[inline]
    pub fn is_ip(&self) -> bool {
        extern "C-unwind" {
            fn nw_protocol_metadata_is_ip(metadata: &NWProtocolMetadata) -> bool;
        }
        unsafe { nw_protocol_metadata_is_ip(self) }
    }
}

/// ECN flags marked in IP headers to indicate congestion.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ip_ecn_flag_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_ip_ecn_flag_t(pub c_uint);
impl nw_ip_ecn_flag_t {
    #[doc(alias = "nw_ip_ecn_flag_non_ect")]
    pub const non_ect: Self = Self(0);
    #[doc(alias = "nw_ip_ecn_flag_ect_0")]
    pub const ect_0: Self = Self(2);
    #[doc(alias = "nw_ip_ecn_flag_ect_1")]
    pub const ect_1: Self = Self(1);
    #[doc(alias = "nw_ip_ecn_flag_ce")]
    pub const ce: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ip_ecn_flag_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ip_ecn_flag_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Sets ECN flags on IP metadata. This will take effect if
/// applied to any sent content.
///
///
/// Parameter `metadata`: An IP metadata object.
///
///
/// Parameter `ecn_flag`: The ECN flag to apply to packets.
#[inline]
pub extern "C-unwind" fn nw_ip_metadata_set_ecn_flag(
    metadata: &NWProtocolMetadata,
    ecn_flag: nw_ip_ecn_flag_t,
) {
    extern "C-unwind" {
        fn nw_ip_metadata_set_ecn_flag(metadata: &NWProtocolMetadata, ecn_flag: nw_ip_ecn_flag_t);
    }
    unsafe { nw_ip_metadata_set_ecn_flag(metadata, ecn_flag) }
}

/// Gets ECN flags from IP metadata. This will be set only
/// for metadata associated with received content.
///
///
/// Parameter `metadata`: An IP metadata object.
///
///
/// Returns: Returns the ECN flag received from a packet.
#[inline]
pub extern "C-unwind" fn nw_ip_metadata_get_ecn_flag(
    metadata: &NWProtocolMetadata,
) -> nw_ip_ecn_flag_t {
    extern "C-unwind" {
        fn nw_ip_metadata_get_ecn_flag(metadata: &NWProtocolMetadata) -> nw_ip_ecn_flag_t;
    }
    unsafe { nw_ip_metadata_get_ecn_flag(metadata) }
}

/// Sets service class on IP metadata. This will not generally
/// translate into TOS or Traffic Class bits unless the network
/// explicitly supports it, but it will impact local queuing of
/// packets.
///
///
/// Parameter `metadata`: An IP metadata object.
///
///
/// Parameter `service_class`: The service class to apply to packets.
#[inline]
pub extern "C-unwind" fn nw_ip_metadata_set_service_class(
    metadata: &NWProtocolMetadata,
    service_class: nw_service_class_t,
) {
    extern "C-unwind" {
        fn nw_ip_metadata_set_service_class(
            metadata: &NWProtocolMetadata,
            service_class: nw_service_class_t,
        );
    }
    unsafe { nw_ip_metadata_set_service_class(metadata, service_class) }
}

/// Gets service class from IP metadata. This reflects the value
/// set using nw_ip_metadata_set_service_class. It will not
/// be received from the network.
///
///
/// Parameter `metadata`: An IP metadata object.
///
///
/// Returns: Returns the service class set on a packet.
#[inline]
pub extern "C-unwind" fn nw_ip_metadata_get_service_class(
    metadata: &NWProtocolMetadata,
) -> nw_service_class_t {
    extern "C-unwind" {
        fn nw_ip_metadata_get_service_class(metadata: &NWProtocolMetadata) -> nw_service_class_t;
    }
    unsafe { nw_ip_metadata_get_service_class(metadata) }
}

/// Access the time at which a packet was received. This is
/// useful for calculating precise timing for round-trip-time
/// estimates. Same as clock_gettime_nsec_np(CLOCK_MONOTONIC_RAW).
///
/// The receive time will be 0 unless timestamps have been enabled
/// using nw_ip_options_set_calculate_receive_time().
///
///
/// Parameter `metadata`: An IP metadata object.
///
///
/// Returns: Returns the time that the packet was received.
#[inline]
pub extern "C-unwind" fn nw_ip_metadata_get_receive_time(metadata: &NWProtocolMetadata) -> u64 {
    extern "C-unwind" {
        fn nw_ip_metadata_get_receive_time(metadata: &NWProtocolMetadata) -> u64;
    }
    unsafe { nw_ip_metadata_get_receive_time(metadata) }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_listener?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_listener: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_listener_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_listener_t = NSObject;

/// Listener states sent by nw_listener_set_state_changed_handler.
/// States progress forward and do not move backwards.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_listener_state_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_listener_state_t(pub c_uint);
impl nw_listener_state_t {
    /// will never be delivered in the listener's state update handler, and can be treated as
    /// an unexpected value.
    #[doc(alias = "nw_listener_state_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_listener_state_waiting")]
    pub const waiting: Self = Self(1);
    #[doc(alias = "nw_listener_state_ready")]
    pub const ready: Self = Self(2);
    #[doc(alias = "nw_listener_state_failed")]
    pub const failed: Self = Self(3);
    #[doc(alias = "nw_listener_state_cancelled")]
    pub const cancelled: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_listener_state_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_listener_state_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWListener {
    /// Creates a networking listener bound to a specified local port.
    ///
    ///
    /// Parameter `port`: A port number as a C string, such as "443", or a service
    /// name, such as "https".
    ///
    ///
    /// Parameter `parameters`: The parameters to use for the listener. These include the protocols to be
    /// used for the listener.
    ///
    ///
    /// Returns: Returns an allocated nw_listener_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    ///
    /// # Safety
    ///
    /// `port` must be a valid pointer.
    #[doc(alias = "nw_listener_create_with_port")]
    #[inline]
    pub unsafe fn with_port(
        port: NonNull<c_char>,
        parameters: &NWParameters,
    ) -> Option<NWRetained<NWListener>> {
        extern "C-unwind" {
            fn nw_listener_create_with_port(
                port: NonNull<c_char>,
                parameters: &NWParameters,
            ) -> Option<NonNull<NWListener>>;
        }
        let ret = unsafe { nw_listener_create_with_port(port, parameters) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Creates a network listener from a launchd key.
    ///
    ///
    /// Parameter `parameters`: The parameters to use for the listener. These include the protocols to be
    /// used for the listener. Since launchd creates the listening sockets, these
    /// parameters may not be applied in all cases.
    ///
    ///
    /// Parameter `launchd_key`: The name of the socket entry as specified in the launchd.plist.
    ///
    ///
    /// Returns: Returns an allocated nw_listener_t object.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    ///
    /// # Safety
    ///
    /// `launchd_key` must be a valid pointer.
    #[doc(alias = "nw_listener_create_with_launchd_key")]
    #[inline]
    pub unsafe fn with_launchd_key(
        parameters: &NWParameters,
        launchd_key: NonNull<c_char>,
    ) -> NWRetained<NWListener> {
        extern "C-unwind" {
            fn nw_listener_create_with_launchd_key(
                parameters: &NWParameters,
                launchd_key: NonNull<c_char>,
            ) -> Option<NonNull<NWListener>>;
        }
        let ret = unsafe { nw_listener_create_with_launchd_key(parameters, launchd_key) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a networking listener. The listener will be assigned a random
    /// port upon which to listen unless otherwise specified by the parameters.
    ///
    ///
    /// Parameter `parameters`: The parameters to use for the listener. These include the protocols to be
    /// used for the listener.
    ///
    ///
    /// Returns: Returns an allocated nw_listener_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_listener_create")]
    #[inline]
    pub fn new(parameters: &NWParameters) -> Option<NWRetained<NWListener>> {
        extern "C-unwind" {
            fn nw_listener_create(parameters: &NWParameters) -> Option<NonNull<NWListener>>;
        }
        let ret = unsafe { nw_listener_create(parameters) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Creates a networking listener based on an existing
    /// multiplexing connection. If there are multiple protocols
    /// in the connection that support listening for incoming flows,
    /// the listener will be hooked up the highest in the stack
    /// (the closest to the reading and writing of the client data).
    ///
    ///
    /// Parameter `connection`: An existing connection that has a multiplexing protocol
    /// that supports receiving new connections.
    ///
    ///
    /// Parameter `parameters`: The parameters to use for the listener. The protocol stack
    /// defined in the parameters must be able to join a protocol
    /// in the connection that supports listening protocols.
    ///
    ///
    /// Returns: Returns an allocated nw_listener_t object on success. Use nw_release() to deallocate.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_listener_create_with_connection")]
    #[inline]
    pub fn with_connection(
        connection: &NWConnection,
        parameters: &NWParameters,
    ) -> Option<NWRetained<NWListener>> {
        extern "C-unwind" {
            fn nw_listener_create_with_connection(
                connection: &NWConnection,
                parameters: &NWParameters,
            ) -> Option<NonNull<NWListener>>;
        }
        let ret = unsafe { nw_listener_create_with_connection(connection, parameters) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Sets the client callback queue, on which blocks for events will
    /// be scheduled. This must be done before calling nw_listener_start().
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Parameter `queue`: The client's dispatch queue.
    #[doc(alias = "nw_listener_set_queue")]
    #[inline]
    pub fn set_queue(&self, queue: &DispatchQueue) {
        extern "C-unwind" {
            fn nw_listener_set_queue(listener: &NWListener, queue: &DispatchQueue);
        }
        unsafe { nw_listener_set_queue(self, queue) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_listener_state_changed_handler_t?language=objc)
pub type nw_listener_state_changed_handler_t =
    *mut block2::DynBlock<dyn Fn(nw_listener_state_t, *mut NWError)>;

impl NWListener {
    /// Sets the state change handler. For clients that need to perform cleanup when the
    /// connection has been cancelled, the nw_listener_state_cancelled state will
    /// be delivered last.
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Parameter `handler`: The state changed handler to call when the listener state changes.
    /// Pass NULL to remove the event handler.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_listener_set_state_changed_handler")]
    #[inline]
    pub unsafe fn set_state_changed_handler(&self, handler: nw_listener_state_changed_handler_t) {
        extern "C-unwind" {
            fn nw_listener_set_state_changed_handler(
                listener: &NWListener,
                handler: nw_listener_state_changed_handler_t,
            );
        }
        unsafe { nw_listener_set_state_changed_handler(self, handler) }
    }
}

/// The block called to notify client of a new connection.
///
///
/// Parameter `connection`: The new connection object. This connection is not yet started. Set the
/// event handler and other settings on the connection before calling start.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_listener_new_connection_handler_t?language=objc)
pub type nw_listener_new_connection_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWConnection>)>;

impl NWListener {
    /// Sets the client new connection handler. Must be called before
    /// nw_listener_start.
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Parameter `handler`: The event handler to call when the listener receives a new connection.
    /// Pass NULL to remove the new connection handler.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_listener_set_new_connection_handler")]
    #[inline]
    pub unsafe fn set_new_connection_handler(&self, handler: nw_listener_new_connection_handler_t) {
        extern "C-unwind" {
            fn nw_listener_set_new_connection_handler(
                listener: &NWListener,
                handler: nw_listener_new_connection_handler_t,
            );
        }
        unsafe { nw_listener_set_new_connection_handler(self, handler) }
    }
}

/// The block called to notify the client of a new connection group.
///
///
/// Parameter `connection_group`: The new connection group object. This connection group is not yet started. Set the
/// event handler and other settings on the connection group before calling start.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_listener_new_connection_group_handler_t?language=objc)
pub type nw_listener_new_connection_group_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWConnectionGroup>)>;

impl NWListener {
    /// Sets a new connection group handler to be called upon receiving an incoming
    /// connection that has a multiplexing protocol in its connected protocol stack.
    /// Must be called before nw_listener_start. Note that this handler is mutually
    /// exclusive with the new connection handler that is set via
    /// nw_listener_set_new_connection_handler. Only one of these handlers may
    /// be set at one time.
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Parameter `handler`: The event handler to call when the listener receives a new connection group.
    /// Pass NULL to remove the new connection group handler.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_listener_set_new_connection_group_handler")]
    #[inline]
    pub unsafe fn set_new_connection_group_handler(
        &self,
        handler: nw_listener_new_connection_group_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_listener_set_new_connection_group_handler(
                listener: &NWListener,
                handler: nw_listener_new_connection_group_handler_t,
            );
        }
        unsafe { nw_listener_set_new_connection_group_handler(self, handler) }
    }

    /// Gets the listener new connection limit. The default value is
    /// NW_LISTENER_INFINITE_CONNECTION_LIMIT which indicates that
    /// the listener should not limit incoming connections. If the value
    /// is not NW_LISTENER_INFINITE_CONNECTION_LIMIT, it will be decremented
    /// by 1 every time a new connection is created. When the value becomes
    /// 0, new connection handlers will no longer be invoked until
    /// nw_listener_set_new_connection_limit() is invoked with a value
    /// that is greater than 0. Incoming connections will eventually be rejected
    /// if nw_listener_set_new_connection_limit() is not called after the connection
    /// limit reaches 0.
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Returns: Returns current new connection limit
    #[doc(alias = "nw_listener_get_new_connection_limit")]
    #[inline]
    pub fn new_connection_limit(&self) -> u32 {
        extern "C-unwind" {
            fn nw_listener_get_new_connection_limit(listener: &NWListener) -> u32;
        }
        unsafe { nw_listener_get_new_connection_limit(self) }
    }

    /// Sets the listener new connection limit. Use the value NW_LISTENER_INFINITE_CONNECTION_LIMIT
    /// to disable connection limits. If the value is not NW_LISTENER_INFINITE_CONNECTION_LIMIT,
    /// it will be decremented by 1 every time a new connection is created. When the value becomes
    /// 0, new connection handlers will no longer be invoked until
    /// nw_listener_set_new_connection_limit() is invoked with a value
    /// that is greater than 0. Incoming connections will eventually be rejected
    /// if nw_listener_set_new_connection_limit() is not called after the connection
    /// limit reaches 0.
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Parameter `new_connection_limit`: The new connection limit. Pass NW_LISTENER_INFINITE_CONNECTION_LIMIT
    /// to disable new connection limiting.
    #[doc(alias = "nw_listener_set_new_connection_limit")]
    #[inline]
    pub fn set_new_connection_limit(&self, new_connection_limit: u32) {
        extern "C-unwind" {
            fn nw_listener_set_new_connection_limit(
                listener: &NWListener,
                new_connection_limit: u32,
            );
        }
        unsafe { nw_listener_set_new_connection_limit(self, new_connection_limit) }
    }

    /// Describes the bonjour service the listener should register. Setting the
    /// advertise descriptor more than once may be used to update the TXT record.
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Parameter `advertise_descriptor`: The advertise_descriptor or NULL to prevent or remove registration of a service.
    #[doc(alias = "nw_listener_set_advertise_descriptor")]
    #[inline]
    pub fn set_advertise_descriptor(&self, advertise_descriptor: Option<&NWAdvertiseDescriptor>) {
        extern "C-unwind" {
            fn nw_listener_set_advertise_descriptor(
                listener: &NWListener,
                advertise_descriptor: Option<&NWAdvertiseDescriptor>,
            );
        }
        unsafe { nw_listener_set_advertise_descriptor(self, advertise_descriptor) }
    }
}

/// A block called to notify client of a change in advertised endpoints.
///
///
/// Parameter `advertised_endpoint`: An endpoint that is has been added or removed from the list of advertised
/// endpoints for the listener.
///
///
/// Parameter `added`: A boolean indicating if the endpoint is being added or removed. If added,
/// the value with be true; if removed, the value will be false.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_listener_advertised_endpoint_changed_handler_t?language=objc)
pub type nw_listener_advertised_endpoint_changed_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWEndpoint>, bool)>;

impl NWListener {
    /// Sets the client advertised endpoint changed handler. The handler will be
    /// invoked for listeners which have called nw_listener_set_advertise_descriptor().
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Parameter `handler`: The event handler to call when the listener adds or removes an advertised endpoint.
    /// Pass NULL to remove the handler.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_listener_set_advertised_endpoint_changed_handler")]
    #[inline]
    pub unsafe fn set_advertised_endpoint_changed_handler(
        &self,
        handler: nw_listener_advertised_endpoint_changed_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_listener_set_advertised_endpoint_changed_handler(
                listener: &NWListener,
                handler: nw_listener_advertised_endpoint_changed_handler_t,
            );
        }
        unsafe { nw_listener_set_advertised_endpoint_changed_handler(self, handler) }
    }

    /// Gets the local port as a number in host byte order. If the listener was created with a
    /// port of 0 (let the system assign a port), nw_listener_get_port will return 0 until the
    /// listener is in the ready state.
    ///
    ///
    /// Parameter `listener`: The listener to get the local port of.
    ///
    ///
    /// Returns: Returns a port in host byte order.
    #[doc(alias = "nw_listener_get_port")]
    #[inline]
    pub fn port(&self) -> u16 {
        extern "C-unwind" {
            fn nw_listener_get_port(listener: &NWListener) -> u16;
        }
        unsafe { nw_listener_get_port(self) }
    }

    /// Starts the listener, which will cause the listener
    /// to start listening for inbound connections.
    ///
    ///
    /// Parameter `listener`: The listener object.
    #[doc(alias = "nw_listener_start")]
    #[inline]
    pub fn start(&self) {
        extern "C-unwind" {
            fn nw_listener_start(listener: &NWListener);
        }
        unsafe { nw_listener_start(self) }
    }

    /// Cancel the listener. This will de-register the listener from the system. The process
    /// of cancellation will be completed asynchronously, and the final callback event
    /// delivered to the caller will be a state update with a value of nw_listener_state_cancelled.
    /// Once this update is delivered, the caller may clean up any associated memory or objects.
    ///
    ///
    /// Parameter `listener`: The listener object.
    #[doc(alias = "nw_listener_cancel")]
    #[inline]
    pub fn cancel(&self) {
        extern "C-unwind" {
            fn nw_listener_cancel(listener: &NWListener);
        }
        unsafe { nw_listener_cancel(self) }
    }
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_path_monitor?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_path_monitor: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_path_monitor_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_path_monitor_t = NSObject;

impl NWPathMonitor {
    /// Create a default path monitor, that will allow the enumeration of all available
    /// interfaces on the system.
    ///
    ///
    /// Returns: Returns an allocated nw_path_monitor_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_path_monitor_create")]
    #[inline]
    pub fn new() -> NWRetained<NWPathMonitor> {
        extern "C-unwind" {
            fn nw_path_monitor_create() -> Option<NonNull<NWPathMonitor>>;
        }
        let ret = unsafe { nw_path_monitor_create() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Create a path monitor specific to an interface type, that will allow the enumeration
    /// of any interface that matches the type on the system.
    ///
    ///
    /// Parameter `required_interface_type`: An interface type that will filter any results that the path monitor returns.
    ///
    ///
    /// Returns: Returns an allocated nw_path_monitor_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_path_monitor_create_with_type")]
    #[inline]
    pub fn with_type(required_interface_type: nw_interface_type_t) -> NWRetained<NWPathMonitor> {
        extern "C-unwind" {
            fn nw_path_monitor_create_with_type(
                required_interface_type: nw_interface_type_t,
            ) -> Option<NonNull<NWPathMonitor>>;
        }
        let ret = unsafe { nw_path_monitor_create_with_type(required_interface_type) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Create a path monitor that enumerates all interfaces that support
    /// Ethernet channel.
    ///
    ///
    /// Returns: Returns an allocated nw_path_monitor_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure.
    #[doc(alias = "nw_path_monitor_create_for_ethernet_channel")]
    #[inline]
    pub fn new_for_ethernet_channel() -> NWRetained<NWPathMonitor> {
        extern "C-unwind" {
            fn nw_path_monitor_create_for_ethernet_channel() -> Option<NonNull<NWPathMonitor>>;
        }
        let ret = unsafe { nw_path_monitor_create_for_ethernet_channel() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Prohibit this path monitor from using the provided network interface type.
    /// Call before calling nw_path_monitor_start.
    ///
    ///
    /// Parameter `monitor`: The path monitor object.
    ///
    ///
    /// Parameter `interface_type`: The interface type to prohibit for the path monitor.
    #[doc(alias = "nw_path_monitor_prohibit_interface_type")]
    #[inline]
    pub fn prohibit_interface_type(&self, interface_type: nw_interface_type_t) {
        extern "C-unwind" {
            fn nw_path_monitor_prohibit_interface_type(
                monitor: &NWPathMonitor,
                interface_type: nw_interface_type_t,
            );
        }
        unsafe { nw_path_monitor_prohibit_interface_type(self, interface_type) }
    }
}

/// A block handler to be called when a path monitor is cancelled. This
/// is used to allow clients to release any objects they have retained in
/// association with the path monitor.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_path_monitor_cancel_handler_t?language=objc)
pub type nw_path_monitor_cancel_handler_t = *mut block2::DynBlock<dyn Fn()>;

impl NWPathMonitor {
    /// Set a handler to be called on the queue provided to nw_path_monitor_set_queue
    /// once cancellation has completed. Once the cancel handler has been called, the
    /// update handler will not fire again.
    ///
    ///
    /// Parameter `monitor`: The path monitor object.
    ///
    ///
    /// Parameter `cancel_handler`: The block to call upon cancellation. Pass NULL to remove the cancel handler.
    ///
    /// # Safety
    ///
    /// `cancel_handler` must be a valid pointer.
    #[doc(alias = "nw_path_monitor_set_cancel_handler")]
    #[inline]
    pub unsafe fn set_cancel_handler(&self, cancel_handler: nw_path_monitor_cancel_handler_t) {
        extern "C-unwind" {
            fn nw_path_monitor_set_cancel_handler(
                monitor: &NWPathMonitor,
                cancel_handler: nw_path_monitor_cancel_handler_t,
            );
        }
        unsafe { nw_path_monitor_set_cancel_handler(self, cancel_handler) }
    }
}

/// A block handler to be called whenever a path monitor has a new snapshot.
/// This will be called one or more times after calling nw_path_monitor_start.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_path_monitor_update_handler_t?language=objc)
pub type nw_path_monitor_update_handler_t = *mut block2::DynBlock<dyn Fn(NonNull<NWPath>)>;

impl NWPathMonitor {
    /// Sets the client update handler. This block will be called with the
    /// current path when start is called and any time the path changes.
    ///
    ///
    /// Parameter `monitor`: The path monitor object.
    ///
    ///
    /// Parameter `update_handler`: The block to call when the path changes.
    ///
    /// # Safety
    ///
    /// `update_handler` must be a valid pointer.
    #[doc(alias = "nw_path_monitor_set_update_handler")]
    #[inline]
    pub unsafe fn set_update_handler(&self, update_handler: nw_path_monitor_update_handler_t) {
        extern "C-unwind" {
            fn nw_path_monitor_set_update_handler(
                monitor: &NWPathMonitor,
                update_handler: nw_path_monitor_update_handler_t,
            );
        }
        unsafe { nw_path_monitor_set_update_handler(self, update_handler) }
    }

    /// Sets the client update queue. All blocks will be scheduled on
    /// this queue. Call before calling nw_path_monitor_start.
    ///
    ///
    /// Parameter `monitor`: The path monitor object.
    ///
    ///
    /// Parameter `queue`: The dispatch queue on which to call the update and cancel handlers.
    #[doc(alias = "nw_path_monitor_set_queue")]
    #[inline]
    pub fn set_queue(&self, queue: &DispatchQueue) {
        extern "C-unwind" {
            fn nw_path_monitor_set_queue(monitor: &NWPathMonitor, queue: &DispatchQueue);
        }
        unsafe { nw_path_monitor_set_queue(self, queue) }
    }

    /// Starts the path monitor.
    ///
    ///
    /// Parameter `monitor`: The path monitor object.
    #[doc(alias = "nw_path_monitor_start")]
    #[inline]
    pub fn start(&self) {
        extern "C-unwind" {
            fn nw_path_monitor_start(monitor: &NWPathMonitor);
        }
        unsafe { nw_path_monitor_start(self) }
    }

    /// Cancel the path monitor.
    ///
    ///
    /// Parameter `monitor`: The path monitor object.
    #[doc(alias = "nw_path_monitor_cancel")]
    #[inline]
    pub fn cancel(&self) {
        extern "C-unwind" {
            fn nw_path_monitor_cancel(monitor: &NWPathMonitor);
        }
        unsafe { nw_path_monitor_cancel(self) }
    }
}

/// Access the definition of the default system protocol implementation
/// of QUIC. This protocol can be used as part of a
/// connection's protocol stack as a transport protocol.
///
///
/// Returns: Returns a retained protocol definition object.
#[inline]
pub extern "C-unwind" fn nw_protocol_copy_quic_definition() -> NWRetained<NWProtocolDefinition> {
    extern "C-unwind" {
        fn nw_protocol_copy_quic_definition() -> Option<NonNull<NWProtocolDefinition>>;
    }
    let ret = unsafe { nw_protocol_copy_quic_definition() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Create an instance of QUIC protocol options. This object can be added
/// to an nw_protocol_stack_t to be used in an nw_connection_t or
/// an nw_listener_t.
///
///
/// Returns: Returns a retained protocol options object.
#[inline]
pub extern "C-unwind" fn nw_quic_create_options() -> NWRetained<NWProtocolOptions> {
    extern "C-unwind" {
        fn nw_quic_create_options() -> Option<NonNull<NWProtocolOptions>>;
    }
    let ret = unsafe { nw_quic_create_options() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

impl NWProtocolOptions {
    /// Checks whether the given protocol options define a QUIC protocol.
    ///
    ///
    /// Returns: Returns true if the protocol options are for QUIC, false otherwise.
    #[doc(alias = "nw_protocol_options_is_quic")]
    #[inline]
    pub fn is_quic(&self) -> bool {
        extern "C-unwind" {
            fn nw_protocol_options_is_quic(options: &NWProtocolOptions) -> bool;
        }
        unsafe { nw_protocol_options_is_quic(self) }
    }
}

extern "C-unwind" {
    /// Adds an Application-Layer Protocol Negotiation (ALPN) value to present in the TLS handshake.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    /// # Safety
    ///
    /// `application_protocol` must be a valid pointer.
    pub fn nw_quic_add_tls_application_protocol(
        options: &NWProtocolOptions,
        application_protocol: NonNull<c_char>,
    );
}

/// Returns whether or not a QUIC stream is unidirectional.
///
///
/// Parameter `options`: An nw_protocol_options_t for a QUIC stream.
///
///
/// Returns: True if the stream is unidirectional, false otherwise.
#[inline]
pub extern "C-unwind" fn nw_quic_get_stream_is_unidirectional(options: &NWProtocolOptions) -> bool {
    extern "C-unwind" {
        fn nw_quic_get_stream_is_unidirectional(options: &NWProtocolOptions) -> bool;
    }
    unsafe { nw_quic_get_stream_is_unidirectional(options) }
}

/// Set whether or not a QUIC stream should be unidirectional.
///
///
/// Parameter `options`: An nw_protocol_options_t for a QUIC stream.
///
///
/// Parameter `is_unidirectional`: True if the stream is unidirectional, false otherwise.
#[inline]
pub extern "C-unwind" fn nw_quic_set_stream_is_unidirectional(
    options: &NWProtocolOptions,
    is_unidirectional: bool,
) {
    extern "C-unwind" {
        fn nw_quic_set_stream_is_unidirectional(
            options: &NWProtocolOptions,
            is_unidirectional: bool,
        );
    }
    unsafe { nw_quic_set_stream_is_unidirectional(options, is_unidirectional) }
}

/// Get whether or not the QUIC stream is a QUIC datagram flow.
///
///
/// Parameter `options`: An nw_protocol_options_t for QUIC.
///
///
/// Returns: is_datagram
/// True if the QUIC stream is a QUIC datagram flow.
#[inline]
pub extern "C-unwind" fn nw_quic_get_stream_is_datagram(options: &NWProtocolOptions) -> bool {
    extern "C-unwind" {
        fn nw_quic_get_stream_is_datagram(options: &NWProtocolOptions) -> bool;
    }
    unsafe { nw_quic_get_stream_is_datagram(options) }
}

/// Set whether or not the QUIC stream should be a QUIC datagram flow.
/// Only one QUIC datagram flow can be created per connection.
///
///
/// Parameter `options`: An nw_protocol_options_t for QUIC.
///
///
/// Parameter `is_datagram`: A boolean to indicate whether or not the QUIC stream should be a QUIC datagram flow.
#[inline]
pub extern "C-unwind" fn nw_quic_set_stream_is_datagram(
    options: &NWProtocolOptions,
    is_datagram: bool,
) {
    extern "C-unwind" {
        fn nw_quic_set_stream_is_datagram(options: &NWProtocolOptions, is_datagram: bool);
    }
    unsafe { nw_quic_set_stream_is_datagram(options, is_datagram) }
}

/// Get the initial_max_data transport parameter on a QUIC
/// connection.
///
///
/// Parameter `options`: An nw_protocol_options_t for QUIC.
///
///
/// Returns: The initial_max_data that a client
/// is willing to receive on a connection.
#[inline]
pub extern "C-unwind" fn nw_quic_get_initial_max_data(options: &NWProtocolOptions) -> u64 {
    extern "C-unwind" {
        fn nw_quic_get_initial_max_data(options: &NWProtocolOptions) -> u64;
    }
    unsafe { nw_quic_get_initial_max_data(options) }
}

/// Set the initial_max_data transport parameter on a QUIC
/// connection. Setting this option requires
/// initial_max_stream_data_bidirectional_local,
/// initial_max_stream_data_bidirectional_remote and
/// initial_max_stream_data_unidirectional also to be set.
///
///
/// Parameter `options`: An nw_protocol_options_t for QUIC.
///
///
/// Parameter `initial_max_data`: The initial_max_data controls how much data, in bytes, a client
/// is willing to receive on a connection.
#[inline]
pub extern "C-unwind" fn nw_quic_set_initial_max_data(
    options: &NWProtocolOptions,
    initial_max_data: u64,
) {
    extern "C-unwind" {
        fn nw_quic_set_initial_max_data(options: &NWProtocolOptions, initial_max_data: u64);
    }
    unsafe { nw_quic_set_initial_max_data(options, initial_max_data) }
}

/// Get the maximum length of a QUIC packet (UDP payload)
/// that the client is willing to receive on a connection, in bytes.
///
///
/// Parameter `options`: An nw_protocol_options_t for QUIC.
///
///
/// Returns: The max_udp_payload_size value, in bytes.
#[inline]
pub extern "C-unwind" fn nw_quic_get_max_udp_payload_size(options: &NWProtocolOptions) -> u16 {
    extern "C-unwind" {
        fn nw_quic_get_max_udp_payload_size(options: &NWProtocolOptions) -> u16;
    }
    unsafe { nw_quic_get_max_udp_payload_size(options) }
}

/// Define the maximum length of a QUIC packet (UDP payload)
/// that the client is willing to receive on a connection, in bytes.
///
///
/// Parameter `options`: An nw_protocol_options_t for QUIC.
///
///
/// Parameter `max_udp_payload_size`: The max_udp_payload_size value, in bytes.
#[inline]
pub extern "C-unwind" fn nw_quic_set_max_udp_payload_size(
    options: &NWProtocolOptions,
    max_udp_payload_size: u16,
) {
    extern "C-unwind" {
        fn nw_quic_set_max_udp_payload_size(options: &NWProtocolOptions, max_udp_payload_size: u16);
    }
    unsafe { nw_quic_set_max_udp_payload_size(options, max_udp_payload_size) }
}

/// Get the idle timeout value for the QUIC connection. If no packets are sent or received
/// within this timeout, the QUIC connection will be closed.
///
///
/// Parameter `options`: An nw_protocol_options_t for QUIC.
///
///
/// Returns: The idle_timeout value, in milliseconds.
#[inline]
pub extern "C-unwind" fn nw_quic_get_idle_timeout(options: &NWProtocolOptions) -> u32 {
    extern "C-unwind" {
        fn nw_quic_get_idle_timeout(options: &NWProtocolOptions) -> u32;
    }
    unsafe { nw_quic_get_idle_timeout(options) }
}

/// Define an idle timeout value for the QUIC connection. If no packets are sent or received
/// within this timeout, the QUIC connection will be closed.
///
///
/// Parameter `options`: An nw_protocol_options_t for QUIC.
///
///
/// Parameter `idle_timeout`: The idle_timeout value, in milliseconds.
#[inline]
pub extern "C-unwind" fn nw_quic_set_idle_timeout(options: &NWProtocolOptions, idle_timeout: u32) {
    extern "C-unwind" {
        fn nw_quic_set_idle_timeout(options: &NWProtocolOptions, idle_timeout: u32);
    }
    unsafe { nw_quic_set_idle_timeout(options, idle_timeout) }
}

/// Get the initial value of maximum bidirectional streams
/// that the peer can initiate on a QUIC connection.
///
///
/// Parameter `options`: An nw_protocol_options_t for QUIC.
///
///
/// Returns: The initial value for the maximum concurrent bidirectional streams.
#[inline]
pub extern "C-unwind" fn nw_quic_get_initial_max_streams_bidirectional(
    options: &NWProtocolOptions,
) -> u64 {
    extern "C-unwind" {
        fn nw_quic_get_initial_max_streams_bidirectional(options: &NWProtocolOptions) -> u64;
    }
    unsafe { nw_quic_get_initial_max_streams_bidirectional(options) }
}

/// Set the initial value of maximum bidirectional streams
/// that the peer can initiate on a QUIC connection.
///
///
/// Parameter `options`: An nw_protocol_options_t for QUIC.
///
///
/// Parameter `initial_max_streams_bidirectional`: The initial value for the maximum concurrent bidirectional streams.
#[inline]
pub extern "C-unwind" fn nw_quic_set_initial_max_streams_bidirectional(
    options: &NWProtocolOptions,
    initial_max_streams_bidirectional: u64,
) {
    extern "C-unwind" {
        fn nw_quic_set_initial_max_streams_bidirectional(
            options: &NWProtocolOptions,
            initial_max_streams_bidirectional: u64,
        );
    }
    unsafe {
        nw_quic_set_initial_max_streams_bidirectional(options, initial_max_streams_bidirectional)
    }
}

/// Get the initial value of maximum unidirectional streams
/// that the peer can initiate on a QUIC connection.
///
///
/// Parameter `options`: An nw_protocol_options_t for QUIC.
///
///
/// Returns: The initial value for the maximum concurrent unidirectional streams.
#[inline]
pub extern "C-unwind" fn nw_quic_get_initial_max_streams_unidirectional(
    options: &NWProtocolOptions,
) -> u64 {
    extern "C-unwind" {
        fn nw_quic_get_initial_max_streams_unidirectional(options: &NWProtocolOptions) -> u64;
    }
    unsafe { nw_quic_get_initial_max_streams_unidirectional(options) }
}

/// Set the initial value of maximum unidirectional streams
/// that the peer can initiate on a QUIC connection.
///
///
/// Parameter `options`: An nw_protocol_options_t for QUIC.
///
///
/// Parameter `initial_max_streams_unidirectional`: The initial value for the maximum concurrent unidirectional streams.
#[inline]
pub extern "C-unwind" fn nw_quic_set_initial_max_streams_unidirectional(
    options: &NWProtocolOptions,
    initial_max_streams_unidirectional: u64,
) {
    extern "C-unwind" {
        fn nw_quic_set_initial_max_streams_unidirectional(
            options: &NWProtocolOptions,
            initial_max_streams_unidirectional: u64,
        );
    }
    unsafe {
        nw_quic_set_initial_max_streams_unidirectional(options, initial_max_streams_unidirectional)
    }
}

/// Get the initial_max_stream_data_bidi_local transport parameter
/// on a QUIC connection.
///
///
/// Parameter `options`: An nw_protocol_options_t for QUIC.
///
///
/// Returns: How much data the client is willing to receive on a locally initiated stream.
#[inline]
pub extern "C-unwind" fn nw_quic_get_initial_max_stream_data_bidirectional_local(
    options: &NWProtocolOptions,
) -> u64 {
    extern "C-unwind" {
        fn nw_quic_get_initial_max_stream_data_bidirectional_local(
            options: &NWProtocolOptions,
        ) -> u64;
    }
    unsafe { nw_quic_get_initial_max_stream_data_bidirectional_local(options) }
}

/// Set the initial_max_stream_data_bidi_local transport parameter
/// on a QUIC connection.
///
///
/// Parameter `options`: An nw_protocol_options_t for QUIC.
///
///
/// Parameter `initial_max_stream_data_bidirectional_local`: The initial_max_stream_data_bidi_local controls how much data
/// the client is willing to receive on a locally initiated stream.
#[inline]
pub extern "C-unwind" fn nw_quic_set_initial_max_stream_data_bidirectional_local(
    options: &NWProtocolOptions,
    initial_max_stream_data_bidirectional_local: u64,
) {
    extern "C-unwind" {
        fn nw_quic_set_initial_max_stream_data_bidirectional_local(
            options: &NWProtocolOptions,
            initial_max_stream_data_bidirectional_local: u64,
        );
    }
    unsafe {
        nw_quic_set_initial_max_stream_data_bidirectional_local(
            options,
            initial_max_stream_data_bidirectional_local,
        )
    }
}

/// Get the initial_max_stream_data_bidi_remote transport parameter
/// on a QUIC connection.
///
///
/// Parameter `options`: An nw_protocol_options_t for QUIC.
///
///
/// Returns: How much data the client is willing to receive on a remotely initiated stream.
#[inline]
pub extern "C-unwind" fn nw_quic_get_initial_max_stream_data_bidirectional_remote(
    options: &NWProtocolOptions,
) -> u64 {
    extern "C-unwind" {
        fn nw_quic_get_initial_max_stream_data_bidirectional_remote(
            options: &NWProtocolOptions,
        ) -> u64;
    }
    unsafe { nw_quic_get_initial_max_stream_data_bidirectional_remote(options) }
}

/// Set the initial_max_stream_data_bidi_remote transport parameter
/// on a QUIC connection.
///
///
/// Parameter `options`: An nw_protocol_options_t for QUIC.
///
///
/// Parameter `initial_max_stream_data_bidirectional_remote`: The initial_max_stream_data_bidi_remote controls how much data
/// the client is willing to receive on a remotely initiated stream.
#[inline]
pub extern "C-unwind" fn nw_quic_set_initial_max_stream_data_bidirectional_remote(
    options: &NWProtocolOptions,
    initial_max_stream_data_bidirectional_remote: u64,
) {
    extern "C-unwind" {
        fn nw_quic_set_initial_max_stream_data_bidirectional_remote(
            options: &NWProtocolOptions,
            initial_max_stream_data_bidirectional_remote: u64,
        );
    }
    unsafe {
        nw_quic_set_initial_max_stream_data_bidirectional_remote(
            options,
            initial_max_stream_data_bidirectional_remote,
        )
    }
}

/// Get the initial_max_stream_data_uni transport parameter
/// on a QUIC connection.
///
///
/// Parameter `options`: An nw_protocol_options_t for QUIC.
///
///
/// Returns: How much data the client is willing to receive on a unidirectional stream.
#[inline]
pub extern "C-unwind" fn nw_quic_get_initial_max_stream_data_unidirectional(
    options: &NWProtocolOptions,
) -> u64 {
    extern "C-unwind" {
        fn nw_quic_get_initial_max_stream_data_unidirectional(options: &NWProtocolOptions) -> u64;
    }
    unsafe { nw_quic_get_initial_max_stream_data_unidirectional(options) }
}

/// Set the initial_max_stream_data_uni transport parameter
/// on a QUIC connection.
///
///
/// Parameter `options`: An nw_protocol_options_t for QUIC.
///
///
/// Parameter `initial_max_stream_data_unidirectional`: The initial_max_stream_data_uni controls how much data
/// the client is willing to receive on a unidirectional stream.
#[inline]
pub extern "C-unwind" fn nw_quic_set_initial_max_stream_data_unidirectional(
    options: &NWProtocolOptions,
    initial_max_stream_data_unidirectional: u64,
) {
    extern "C-unwind" {
        fn nw_quic_set_initial_max_stream_data_unidirectional(
            options: &NWProtocolOptions,
            initial_max_stream_data_unidirectional: u64,
        );
    }
    unsafe {
        nw_quic_set_initial_max_stream_data_unidirectional(
            options,
            initial_max_stream_data_unidirectional,
        )
    }
}

/// Get the max_datagram_frame_size transport parameter
/// on a QUIC connection.
///
///
/// Parameter `options`: An nw_protocol_options_t for QUIC.
///
///
/// Returns: If greater than zero, the max_datagram_frame_size value indicates that
/// DATAGRAM frames are supported, and describes the maximum number
/// of bytes that a single DATAGRAM frame can contain.
#[inline]
pub extern "C-unwind" fn nw_quic_get_max_datagram_frame_size(options: &NWProtocolOptions) -> u16 {
    extern "C-unwind" {
        fn nw_quic_get_max_datagram_frame_size(options: &NWProtocolOptions) -> u16;
    }
    unsafe { nw_quic_get_max_datagram_frame_size(options) }
}

/// Set the max_datagram_frame_size transport parameter
/// on a QUIC connection.
///
///
/// Parameter `options`: An nw_protocol_options_t for QUIC.
///
///
/// Parameter `max_datagram_frame_size`: If greater than zero, the max_datagram_frame_size value indicates that
/// DATAGRAM frames are supported, and describes the maximum number
/// of bytes that a single DATAGRAM frame can contain.
#[inline]
pub extern "C-unwind" fn nw_quic_set_max_datagram_frame_size(
    options: &NWProtocolOptions,
    max_datagram_frame_size: u16,
) {
    extern "C-unwind" {
        fn nw_quic_set_max_datagram_frame_size(
            options: &NWProtocolOptions,
            max_datagram_frame_size: u16,
        );
    }
    unsafe { nw_quic_set_max_datagram_frame_size(options, max_datagram_frame_size) }
}

/// Represents the type of a QUIC stream.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_quic_stream_type_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_quic_stream_type_t(pub c_uint);
impl nw_quic_stream_type_t {
    #[doc(alias = "nw_quic_stream_type_unknown")]
    pub const unknown: Self = Self(0);
    #[doc(alias = "nw_quic_stream_type_bidirectional")]
    pub const bidirectional: Self = Self(1);
    #[doc(alias = "nw_quic_stream_type_unidirectional")]
    pub const unidirectional: Self = Self(2);
    #[doc(alias = "nw_quic_stream_type_datagram")]
    pub const datagram: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_quic_stream_type_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_quic_stream_type_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWProtocolMetadata {
    /// Checks if a protocol metadata object is compatible with the
    /// accessors defined in this file for the default system
    /// implementation of QUIC.
    ///
    ///
    /// Returns: Returns true if the metadata is for the default system QUIC,
    /// false otherwise.
    #[doc(alias = "nw_protocol_metadata_is_quic")]
    #[inline]
    pub fn is_quic(&self) -> bool {
        extern "C-unwind" {
            fn nw_protocol_metadata_is_quic(metadata: &NWProtocolMetadata) -> bool;
        }
        unsafe { nw_protocol_metadata_is_quic(self) }
    }
}

/// Get the QUIC stream ID.
///
///
/// Parameter `metadata`: A nw_protocol_metadata_t for a QUIC stream.
///
///
/// Returns: Returns the QUIC stream id.
#[inline]
pub extern "C-unwind" fn nw_quic_get_stream_id(metadata: &NWProtocolMetadata) -> u64 {
    extern "C-unwind" {
        fn nw_quic_get_stream_id(metadata: &NWProtocolMetadata) -> u64;
    }
    unsafe { nw_quic_get_stream_id(metadata) }
}

/// Describes the type of the QUIC stream.
///
///
/// Parameter `stream_metadata`: A nw_protocol_metadata_t for a QUIC stream.
///
///
/// Returns: Returns the type of the QUIC stream, stored in nw_quic_stream_type_t.
/// If the type can not be determined, returns nw_quic_stream_type_unknown.
#[inline]
pub extern "C-unwind" fn nw_quic_get_stream_type(stream_metadata: &NWProtocolMetadata) -> u8 {
    extern "C-unwind" {
        fn nw_quic_get_stream_type(stream_metadata: &NWProtocolMetadata) -> u8;
    }
    unsafe { nw_quic_get_stream_type(stream_metadata) }
}

/// Access the Application Error value received from the peer in a stream close
/// message.
///
///
/// Parameter `metadata`: A nw_protocol_metadata_t for a QUIC stream.
///
///
/// Returns: Returns the Application Error code value received from by the peer,
/// or UINT64_MAX if no error has been received.
#[inline]
pub extern "C-unwind" fn nw_quic_get_stream_application_error(
    metadata: &NWProtocolMetadata,
) -> u64 {
    extern "C-unwind" {
        fn nw_quic_get_stream_application_error(metadata: &NWProtocolMetadata) -> u64;
    }
    unsafe { nw_quic_get_stream_application_error(metadata) }
}

/// Set an Application Error value to send to the peer when the stream
/// is closed.
///
///
/// Parameter `metadata`: A nw_protocol_metadata_t for a QUIC stream.
///
///
/// Parameter `application_error`: An application-specific error code value.
#[inline]
pub extern "C-unwind" fn nw_quic_set_stream_application_error(
    metadata: &NWProtocolMetadata,
    application_error: u64,
) {
    extern "C-unwind" {
        fn nw_quic_set_stream_application_error(
            metadata: &NWProtocolMetadata,
            application_error: u64,
        );
    }
    unsafe { nw_quic_set_stream_application_error(metadata, application_error) }
}

/// Get the most recent value of the maximum number of bidirectional streams that the peer can create.
///
///
/// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
///
///
/// Returns: Returns the most recent value of the peer's max number of bidirectional streams.
#[inline]
pub extern "C-unwind" fn nw_quic_get_local_max_streams_bidirectional(
    metadata: &NWProtocolMetadata,
) -> u64 {
    extern "C-unwind" {
        fn nw_quic_get_local_max_streams_bidirectional(metadata: &NWProtocolMetadata) -> u64;
    }
    unsafe { nw_quic_get_local_max_streams_bidirectional(metadata) }
}

/// Sets the maximum number of bidirectional streams that the peer can create.
///
///
/// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
///
///
/// Parameter `max_streams_bidirectional`: The new number of maximum bidirectional streams.
#[inline]
pub extern "C-unwind" fn nw_quic_set_local_max_streams_bidirectional(
    metadata: &NWProtocolMetadata,
    max_streams_bidirectional: u64,
) {
    extern "C-unwind" {
        fn nw_quic_set_local_max_streams_bidirectional(
            metadata: &NWProtocolMetadata,
            max_streams_bidirectional: u64,
        );
    }
    unsafe { nw_quic_set_local_max_streams_bidirectional(metadata, max_streams_bidirectional) }
}

/// Get the most recent value of the maximum number of unidirectional streams that the peer can create.
///
///
/// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
///
///
/// Returns: Returns the most recent value of the peer's max number of unidirectional streams.
#[inline]
pub extern "C-unwind" fn nw_quic_get_local_max_streams_unidirectional(
    metadata: &NWProtocolMetadata,
) -> u64 {
    extern "C-unwind" {
        fn nw_quic_get_local_max_streams_unidirectional(metadata: &NWProtocolMetadata) -> u64;
    }
    unsafe { nw_quic_get_local_max_streams_unidirectional(metadata) }
}

/// Sets the maximum number of unidirectional streams that the peer can create.
///
///
/// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
///
///
/// Parameter `max_streams_unidirectional`: The new number of maximum unidirectional streams.
#[inline]
pub extern "C-unwind" fn nw_quic_set_local_max_streams_unidirectional(
    metadata: &NWProtocolMetadata,
    max_streams_unidirectional: u64,
) {
    extern "C-unwind" {
        fn nw_quic_set_local_max_streams_unidirectional(
            metadata: &NWProtocolMetadata,
            max_streams_unidirectional: u64,
        );
    }
    unsafe { nw_quic_set_local_max_streams_unidirectional(metadata, max_streams_unidirectional) }
}

/// Get the maximum number of bidirectional streams advertised by peer that an application
/// is allowed to create.
///
/// Note that while attempts to create streams above this limit will
/// be blocked until the server increases the limit, these blocked
/// attempts will cause a STREAMS_BLOCKED frame to be sent to the
/// server. This informs the server that the client has more streams
/// it would like to create. As a result, the caller should attempt to
/// create streams over this limit if it desires more streams.
///
///
/// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
///
///
/// Returns: Returns the most recent value of the peer's advertised max number of bidirectional streams.
#[inline]
pub extern "C-unwind" fn nw_quic_get_remote_max_streams_bidirectional(
    metadata: &NWProtocolMetadata,
) -> u64 {
    extern "C-unwind" {
        fn nw_quic_get_remote_max_streams_bidirectional(metadata: &NWProtocolMetadata) -> u64;
    }
    unsafe { nw_quic_get_remote_max_streams_bidirectional(metadata) }
}

/// Get the maximum number of unidirectional streams advertised by peer that an application
/// is allowed to create.
///
/// Note that while attempts to create streams above this limit will
/// be blocked until the server increases the limit, these blocked
/// attempts will cause a STREAMS_BLOCKED frame to be sent to the
/// server. This informs the server that the client has more streams
/// it would like to create. As a result, the caller should attempt to
/// create streams over this limit if it desires more streams.
///
///
/// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
///
///
/// Returns: Returns the most recent value of the peer's advertised max number of unidirectional streams.
#[inline]
pub extern "C-unwind" fn nw_quic_get_remote_max_streams_unidirectional(
    metadata: &NWProtocolMetadata,
) -> u64 {
    extern "C-unwind" {
        fn nw_quic_get_remote_max_streams_unidirectional(metadata: &NWProtocolMetadata) -> u64;
    }
    unsafe { nw_quic_get_remote_max_streams_unidirectional(metadata) }
}

/// Get the usable size of a datagram frame from a QUIC datagram flow.
///
///
/// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
///
///
/// Returns: Returns the usable datagram frame size.
#[inline]
pub extern "C-unwind" fn nw_quic_get_stream_usable_datagram_frame_size(
    metadata: &NWProtocolMetadata,
) -> u16 {
    extern "C-unwind" {
        fn nw_quic_get_stream_usable_datagram_frame_size(metadata: &NWProtocolMetadata) -> u16;
    }
    unsafe { nw_quic_get_stream_usable_datagram_frame_size(metadata) }
}

/// Access the Application Error value received from the peer in a connection close
/// message.
///
///
/// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
///
///
/// Returns: Returns the Application Error code value received from by the peer,
/// or UINT64_MAX if no    error has been received.
#[inline]
pub extern "C-unwind" fn nw_quic_get_application_error(metadata: &NWProtocolMetadata) -> u64 {
    extern "C-unwind" {
        fn nw_quic_get_application_error(metadata: &NWProtocolMetadata) -> u64;
    }
    unsafe { nw_quic_get_application_error(metadata) }
}

/// Access the Application Error reason string received from the peer in a connection
/// close message.
///
///
/// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
///
///
/// Returns: Returns the Application Error reason received from by the peer,
/// or NULL if no error reason has been received.
#[inline]
pub extern "C-unwind" fn nw_quic_get_application_error_reason(
    metadata: &NWProtocolMetadata,
) -> *const c_char {
    extern "C-unwind" {
        fn nw_quic_get_application_error_reason(metadata: &NWProtocolMetadata) -> *const c_char;
    }
    unsafe { nw_quic_get_application_error_reason(metadata) }
}

extern "C-unwind" {
    /// Set the Application Error value to send to the peer in a connection close
    /// message.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Parameter `application_error`: Sets the Application Error code value.
    ///
    ///
    /// Parameter `reason`: An optional reason string to associate with the error.
    ///
    /// # Safety
    ///
    /// `reason` must be a valid pointer or null.
    pub fn nw_quic_set_application_error(
        metadata: &NWProtocolMetadata,
        application_error: u64,
        reason: *const c_char,
    );
}

/// Retrieves the keep-alive interval set on a QUIC connection.
///
///
/// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
///
///
/// Returns: Returns value of the keep-alive interval, in seconds,
/// or 0 if the keep-alive timer is disabled.
#[inline]
pub extern "C-unwind" fn nw_quic_get_keepalive_interval(metadata: &NWProtocolMetadata) -> u16 {
    extern "C-unwind" {
        fn nw_quic_get_keepalive_interval(metadata: &NWProtocolMetadata) -> u16;
    }
    unsafe { nw_quic_get_keepalive_interval(metadata) }
}

/// Changes the keep-alive interval for QUIC.
///
///
/// QUIC connections are encrypted and operate over the UDP protocol
/// which makes it hard for Network Address    Translators and firewalls
/// to track their state. For this reason, these middleboxes may
/// use short timeouts for QUIC flows. By sending keep-alive packets
/// (QUIC PING frames), the endpoint can maintain
/// state of the flow across the network.
/// Keep-alives should only be enabled while there is an outstanding
/// exchange of information with the remote endpoint that has not yet
/// completed, it is not recommended to enable keep-alive packets on an
/// idle connection that is not expecting to send or receive data in
/// the near future.
///
///
/// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
///
///
/// Parameter `keepalive_interval`: The keep-alive interval for QUIC, in seconds,
/// or 0 if the keep-alive timer is disabled.
/// Pass `NW_QUIC_CONNECTION_DEFAULT_KEEPALIVE` to use the default
/// keep-alive interval.
#[inline]
pub extern "C-unwind" fn nw_quic_set_keepalive_interval(
    metadata: &NWProtocolMetadata,
    keepalive_interval: u16,
) {
    extern "C-unwind" {
        fn nw_quic_set_keepalive_interval(metadata: &NWProtocolMetadata, keepalive_interval: u16);
    }
    unsafe { nw_quic_set_keepalive_interval(metadata, keepalive_interval) }
}

/// Access the idle_timeout value in milliseconds received from the peer
/// in the transport parameters.
///
///
/// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
///
///
/// Returns: Returns the idle_timeout value in milliseconds received from the peer.
#[inline]
pub extern "C-unwind" fn nw_quic_get_remote_idle_timeout(metadata: &NWProtocolMetadata) -> u64 {
    extern "C-unwind" {
        fn nw_quic_get_remote_idle_timeout(metadata: &NWProtocolMetadata) -> u64;
    }
    unsafe { nw_quic_get_remote_idle_timeout(metadata) }
}

/// Access the definition of the default system protocol implementation
/// of TCP (Transmission Control Protocol). This protocol can be used
/// as part of a connection's protocol stack as the transport protocol.
///
///
/// Returns: Returns a retained protocol definition object.
#[inline]
pub extern "C-unwind" fn nw_protocol_copy_tcp_definition() -> NWRetained<NWProtocolDefinition> {
    extern "C-unwind" {
        fn nw_protocol_copy_tcp_definition() -> Option<NonNull<NWProtocolDefinition>>;
    }
    let ret = unsafe { nw_protocol_copy_tcp_definition() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Create an instance of TCP protocol options. This object can be added
/// to an nw_protocol_stack_t to be used in an nw_connection_t or
/// an nw_listener_t.
///
///
/// Returns: Returns a retained protocol options object.
#[inline]
pub extern "C-unwind" fn nw_tcp_create_options() -> NWRetained<NWProtocolOptions> {
    extern "C-unwind" {
        fn nw_tcp_create_options() -> Option<NonNull<NWProtocolOptions>>;
    }
    let ret = unsafe { nw_tcp_create_options() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Configure TCP to disable Nagle's algorithm, which will
/// delay sending packets to coalesce sending.
///
///
/// Parameter `options`: A TCP protocol options object.
///
///
/// Parameter `no_delay`: A boolean indicating that TCP should disable
/// Nagle's algorithm.
#[inline]
pub extern "C-unwind" fn nw_tcp_options_set_no_delay(options: &NWProtocolOptions, no_delay: bool) {
    extern "C-unwind" {
        fn nw_tcp_options_set_no_delay(options: &NWProtocolOptions, no_delay: bool);
    }
    unsafe { nw_tcp_options_set_no_delay(options, no_delay) }
}

/// Wait to send TCP data until the connection has finished
/// writing, or else the TCP send buffer is full.
///
///
/// Parameter `options`: A TCP protocol options object.
///
///
/// Parameter `no_push`: A boolean indicating that TCP should use no-push mode.
#[inline]
pub extern "C-unwind" fn nw_tcp_options_set_no_push(options: &NWProtocolOptions, no_push: bool) {
    extern "C-unwind" {
        fn nw_tcp_options_set_no_push(options: &NWProtocolOptions, no_push: bool);
    }
    unsafe { nw_tcp_options_set_no_push(options, no_push) }
}

/// Disable sending TCP options and extensions.
///
///
/// Parameter `options`: A TCP protocol options object.
///
///
/// Parameter `no_options`: A boolean indicating that TCP should use no-options mode.
#[inline]
pub extern "C-unwind" fn nw_tcp_options_set_no_options(
    options: &NWProtocolOptions,
    no_options: bool,
) {
    extern "C-unwind" {
        fn nw_tcp_options_set_no_options(options: &NWProtocolOptions, no_options: bool);
    }
    unsafe { nw_tcp_options_set_no_options(options, no_options) }
}

/// Enable sending TCP keepalive probes.
///
///
/// Parameter `options`: A TCP protocol options object.
///
///
/// Parameter `enable_keepalive`: A boolean indicating that TCP should send keepalives.
#[inline]
pub extern "C-unwind" fn nw_tcp_options_set_enable_keepalive(
    options: &NWProtocolOptions,
    enable_keepalive: bool,
) {
    extern "C-unwind" {
        fn nw_tcp_options_set_enable_keepalive(options: &NWProtocolOptions, enable_keepalive: bool);
    }
    unsafe { nw_tcp_options_set_enable_keepalive(options, enable_keepalive) }
}

/// Configure the number of times TCP keepalive probes
/// should be sent without reply before terminating
/// the connection.
///
///
/// Parameter `options`: A TCP protocol options object.
///
///
/// Parameter `keepalive_count`: The number of keepalive probes to send before terminating
/// the connection.
#[inline]
pub extern "C-unwind" fn nw_tcp_options_set_keepalive_count(
    options: &NWProtocolOptions,
    keepalive_count: u32,
) {
    extern "C-unwind" {
        fn nw_tcp_options_set_keepalive_count(options: &NWProtocolOptions, keepalive_count: u32);
    }
    unsafe { nw_tcp_options_set_keepalive_count(options, keepalive_count) }
}

/// Configure the amount of time that a connection must be
/// idle before TCP should start sending keepalive probes.
///
///
/// Parameter `options`: A TCP protocol options object.
///
///
/// Parameter `keepalive_idle_time`: The number of seconds of idleness to wait before keepalive
/// probes are sent by TCP.
#[inline]
pub extern "C-unwind" fn nw_tcp_options_set_keepalive_idle_time(
    options: &NWProtocolOptions,
    keepalive_idle_time: u32,
) {
    extern "C-unwind" {
        fn nw_tcp_options_set_keepalive_idle_time(
            options: &NWProtocolOptions,
            keepalive_idle_time: u32,
        );
    }
    unsafe { nw_tcp_options_set_keepalive_idle_time(options, keepalive_idle_time) }
}

/// Configure the amount of time between sending TCP keepalive
/// probes when the peer is not responding.
///
///
/// Parameter `options`: A TCP protocol options object.
///
///
/// Parameter `keepalive_interval`: The number of seconds of to wait before resending TCP
/// keepalive probes.
#[inline]
pub extern "C-unwind" fn nw_tcp_options_set_keepalive_interval(
    options: &NWProtocolOptions,
    keepalive_interval: u32,
) {
    extern "C-unwind" {
        fn nw_tcp_options_set_keepalive_interval(
            options: &NWProtocolOptions,
            keepalive_interval: u32,
        );
    }
    unsafe { nw_tcp_options_set_keepalive_interval(options, keepalive_interval) }
}

/// Directly configure the maximum segment size (MSS)
/// TCP will use.
///
///
/// Parameter `options`: A TCP protocol options object.
///
///
/// Parameter `maximum_segment_size`: The maximum segment size in bytes.
#[inline]
pub extern "C-unwind" fn nw_tcp_options_set_maximum_segment_size(
    options: &NWProtocolOptions,
    maximum_segment_size: u32,
) {
    extern "C-unwind" {
        fn nw_tcp_options_set_maximum_segment_size(
            options: &NWProtocolOptions,
            maximum_segment_size: u32,
        );
    }
    unsafe { nw_tcp_options_set_maximum_segment_size(options, maximum_segment_size) }
}

/// Define a timeout value after which TCP connection
/// establishment will give up.
///
///
/// Parameter `options`: A TCP protocol options object.
///
///
/// Parameter `connection_timeout`: A timeout for TCP connection establishment, in seconds.
#[inline]
pub extern "C-unwind" fn nw_tcp_options_set_connection_timeout(
    options: &NWProtocolOptions,
    connection_timeout: u32,
) {
    extern "C-unwind" {
        fn nw_tcp_options_set_connection_timeout(
            options: &NWProtocolOptions,
            connection_timeout: u32,
        );
    }
    unsafe { nw_tcp_options_set_connection_timeout(options, connection_timeout) }
}

/// Define a timeout value after which TCP connections
/// in the persist state will terminate. See RFC 6429.
///
///
/// Parameter `options`: A TCP protocol options object.
///
///
/// Parameter `persist_timeout`: The TCP persist timeout, in seconds.
#[inline]
pub extern "C-unwind" fn nw_tcp_options_set_persist_timeout(
    options: &NWProtocolOptions,
    persist_timeout: u32,
) {
    extern "C-unwind" {
        fn nw_tcp_options_set_persist_timeout(options: &NWProtocolOptions, persist_timeout: u32);
    }
    unsafe { nw_tcp_options_set_persist_timeout(options, persist_timeout) }
}

/// Define a timeout value after which TCP will drop
/// a connection with unacknowledged retransmissions.
///
///
/// Parameter `options`: A TCP protocol options object.
///
///
/// Parameter `retransmit_connection_drop_time`: A timeout for TCP retransmission attempts, in seconds.
#[inline]
pub extern "C-unwind" fn nw_tcp_options_set_retransmit_connection_drop_time(
    options: &NWProtocolOptions,
    retransmit_connection_drop_time: u32,
) {
    extern "C-unwind" {
        fn nw_tcp_options_set_retransmit_connection_drop_time(
            options: &NWProtocolOptions,
            retransmit_connection_drop_time: u32,
        );
    }
    unsafe {
        nw_tcp_options_set_retransmit_connection_drop_time(options, retransmit_connection_drop_time)
    }
}

/// Cause TCP to drop connections after not receiving
/// an ACK multiple times after a FIN, currently set at three.
///
///
/// Parameter `options`: A TCP protocol options object.
///
///
/// Parameter `retransmit_fin_drop`: A boolean to cause TCP to drop its connection after
/// not receiving an ACK after a FIN.
#[inline]
pub extern "C-unwind" fn nw_tcp_options_set_retransmit_fin_drop(
    options: &NWProtocolOptions,
    retransmit_fin_drop: bool,
) {
    extern "C-unwind" {
        fn nw_tcp_options_set_retransmit_fin_drop(
            options: &NWProtocolOptions,
            retransmit_fin_drop: bool,
        );
    }
    unsafe { nw_tcp_options_set_retransmit_fin_drop(options, retransmit_fin_drop) }
}

/// Configure TCP to disable ACK stretching. ACKs will be sent
/// for every other data packet.
///
///
/// Parameter `options`: A TCP protocol options object.
///
///
/// Parameter `disable_ack_stretching`: A boolean to cause TCP to disable ACK stretching.
#[inline]
pub extern "C-unwind" fn nw_tcp_options_set_disable_ack_stretching(
    options: &NWProtocolOptions,
    disable_ack_stretching: bool,
) {
    extern "C-unwind" {
        fn nw_tcp_options_set_disable_ack_stretching(
            options: &NWProtocolOptions,
            disable_ack_stretching: bool,
        );
    }
    unsafe { nw_tcp_options_set_disable_ack_stretching(options, disable_ack_stretching) }
}

/// Configure TCP to enable TCP Fast Open (TFO). This may take effect
/// even when TCP is not the top-level protocol in the protocol stack.
/// For example, if TLS is running over TCP, the Client Hello message
/// may be sent as fast open data.
///
/// If TCP is the top-level protocol in the stack (the one the application
/// directly interacts with), TFO will be disabled unless the application
/// indicated that it will provide its own fast open data by calling
/// nw_parameters_set_fast_open_enabled().
///
///
/// Parameter `options`: A TCP protocol options object.
///
///
/// Parameter `enable_fast_open`: A boolean to enable TFO.
#[inline]
pub extern "C-unwind" fn nw_tcp_options_set_enable_fast_open(
    options: &NWProtocolOptions,
    enable_fast_open: bool,
) {
    extern "C-unwind" {
        fn nw_tcp_options_set_enable_fast_open(options: &NWProtocolOptions, enable_fast_open: bool);
    }
    unsafe { nw_tcp_options_set_enable_fast_open(options, enable_fast_open) }
}

/// Configure TCP to disable default Explicit Congestion
/// Notification (ECN) behavior.
///
///
/// Parameter `options`: A TCP protocol options object.
///
///
/// Parameter `disable_ecn`: A boolean to disable ECN support in TCP.
#[inline]
pub extern "C-unwind" fn nw_tcp_options_set_disable_ecn(
    options: &NWProtocolOptions,
    disable_ecn: bool,
) {
    extern "C-unwind" {
        fn nw_tcp_options_set_disable_ecn(options: &NWProtocolOptions, disable_ecn: bool);
    }
    unsafe { nw_tcp_options_set_disable_ecn(options, disable_ecn) }
}

/// Multipath versions represent the MPTCP standard versions
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_multipath_version_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_multipath_version_t(pub c_int);
impl nw_multipath_version_t {
    #[doc(alias = "nw_multipath_version_unspecified")]
    pub const unspecified: Self = Self(-1);
    #[doc(alias = "nw_multipath_version_0")]
    pub const v0: Self = Self(0);
    #[doc(alias = "nw_multipath_version_1")]
    pub const v1: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_multipath_version_t {
    const ENCODING: Encoding = c_int::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_multipath_version_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Configure MPTCP to use a specified MPTCP standard version.
/// This ignores the cached value from MPTCP version discovery.
///
///
/// Parameter `options`: A TCP protocol options object.
///
///
/// Parameter `multipath_force_version`: The MPTCP version.
#[inline]
pub extern "C-unwind" fn nw_tcp_options_set_multipath_force_version(
    options: &NWProtocolOptions,
    multipath_force_version: nw_multipath_version_t,
) {
    extern "C-unwind" {
        fn nw_tcp_options_set_multipath_force_version(
            options: &NWProtocolOptions,
            multipath_force_version: nw_multipath_version_t,
        );
    }
    unsafe { nw_tcp_options_set_multipath_force_version(options, multipath_force_version) }
}

impl NWProtocolMetadata {
    /// Checks if a protocol metadata object is compatible with the
    /// accessors defined in this file for the default system
    /// implementation of TCP.
    ///
    ///
    /// Returns: Returns true if the metadata is for the default system TCP,
    /// false otherwise.
    #[doc(alias = "nw_protocol_metadata_is_tcp")]
    #[inline]
    pub fn is_tcp(&self) -> bool {
        extern "C-unwind" {
            fn nw_protocol_metadata_is_tcp(metadata: &NWProtocolMetadata) -> bool;
        }
        unsafe { nw_protocol_metadata_is_tcp(self) }
    }
}

/// Fetch the number of bytes waiting to be read from the receive buffer.
///
///
/// Returns: The number of bytes available in the receive buffer.
#[inline]
pub extern "C-unwind" fn nw_tcp_get_available_receive_buffer(metadata: &NWProtocolMetadata) -> u32 {
    extern "C-unwind" {
        fn nw_tcp_get_available_receive_buffer(metadata: &NWProtocolMetadata) -> u32;
    }
    unsafe { nw_tcp_get_available_receive_buffer(metadata) }
}

/// Fetch the number of bytes waiting to be acknowledged in the send buffer.
///
///
/// Returns: The number of bytes waiting to be acknowledged.
#[inline]
pub extern "C-unwind" fn nw_tcp_get_available_send_buffer(metadata: &NWProtocolMetadata) -> u32 {
    extern "C-unwind" {
        fn nw_tcp_get_available_send_buffer(metadata: &NWProtocolMetadata) -> u32;
    }
    unsafe { nw_tcp_get_available_send_buffer(metadata) }
}

/// Access the definition of the default system protocol implementation
/// of TLS (Transport Layer Security). This protocol can be used
/// as part of a connection's protocol stack as an application protocol.
///
///
/// Returns: Returns a retained protocol definition object.
#[inline]
pub extern "C-unwind" fn nw_protocol_copy_tls_definition() -> NWRetained<NWProtocolDefinition> {
    extern "C-unwind" {
        fn nw_protocol_copy_tls_definition() -> Option<NonNull<NWProtocolDefinition>>;
    }
    let ret = unsafe { nw_protocol_copy_tls_definition() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Create an instance of TLS protocol options. This object can be added
/// to an nw_protocol_stack_t to be used in an nw_connection_t or
/// an nw_listener_t.
///
///
/// Returns: Returns a retained protocol options object.
#[inline]
pub extern "C-unwind" fn nw_tls_create_options() -> NWRetained<NWProtocolOptions> {
    extern "C-unwind" {
        fn nw_tls_create_options() -> Option<NonNull<NWProtocolOptions>>;
    }
    let ret = unsafe { nw_tls_create_options() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

impl NWProtocolMetadata {
    /// Checks if a protocol metadata object is compatible with the
    /// accessors defined in this file for the default system
    /// implementation of TLS.
    ///
    ///
    /// Returns: Returns true if the metadata is for the default system TLS,
    /// false otherwise.
    #[doc(alias = "nw_protocol_metadata_is_tls")]
    #[inline]
    pub fn is_tls(&self) -> bool {
        extern "C-unwind" {
            fn nw_protocol_metadata_is_tls(metadata: &NWProtocolMetadata) -> bool;
        }
        unsafe { nw_protocol_metadata_is_tls(self) }
    }
}

/// Access the definition of the default system protocol implementation
/// of UDP (User Datagram Protocol). This protocol can be used
/// as part of a connection's protocol stack as the transport protocol.
///
///
/// Returns: Returns a retained protocol definition object.
#[inline]
pub extern "C-unwind" fn nw_protocol_copy_udp_definition() -> NWRetained<NWProtocolDefinition> {
    extern "C-unwind" {
        fn nw_protocol_copy_udp_definition() -> Option<NonNull<NWProtocolDefinition>>;
    }
    let ret = unsafe { nw_protocol_copy_udp_definition() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Create an instance of UDP protocol options. This object can be added
/// to an nw_protocol_stack_t to be used in an nw_connection_t or
/// an nw_listener_t.
///
///
/// Returns: Returns a retained protocol options object.
#[inline]
pub extern "C-unwind" fn nw_udp_create_options() -> NWRetained<NWProtocolOptions> {
    extern "C-unwind" {
        fn nw_udp_create_options() -> Option<NonNull<NWProtocolOptions>>;
    }
    let ret = unsafe { nw_udp_create_options() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Configure UDP to skip computing checksums when sending.
/// This will only take effect when running over IPv4.
///
///
/// Parameter `options`: A UDP protocol options object.
///
///
/// Parameter `prefer_no_checksum`: A boolean that indicates if UDP is allowed to skip computing
/// its checksum.
#[inline]
pub extern "C-unwind" fn nw_udp_options_set_prefer_no_checksum(
    options: &NWProtocolOptions,
    prefer_no_checksum: bool,
) {
    extern "C-unwind" {
        fn nw_udp_options_set_prefer_no_checksum(
            options: &NWProtocolOptions,
            prefer_no_checksum: bool,
        );
    }
    unsafe { nw_udp_options_set_prefer_no_checksum(options, prefer_no_checksum) }
}

/// Create an instance of UDP metadata that can be used
/// to configure per-datagram options when sending data
/// on a connection.
///
///
/// Returns: Returns a retained protocol metadata object.
#[inline]
pub extern "C-unwind" fn nw_udp_create_metadata() -> NWRetained<NWProtocolMetadata> {
    extern "C-unwind" {
        fn nw_udp_create_metadata() -> Option<NonNull<NWProtocolMetadata>>;
    }
    let ret = unsafe { nw_udp_create_metadata() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

impl NWProtocolMetadata {
    /// Checks if a protocol metadata object is compatible with the
    /// accessors defined in this file for the default system
    /// implementation of UDP.
    ///
    ///
    /// Returns: Returns true if the metadata is for the default system UDP,
    /// false otherwise.
    #[doc(alias = "nw_protocol_metadata_is_udp")]
    #[inline]
    pub fn is_udp(&self) -> bool {
        extern "C-unwind" {
            fn nw_protocol_metadata_is_udp(metadata: &NWProtocolMetadata) -> bool;
        }
        unsafe { nw_protocol_metadata_is_udp(self) }
    }
}

/// WebSocket opcodes that denote the type of frame sent or received by
/// a WebSocket endpoint. Opcodes define the interpretation of their
/// associated payload data.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_opcode_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_ws_opcode_t(pub c_int);
impl nw_ws_opcode_t {
    #[doc(alias = "nw_ws_opcode_invalid")]
    pub const invalid: Self = Self(-1);
    /// Protocol WebSocket handles continuation frames internally,
    /// so clients will not see or use continuation frames.
    #[doc(alias = "nw_ws_opcode_cont")]
    pub const cont: Self = Self(0x0);
    #[doc(alias = "nw_ws_opcode_text")]
    pub const text: Self = Self(0x1);
    #[doc(alias = "nw_ws_opcode_binary")]
    pub const binary: Self = Self(0x2);
    #[doc(alias = "nw_ws_opcode_close")]
    pub const close: Self = Self(0x8);
    #[doc(alias = "nw_ws_opcode_ping")]
    pub const ping: Self = Self(0x9);
    #[doc(alias = "nw_ws_opcode_pong")]
    pub const pong: Self = Self(0xA);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ws_opcode_t {
    const ENCODING: Encoding = c_int::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ws_opcode_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// WebSocket close codes that describe the reason for closing a WebSocket
/// connection. Endpoints MAY use the following pre-defined status codes
/// when sending a Close frame.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_close_code_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_ws_close_code_t(pub c_uint);
impl nw_ws_close_code_t {
    /// meaning that the purpose for which the connection was established
    /// has been fulfilled.
    #[doc(alias = "nw_ws_close_code_normal_closure")]
    pub const normal_closure: Self = Self(1000);
    /// "going away", such as a server going down or a browser having
    /// navigated away from a page.
    #[doc(alias = "nw_ws_close_code_going_away")]
    pub const going_away: Self = Self(1001);
    /// terminating the connection due to a protocol error.
    #[doc(alias = "nw_ws_close_code_protocol_error")]
    pub const protocol_error: Self = Self(1002);
    /// terminating the connection because it has received a type of data
    /// it cannot accept (e.g., an endpoint that understands only text data
    /// MAY send this if it receives a binary message).
    #[doc(alias = "nw_ws_close_code_unsupported_data")]
    pub const unsupported_data: Self = Self(1003);
    /// be set as a status code in a Close control frame by an endpoint. It
    /// is designated for use in applications expecting a status code to
    /// indicate that no status code was actually present.
    #[doc(alias = "nw_ws_close_code_no_status_received")]
    pub const no_status_received: Self = Self(1005);
    /// be set as a status code in a Close control frame by an endpoint.
    /// It is designated for use in applications expecting a status code to
    /// indicate that the connection was closed abnormally, e.g., without
    /// sending or receiving a Close control frame.
    #[doc(alias = "nw_ws_close_code_abnormal_closure")]
    pub const abnormal_closure: Self = Self(1006);
    /// endpoint is terminating the connection because it has received data
    /// within a message that was not consistent with the type of the
    /// message (e.g., non-UTF-8 [RFC3629] data within a text message).
    #[doc(alias = "nw_ws_close_code_invalid_frame_payload_data")]
    pub const invalid_frame_payload_data: Self = Self(1007);
    /// terminating the connection because it has received a message that
    /// violates its policy. This is a generic status code that can be
    /// returned when there is no other more suitable status code (e.g.,
    /// 1003 or 1009) or if there is a need to hide specific details about
    /// the policy.
    #[doc(alias = "nw_ws_close_code_policy_violation")]
    pub const policy_violation: Self = Self(1008);
    /// terminating the connection because it has received a message that
    /// is too big for it to process.
    #[doc(alias = "nw_ws_close_code_message_too_big")]
    pub const message_too_big: Self = Self(1009);
    /// (client) is terminating the connection because it has expected the
    /// server to negotiate one or more extensions, but the server didn't
    /// return them in the response message of the WebSocket handshake. The
    /// list of extensions that are needed SHOULD appear in the /reason/
    /// part of the Close frame. Note that this status code is not used by
    /// the server, because it can fail the WebSocket handshake instead.
    #[doc(alias = "nw_ws_close_code_mandatory_extension")]
    pub const mandatory_extension: Self = Self(1010);
    /// terminating the connection because it encountered an unexpected
    /// condition that prevented it from fulfilling the request.
    #[doc(alias = "nw_ws_close_code_internal_server_error")]
    pub const internal_server_error: Self = Self(1011);
    /// be set as a status code in a Close control frame by an endpoint. It
    /// is designated for use in applications expecting a status code to
    /// indicate that the connection was closed due to a failure to perform
    /// a TLS handshake (e.g., the server certificate can't be verified).
    #[doc(alias = "nw_ws_close_code_tls_handshake")]
    pub const tls_handshake: Self = Self(1015);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ws_close_code_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ws_close_code_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The WebSocket Protocol version.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_version_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_ws_version_t(pub c_uint);
impl nw_ws_version_t {
    #[doc(alias = "nw_ws_version_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_ws_version_13")]
    pub const v13: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ws_version_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ws_version_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Access the definition of the default system implementation of the
/// WebSocket protocol. This protocol can be appended to a connection's
/// protocol stack.
///
///
/// Returns: Returns a retained protocol definition object.
#[inline]
pub extern "C-unwind" fn nw_protocol_copy_ws_definition() -> NWRetained<NWProtocolDefinition> {
    extern "C-unwind" {
        fn nw_protocol_copy_ws_definition() -> Option<NonNull<NWProtocolDefinition>>;
    }
    let ret = unsafe { nw_protocol_copy_ws_definition() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Create an instance of WebSocket protocol options. This object can be
/// added to an nw_protocol_stack_t to be used in an nw_connection_t or
/// an nw_listener_t.
///
///
/// Returns: Returns a retained protocol options object.
#[inline]
pub extern "C-unwind" fn nw_ws_create_options(
    version: nw_ws_version_t,
) -> NWRetained<NWProtocolOptions> {
    extern "C-unwind" {
        fn nw_ws_create_options(version: nw_ws_version_t) -> Option<NonNull<NWProtocolOptions>>;
    }
    let ret = unsafe { nw_ws_create_options(version) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Set additional HTTP headers to be sent by the client during the
    /// WebSocket handshake.
    ///
    ///
    /// Parameter `options`: The WebSocket protocol options object.
    ///
    ///
    /// Parameter `name`: The HTTP header name.
    ///
    ///
    /// Parameter `value`: The HTTP header value.
    ///
    /// # Safety
    ///
    /// - `name` must be a valid pointer.
    /// - `value` must be a valid pointer.
    pub fn nw_ws_options_add_additional_header(
        options: &NWProtocolOptions,
        name: NonNull<c_char>,
        value: NonNull<c_char>,
    );
}

extern "C-unwind" {
    /// Add to the list of subprotocols that will be presented to a
    /// WebSocket server during connection establishment.
    ///
    ///
    /// Parameter `options`: The WebSocket protocol options object.
    ///
    ///
    /// Parameter `subprotocol`: The subprotocol supported by the client.
    ///
    /// # Safety
    ///
    /// `subprotocol` must be a valid pointer.
    pub fn nw_ws_options_add_subprotocol(options: &NWProtocolOptions, subprotocol: NonNull<c_char>);
}

/// Set whether the WebSocket connection should automatically reply to all
/// incoming pings. If set to true, the WebSocket protocol will automatically
/// reply to incoming pings and will deliver the pings to receive requests
/// on the connection.
///
///
/// Parameter `options`: The WebSocket protocol options object.
///
///
/// Parameter `auto_reply_ping`: Whether the WebSocket connection should automatically reply to all
/// incoming pings.
#[inline]
pub extern "C-unwind" fn nw_ws_options_set_auto_reply_ping(
    options: &NWProtocolOptions,
    auto_reply_ping: bool,
) {
    extern "C-unwind" {
        fn nw_ws_options_set_auto_reply_ping(options: &NWProtocolOptions, auto_reply_ping: bool);
    }
    unsafe { nw_ws_options_set_auto_reply_ping(options, auto_reply_ping) }
}

/// Set whether the WebSocket protocol should skip the opening handshake
/// and begin framing data as soon as a connection is established.
///
///
/// Parameter `options`: The WebSocket protocol options object.
///
///
/// Parameter `skip_handshake`: Whether the WebSocket connection should skip the opening handshake.
#[inline]
pub extern "C-unwind" fn nw_ws_options_set_skip_handshake(
    options: &NWProtocolOptions,
    skip_handshake: bool,
) {
    extern "C-unwind" {
        fn nw_ws_options_set_skip_handshake(options: &NWProtocolOptions, skip_handshake: bool);
    }
    unsafe { nw_ws_options_set_skip_handshake(options, skip_handshake) }
}

/// Set the maximum allowed message size to be received by the WebSocket
/// connection. This does not limit the sending message size.
///
///
/// Parameter `options`: The WebSocket protocol options object.
///
///
/// Parameter `maximum_message_size`: The maximum message size in bytes. A maximum message size of 0 means
/// there is no receive limit. The default maximum message size is 0.
#[inline]
pub extern "C-unwind" fn nw_ws_options_set_maximum_message_size(
    options: &NWProtocolOptions,
    maximum_message_size: usize,
) {
    extern "C-unwind" {
        fn nw_ws_options_set_maximum_message_size(
            options: &NWProtocolOptions,
            maximum_message_size: usize,
        );
    }
    unsafe { nw_ws_options_set_maximum_message_size(options, maximum_message_size) }
}

impl NWProtocolMetadata {
    /// Checks if a protocol metadata object is compatible with the
    /// accessors defined in this file for the default system
    /// implementation of WebSocket.
    ///
    ///
    /// Returns: Returns true if the metadata is for the default system
    /// implementation of WebSocket, false otherwise.
    #[doc(alias = "nw_protocol_metadata_is_ws")]
    #[inline]
    pub fn is_ws(&self) -> bool {
        extern "C-unwind" {
            fn nw_protocol_metadata_is_ws(metadata: &NWProtocolMetadata) -> bool;
        }
        unsafe { nw_protocol_metadata_is_ws(self) }
    }
}

/// Creates a protocol metadata object that can be used to define the
/// content context of messages sent over a WebSocket connection.
///
///
/// Parameter `opcode`: Set the opcode on a WebSocket frame. This must be defined on create.
///
///
/// Returns: Returns a retained metadata object representing the WebSocket frame.
#[inline]
pub extern "C-unwind" fn nw_ws_create_metadata(
    opcode: nw_ws_opcode_t,
) -> NWRetained<NWProtocolMetadata> {
    extern "C-unwind" {
        fn nw_ws_create_metadata(opcode: nw_ws_opcode_t) -> Option<NonNull<NWProtocolMetadata>>;
    }
    let ret = unsafe { nw_ws_create_metadata(opcode) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Get the opcode on a WebSocket frame.
///
///
/// Parameter `metadata`: The metadata object representing the WebSocket frame.
///
///
/// Returns: The opcode on the WebSocket frame.
#[inline]
pub extern "C-unwind" fn nw_ws_metadata_get_opcode(
    metadata: &NWProtocolMetadata,
) -> nw_ws_opcode_t {
    extern "C-unwind" {
        fn nw_ws_metadata_get_opcode(metadata: &NWProtocolMetadata) -> nw_ws_opcode_t;
    }
    unsafe { nw_ws_metadata_get_opcode(metadata) }
}

/// Set the close code on a WebSocket frame. The WebSocket frame's opcode
/// should be nw_ws_opcode_close.
///
///
/// Parameter `metadata`: The metadata object representing the WebSocket frame.
///
///
/// Parameter `close_code`: The close code on the WebSocket frame.
#[inline]
pub extern "C-unwind" fn nw_ws_metadata_set_close_code(
    metadata: &NWProtocolMetadata,
    close_code: nw_ws_close_code_t,
) {
    extern "C-unwind" {
        fn nw_ws_metadata_set_close_code(
            metadata: &NWProtocolMetadata,
            close_code: nw_ws_close_code_t,
        );
    }
    unsafe { nw_ws_metadata_set_close_code(metadata, close_code) }
}

/// Get the close code from a WebSocket frame. If the close code is equal
/// to nw_ws_close_code_no_status_received, it means that a close code
/// was not actually present in the WebSocket frame.
///
///
/// Parameter `metadata`: The metadata object representing the WebSocket frame.
///
///
/// Returns: The close code on the WebSocket frame.
#[inline]
pub extern "C-unwind" fn nw_ws_metadata_get_close_code(
    metadata: &NWProtocolMetadata,
) -> nw_ws_close_code_t {
    extern "C-unwind" {
        fn nw_ws_metadata_get_close_code(metadata: &NWProtocolMetadata) -> nw_ws_close_code_t;
    }
    unsafe { nw_ws_metadata_get_close_code(metadata) }
}

/// A block to be invoked when a pong reply is received after sending a ping
/// message, or if the WebSocket connection has closed or failed.
///
///
/// Parameter `error`: An optional error if the WebSocket connection fails or closes before a
/// pong reply is received.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_pong_handler_t?language=objc)
pub type nw_ws_pong_handler_t = *mut block2::DynBlock<dyn Fn(*mut NWError)>;

extern "C-unwind" {
    /// Set a callback that will notify the client when a pong message has been
    /// received for a ping message sent. The metadata object's associated
    /// opcode should be nw_ws_opcode_ping.
    ///
    ///
    /// Parameter `metadata`: The WebSocket metadata object.
    ///
    ///
    /// Parameter `client_queue`: The queue on which the pong handler will be delivered.
    ///
    ///
    /// Parameter `pong_handler`: The handler that gets called when a pong reply is received.
    ///
    /// # Safety
    ///
    /// `pong_handler` must be a valid pointer.
    pub fn nw_ws_metadata_set_pong_handler(
        metadata: &NWProtocolMetadata,
        client_queue: &DispatchQueue,
        pong_handler: nw_ws_pong_handler_t,
    );
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_ws_request?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_ws_request: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_request_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_ws_request_t = NSObject;

/// A block that can be applied to every subprotocol in a client's WebSocket
/// request.
///
///
/// Parameter `subprotocol`: A subprotocol presented by the client.
///
///
/// Returns: A boolean value that indicating if enumeration should continue.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_subprotocol_enumerator_t?language=objc)
pub type nw_ws_subprotocol_enumerator_t = *mut block2::DynBlock<dyn Fn(NonNull<c_char>) -> bool>;

extern "C-unwind" {
    /// Enumerates the list of subprotocols on the client's request.
    ///
    ///
    /// Parameter `request`: The client request.
    ///
    ///
    /// Parameter `enumerator`: The enumerator block.
    ///
    ///
    /// Returns: Whether the enumeration completed.
    ///
    /// # Safety
    ///
    /// `enumerator` must be a valid pointer.
    pub fn nw_ws_request_enumerate_subprotocols(
        request: &NWWsRequest,
        enumerator: nw_ws_subprotocol_enumerator_t,
    ) -> bool;
}

/// A block that can be applied to every additional header in a client's
/// WebSocket request.
///
///
/// Parameter `name`: The HTTP name.
///
///
/// Parameter `value`: The HTTP value.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_additional_header_enumerator_t?language=objc)
pub type nw_ws_additional_header_enumerator_t =
    *mut block2::DynBlock<dyn Fn(NonNull<c_char>, NonNull<c_char>) -> bool>;

extern "C-unwind" {
    /// Enumerates the list of additional headers on the client's request.
    ///
    ///
    /// Parameter `request`: The client request.
    ///
    ///
    /// Parameter `enumerator`: The enumerator block.
    ///
    ///
    /// Returns: Whether the enumeration completed.
    ///
    /// # Safety
    ///
    /// `enumerator` must be a valid pointer.
    pub fn nw_ws_request_enumerate_additional_headers(
        request: &NWWsRequest,
        enumerator: nw_ws_additional_header_enumerator_t,
    ) -> bool;
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/network/os_nw_ws_response?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait OS_nw_ws_response: NSObjectProtocol {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_response_t?language=objc)
#[cfg(feature = "objc2")]
pub type nw_ws_response_t = NSObject;

/// The status of a WebSocket server's response to a client's request to
/// connect.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_response_status_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_ws_response_status_t(pub c_uint);
impl nw_ws_response_status_t {
    /// be treated as an unexpected value.
    #[doc(alias = "nw_ws_response_status_invalid")]
    pub const invalid: Self = Self(0);
    /// WebSocket connection will begin framing data.
    #[doc(alias = "nw_ws_response_status_accept")]
    pub const accept: Self = Self(1);
    /// WebSocket connection will be closed.
    #[doc(alias = "nw_ws_response_status_reject")]
    pub const reject: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ws_response_status_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ws_response_status_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Create a server response to a WebSocket client's opening handshake.
///
///
/// Parameter `status`: The status of the response. If the status is nw_ws_response_status_accept,
/// the server will accept the handshake and open the WebSocket connection.
/// If the status is nw_ws_response_status_reject, the server will reject the
/// handshake and respond with the HTTP error 400 Bad Request.
///
///
/// Parameter `selected_subprotocol`: The server's selected protocol from the client's list of proposed
/// subprotocols. If the status of this response is nw_ws_response_status_reject,
/// this parameter is ignored. Pass NULL to indicate the server did not find
/// a suitable subprotocol, but has accepted the handshake anyways.
/// Passing an empty string is prohibited by the WebSocket protocol.
///
///
/// Returns: An instantiated WebSocket server response object.
///
/// # Safety
///
/// `selected_subprotocol` must be a valid pointer or null.
#[inline]
pub unsafe extern "C-unwind" fn nw_ws_response_create(
    status: nw_ws_response_status_t,
    selected_subprotocol: *const c_char,
) -> NWRetained<NWWsResponse> {
    extern "C-unwind" {
        fn nw_ws_response_create(
            status: nw_ws_response_status_t,
            selected_subprotocol: *const c_char,
        ) -> Option<NonNull<NWWsResponse>>;
    }
    let ret = unsafe { nw_ws_response_create(status, selected_subprotocol) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

/// Get the status from a WebSocket server's response. If the response is
/// nil, the return value will be nw_ws_response_status_invalid.
///
///
/// Parameter `response`: The server response.
///
///
/// Returns: The status of the server's response.
#[inline]
pub extern "C-unwind" fn nw_ws_response_get_status(
    response: Option<&NWWsResponse>,
) -> nw_ws_response_status_t {
    extern "C-unwind" {
        fn nw_ws_response_get_status(response: Option<&NWWsResponse>) -> nw_ws_response_status_t;
    }
    unsafe { nw_ws_response_get_status(response) }
}

/// Get the selected subprotocol from a WebSocket server's response.
///
///
/// Parameter `response`: The server response.
///
///
/// Returns: The status of the server's response.
#[inline]
pub extern "C-unwind" fn nw_ws_response_get_selected_subprotocol(
    response: &NWWsResponse,
) -> *const c_char {
    extern "C-unwind" {
        fn nw_ws_response_get_selected_subprotocol(response: &NWWsResponse) -> *const c_char;
    }
    unsafe { nw_ws_response_get_selected_subprotocol(response) }
}

extern "C-unwind" {
    /// Add additional HTTP headers to be sent back to the WebSocket client in
    /// the server's response.
    ///
    ///
    /// Parameter `response`: The server response.
    ///
    ///
    /// Parameter `name`: The HTTP name.
    ///
    ///
    /// Parameter `value`: The HTTP value.
    ///
    /// # Safety
    ///
    /// - `name` must be a valid pointer.
    /// - `value` must be a valid pointer.
    pub fn nw_ws_response_add_additional_header(
        response: &NWWsResponse,
        name: NonNull<c_char>,
        value: NonNull<c_char>,
    );
}

/// Copy the WebSocket server's response to a client's request to connect.
/// If this is called on a WebSocket server, the response object will contain
/// the server's own response to the client.
///
///
/// Parameter `metadata`: The metadata object representing the WebSocket connection.
///
///
/// Returns: The server response.
#[inline]
pub extern "C-unwind" fn nw_ws_metadata_copy_server_response(
    metadata: &NWProtocolMetadata,
) -> NWRetained<NWWsResponse> {
    extern "C-unwind" {
        fn nw_ws_metadata_copy_server_response(
            metadata: &NWProtocolMetadata,
        ) -> Option<NonNull<NWWsResponse>>;
    }
    let ret = unsafe { nw_ws_metadata_copy_server_response(metadata) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Enumerates the list of additional headers on the server's response.
    ///
    ///
    /// Parameter `response`: The server response.
    ///
    ///
    /// Parameter `enumerator`: The enumerator block.
    ///
    ///
    /// Returns: Whether the enumeration completed.
    ///
    /// # Safety
    ///
    /// `enumerator` must be a valid pointer.
    pub fn nw_ws_response_enumerate_additional_headers(
        response: &NWWsResponse,
        enumerator: nw_ws_additional_header_enumerator_t,
    ) -> bool;
}

/// A block to be invoked when a WebSocket server receives a WebSocket
/// client's request to connect.
///
///
/// Parameter `request`: The client request.
///
///
/// Returns: The server response.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_client_request_handler_t?language=objc)
pub type nw_ws_client_request_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWWsRequest>) -> NonNull<NWWsResponse>>;

extern "C-unwind" {
    /// Set callback handler to be invoked when a WebSocket server receives a
    /// WebSocket client's request to connect.
    ///
    ///
    /// Parameter `options`: The protocol options object.
    ///
    ///
    /// Parameter `client_queue`: The queue on which the client request handler will be delivered.
    ///
    ///
    /// Parameter `handler`: The callback handler.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer.
    pub fn nw_ws_options_set_client_request_handler(
        options: &NWProtocolOptions,
        client_queue: &DispatchQueue,
        handler: nw_ws_client_request_handler_t,
    );
}

#[deprecated = "renamed to `NWTxtRecord::with_bytes`"]
#[inline]
pub unsafe extern "C-unwind" fn nw_txt_record_create_with_bytes(
    txt_bytes: NonNull<u8>,
    txt_len: usize,
) -> NWRetained<NWTxtRecord> {
    extern "C-unwind" {
        fn nw_txt_record_create_with_bytes(
            txt_bytes: NonNull<u8>,
            txt_len: usize,
        ) -> Option<NonNull<NWTxtRecord>>;
    }
    let ret = unsafe { nw_txt_record_create_with_bytes(txt_bytes, txt_len) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWTxtRecord::new_dictionary`"]
#[inline]
pub extern "C-unwind" fn nw_txt_record_create_dictionary() -> NWRetained<NWTxtRecord> {
    extern "C-unwind" {
        fn nw_txt_record_create_dictionary() -> Option<NonNull<NWTxtRecord>>;
    }
    let ret = unsafe { nw_txt_record_create_dictionary() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWTxtRecord::copy`"]
#[inline]
pub extern "C-unwind" fn nw_txt_record_copy(&self) -> Option<NWRetained<NWTxtRecord>> {
    extern "C-unwind" {
        fn nw_txt_record_copy(txt_record: Option<&NWTxtRecord>) -> Option<NonNull<NWTxtRecord>>;
    }
    let ret = unsafe { nw_txt_record_copy(self) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `nw_txt_record_find_key_t::new`"]
    pub fn nw_txt_record_find_key(
        txt_record: &NWTxtRecord,
        key: NonNull<c_char>,
    ) -> nw_txt_record_find_key_t;
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWTxtRecord::access_key`"]
    pub fn nw_txt_record_access_key(
        txt_record: &NWTxtRecord,
        key: NonNull<c_char>,
        access_value: nw_txt_record_access_key_t,
    ) -> bool;
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWTxtRecord::set_key`"]
    pub fn nw_txt_record_set_key(
        txt_record: &NWTxtRecord,
        key: NonNull<c_char>,
        value: *const u8,
        value_len: usize,
    ) -> bool;
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWTxtRecord::remove_key`"]
    pub fn nw_txt_record_remove_key(txt_record: &NWTxtRecord, key: NonNull<c_char>) -> bool;
}

#[deprecated = "renamed to `NWTxtRecord::key_count`"]
#[inline]
pub extern "C-unwind" fn nw_txt_record_get_key_count(&self) -> usize {
    extern "C-unwind" {
        fn nw_txt_record_get_key_count(txt_record: Option<&NWTxtRecord>) -> usize;
    }
    unsafe { nw_txt_record_get_key_count(self) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWTxtRecord::access_bytes`"]
    pub fn nw_txt_record_access_bytes(
        txt_record: &NWTxtRecord,
        access_bytes: nw_txt_record_access_bytes_t,
    ) -> bool;
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWTxtRecord::apply`"]
    pub fn nw_txt_record_apply(txt_record: &NWTxtRecord, applier: nw_txt_record_applier_t) -> bool;
}

#[deprecated = "renamed to `NWTxtRecord::is_equal`"]
#[inline]
pub extern "C-unwind" fn nw_txt_record_is_equal(&self, right: Option<&NWTxtRecord>) -> bool {
    extern "C-unwind" {
        fn nw_txt_record_is_equal(left: Option<&NWTxtRecord>, right: Option<&NWTxtRecord>) -> bool;
    }
    unsafe { nw_txt_record_is_equal(self, right) }
}

#[deprecated = "renamed to `NWTxtRecord::is_dictionary`"]
#[inline]
pub extern "C-unwind" fn nw_txt_record_is_dictionary(&self) -> bool {
    extern "C-unwind" {
        fn nw_txt_record_is_dictionary(txt_record: &NWTxtRecord) -> bool;
    }
    unsafe { nw_txt_record_is_dictionary(self) }
}

#[deprecated = "renamed to `NWAdvertiseDescriptor::new_bonjour_service`"]
#[inline]
pub unsafe extern "C-unwind" fn nw_advertise_descriptor_create_bonjour_service(
    name: *const c_char,
    r#type: NonNull<c_char>,
    domain: *const c_char,
) -> Option<NWRetained<NWAdvertiseDescriptor>> {
    extern "C-unwind" {
        fn nw_advertise_descriptor_create_bonjour_service(
            name: *const c_char,
            r#type: NonNull<c_char>,
            domain: *const c_char,
        ) -> Option<NonNull<NWAdvertiseDescriptor>>;
    }
    let ret = unsafe { nw_advertise_descriptor_create_bonjour_service(name, r#type, domain) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWAdvertiseDescriptor::set_txt_record`"]
    pub fn nw_advertise_descriptor_set_txt_record(
        advertise_descriptor: &NWAdvertiseDescriptor,
        txt_record: *const c_void,
        txt_length: usize,
    );
}

#[deprecated = "renamed to `NWAdvertiseDescriptor::set_no_auto_rename`"]
#[inline]
pub extern "C-unwind" fn nw_advertise_descriptor_set_no_auto_rename(&self, no_auto_rename: bool) {
    extern "C-unwind" {
        fn nw_advertise_descriptor_set_no_auto_rename(
            advertise_descriptor: &NWAdvertiseDescriptor,
            no_auto_rename: bool,
        );
    }
    unsafe { nw_advertise_descriptor_set_no_auto_rename(self, no_auto_rename) }
}

#[deprecated = "renamed to `NWAdvertiseDescriptor::no_auto_rename`"]
#[inline]
pub extern "C-unwind" fn nw_advertise_descriptor_get_no_auto_rename(&self) -> bool {
    extern "C-unwind" {
        fn nw_advertise_descriptor_get_no_auto_rename(
            advertise_descriptor: &NWAdvertiseDescriptor,
        ) -> bool;
    }
    unsafe { nw_advertise_descriptor_get_no_auto_rename(self) }
}

#[deprecated = "renamed to `NWAdvertiseDescriptor::set_txt_record_object`"]
#[inline]
pub extern "C-unwind" fn nw_advertise_descriptor_set_txt_record_object(
    &self,
    txt_record: Option<&NWTxtRecord>,
) {
    extern "C-unwind" {
        fn nw_advertise_descriptor_set_txt_record_object(
            advertise_descriptor: &NWAdvertiseDescriptor,
            txt_record: Option<&NWTxtRecord>,
        );
    }
    unsafe { nw_advertise_descriptor_set_txt_record_object(self, txt_record) }
}

#[deprecated = "renamed to `NWAdvertiseDescriptor::txt_record_object`"]
#[inline]
pub extern "C-unwind" fn nw_advertise_descriptor_copy_txt_record_object(
    &self,
) -> Option<NWRetained<NWTxtRecord>> {
    extern "C-unwind" {
        fn nw_advertise_descriptor_copy_txt_record_object(
            advertise_descriptor: &NWAdvertiseDescriptor,
        ) -> Option<NonNull<NWTxtRecord>>;
    }
    let ret = unsafe { nw_advertise_descriptor_copy_txt_record_object(self) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

#[deprecated = "renamed to `NWAdvertiseDescriptor::new_application_service`"]
#[inline]
pub unsafe extern "C-unwind" fn nw_advertise_descriptor_create_application_service(
    application_service_name: NonNull<c_char>,
) -> NWRetained<NWAdvertiseDescriptor> {
    extern "C-unwind" {
        fn nw_advertise_descriptor_create_application_service(
            application_service_name: NonNull<c_char>,
        ) -> Option<NonNull<NWAdvertiseDescriptor>>;
    }
    let ret =
        unsafe { nw_advertise_descriptor_create_application_service(application_service_name) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWAdvertiseDescriptor::application_service_name`"]
#[inline]
pub extern "C-unwind" fn nw_advertise_descriptor_get_application_service_name(
    &self,
) -> *const c_char {
    extern "C-unwind" {
        fn nw_advertise_descriptor_get_application_service_name(
            advertise_descriptor: &NWAdvertiseDescriptor,
        ) -> *const c_char;
    }
    unsafe { nw_advertise_descriptor_get_application_service_name(self) }
}

#[deprecated = "renamed to `NWProtocolDefinition::is_equal`"]
#[inline]
pub extern "C-unwind" fn nw_protocol_definition_is_equal(
    &self,
    definition2: &NWProtocolDefinition,
) -> bool {
    extern "C-unwind" {
        fn nw_protocol_definition_is_equal(
            definition1: &NWProtocolDefinition,
            definition2: &NWProtocolDefinition,
        ) -> bool;
    }
    unsafe { nw_protocol_definition_is_equal(self, definition2) }
}

#[deprecated = "renamed to `NWProtocolOptions::definition`"]
#[inline]
pub extern "C-unwind" fn nw_protocol_options_copy_definition(
    &self,
) -> NWRetained<NWProtocolDefinition> {
    extern "C-unwind" {
        fn nw_protocol_options_copy_definition(
            options: &NWProtocolOptions,
        ) -> Option<NonNull<NWProtocolDefinition>>;
    }
    let ret = unsafe { nw_protocol_options_copy_definition(self) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWProtocolMetadata::definition`"]
#[inline]
pub extern "C-unwind" fn nw_protocol_metadata_copy_definition(
    &self,
) -> NWRetained<NWProtocolDefinition> {
    extern "C-unwind" {
        fn nw_protocol_metadata_copy_definition(
            metadata: &NWProtocolMetadata,
        ) -> Option<NonNull<NWProtocolDefinition>>;
    }
    let ret = unsafe { nw_protocol_metadata_copy_definition(self) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWInterface::type`"]
#[inline]
pub extern "C-unwind" fn nw_interface_get_type(&self) -> nw_interface_type_t {
    extern "C-unwind" {
        fn nw_interface_get_type(interface: &NWInterface) -> nw_interface_type_t;
    }
    unsafe { nw_interface_get_type(self) }
}

#[deprecated = "renamed to `NWInterface::name`"]
#[inline]
pub extern "C-unwind" fn nw_interface_get_name(&self) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_interface_get_name(interface: &NWInterface) -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_interface_get_name(self) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

#[deprecated = "renamed to `NWInterface::index`"]
#[inline]
pub extern "C-unwind" fn nw_interface_get_index(&self) -> u32 {
    extern "C-unwind" {
        fn nw_interface_get_index(interface: &NWInterface) -> u32;
    }
    unsafe { nw_interface_get_index(self) }
}

#[deprecated = "renamed to `NWEndpoint::type`"]
#[inline]
pub extern "C-unwind" fn nw_endpoint_get_type(&self) -> nw_endpoint_type_t {
    extern "C-unwind" {
        fn nw_endpoint_get_type(endpoint: &NWEndpoint) -> nw_endpoint_type_t;
    }
    unsafe { nw_endpoint_get_type(self) }
}

#[deprecated = "renamed to `NWEndpoint::new_host`"]
#[inline]
pub unsafe extern "C-unwind" fn nw_endpoint_create_host(
    hostname: NonNull<c_char>,
    port: NonNull<c_char>,
) -> NWRetained<NWEndpoint> {
    extern "C-unwind" {
        fn nw_endpoint_create_host(
            hostname: NonNull<c_char>,
            port: NonNull<c_char>,
        ) -> Option<NonNull<NWEndpoint>>;
    }
    let ret = unsafe { nw_endpoint_create_host(hostname, port) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWEndpoint::hostname`"]
#[inline]
pub extern "C-unwind" fn nw_endpoint_get_hostname(&self) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_endpoint_get_hostname(endpoint: &NWEndpoint) -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_endpoint_get_hostname(self) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

#[deprecated = "renamed to `NWEndpoint::port_string`"]
#[inline]
pub extern "C-unwind" fn nw_endpoint_copy_port_string(&self) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_endpoint_copy_port_string(endpoint: &NWEndpoint) -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_endpoint_copy_port_string(self) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

#[deprecated = "renamed to `NWEndpoint::port`"]
#[inline]
pub extern "C-unwind" fn nw_endpoint_get_port(&self) -> u16 {
    extern "C-unwind" {
        fn nw_endpoint_get_port(endpoint: &NWEndpoint) -> u16;
    }
    unsafe { nw_endpoint_get_port(self) }
}

#[cfg(feature = "libc")]
#[deprecated = "renamed to `NWEndpoint::new_address`"]
#[inline]
pub unsafe extern "C-unwind" fn nw_endpoint_create_address(
    address: NonNull<libc::sockaddr>,
) -> NWRetained<NWEndpoint> {
    extern "C-unwind" {
        fn nw_endpoint_create_address(
            address: NonNull<libc::sockaddr>,
        ) -> Option<NonNull<NWEndpoint>>;
    }
    let ret = unsafe { nw_endpoint_create_address(address) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWEndpoint::address_string`"]
#[inline]
pub extern "C-unwind" fn nw_endpoint_copy_address_string(&self) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_endpoint_copy_address_string(endpoint: &NWEndpoint) -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_endpoint_copy_address_string(self) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

#[cfg(feature = "libc")]
#[deprecated = "renamed to `NWEndpoint::address`"]
#[inline]
pub extern "C-unwind" fn nw_endpoint_get_address(&self) -> NonNull<libc::sockaddr> {
    extern "C-unwind" {
        fn nw_endpoint_get_address(endpoint: &NWEndpoint) -> Option<NonNull<libc::sockaddr>>;
    }
    let ret = unsafe { nw_endpoint_get_address(self) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

#[deprecated = "renamed to `NWEndpoint::new_bonjour_service`"]
#[inline]
pub unsafe extern "C-unwind" fn nw_endpoint_create_bonjour_service(
    name: NonNull<c_char>,
    r#type: NonNull<c_char>,
    domain: NonNull<c_char>,
) -> NWRetained<NWEndpoint> {
    extern "C-unwind" {
        fn nw_endpoint_create_bonjour_service(
            name: NonNull<c_char>,
            r#type: NonNull<c_char>,
            domain: NonNull<c_char>,
        ) -> Option<NonNull<NWEndpoint>>;
    }
    let ret = unsafe { nw_endpoint_create_bonjour_service(name, r#type, domain) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWEndpoint::bonjour_service_name`"]
#[inline]
pub extern "C-unwind" fn nw_endpoint_get_bonjour_service_name(&self) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_endpoint_get_bonjour_service_name(endpoint: &NWEndpoint) -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_endpoint_get_bonjour_service_name(self) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

#[deprecated = "renamed to `NWEndpoint::bonjour_service_type`"]
#[inline]
pub extern "C-unwind" fn nw_endpoint_get_bonjour_service_type(&self) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_endpoint_get_bonjour_service_type(endpoint: &NWEndpoint) -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_endpoint_get_bonjour_service_type(self) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

#[deprecated = "renamed to `NWEndpoint::bonjour_service_domain`"]
#[inline]
pub extern "C-unwind" fn nw_endpoint_get_bonjour_service_domain(&self) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_endpoint_get_bonjour_service_domain(endpoint: &NWEndpoint)
            -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_endpoint_get_bonjour_service_domain(self) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

#[deprecated = "renamed to `NWEndpoint::new_url`"]
#[inline]
pub unsafe extern "C-unwind" fn nw_endpoint_create_url(
    url: NonNull<c_char>,
) -> NWRetained<NWEndpoint> {
    extern "C-unwind" {
        fn nw_endpoint_create_url(url: NonNull<c_char>) -> Option<NonNull<NWEndpoint>>;
    }
    let ret = unsafe { nw_endpoint_create_url(url) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWEndpoint::url`"]
#[inline]
pub extern "C-unwind" fn nw_endpoint_get_url(&self) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_endpoint_get_url(endpoint: &NWEndpoint) -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_endpoint_get_url(self) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

#[deprecated = "renamed to `NWEndpoint::txt_record`"]
#[inline]
pub extern "C-unwind" fn nw_endpoint_copy_txt_record(&self) -> Option<NWRetained<NWTxtRecord>> {
    extern "C-unwind" {
        fn nw_endpoint_copy_txt_record(endpoint: &NWEndpoint) -> Option<NonNull<NWTxtRecord>>;
    }
    let ret = unsafe { nw_endpoint_copy_txt_record(self) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWEndpoint::signature`"]
    pub fn nw_endpoint_get_signature(
        endpoint: &NWEndpoint,
        out_signature_length: NonNull<usize>,
    ) -> *const u8;
}

#[deprecated = "renamed to `NWResolverConfig::new_https`"]
#[inline]
pub extern "C-unwind" fn nw_resolver_config_create_https(
    url_endpoint: &NWEndpoint,
) -> NWRetained<NWResolverConfig> {
    extern "C-unwind" {
        fn nw_resolver_config_create_https(
            url_endpoint: &NWEndpoint,
        ) -> Option<NonNull<NWResolverConfig>>;
    }
    let ret = unsafe { nw_resolver_config_create_https(url_endpoint) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWResolverConfig::new_tls`"]
#[inline]
pub extern "C-unwind" fn nw_resolver_config_create_tls(
    server_endpoint: &NWEndpoint,
) -> NWRetained<NWResolverConfig> {
    extern "C-unwind" {
        fn nw_resolver_config_create_tls(
            server_endpoint: &NWEndpoint,
        ) -> Option<NonNull<NWResolverConfig>>;
    }
    let ret = unsafe { nw_resolver_config_create_tls(server_endpoint) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWResolverConfig::add_server_address`"]
#[inline]
pub extern "C-unwind" fn nw_resolver_config_add_server_address(&self, server_address: &NWEndpoint) {
    extern "C-unwind" {
        fn nw_resolver_config_add_server_address(
            config: &NWResolverConfig,
            server_address: &NWEndpoint,
        );
    }
    unsafe { nw_resolver_config_add_server_address(self, server_address) }
}

#[deprecated = "renamed to `NWRelayHop::new`"]
#[inline]
pub extern "C-unwind" fn nw_relay_hop_create(
    http3_relay_endpoint: Option<&NWEndpoint>,
    http2_relay_endpoint: Option<&NWEndpoint>,
    relay_tls_options: Option<&NWProtocolOptions>,
) -> NWRetained<NWRelayHop> {
    extern "C-unwind" {
        fn nw_relay_hop_create(
            http3_relay_endpoint: Option<&NWEndpoint>,
            http2_relay_endpoint: Option<&NWEndpoint>,
            relay_tls_options: Option<&NWProtocolOptions>,
        ) -> Option<NonNull<NWRelayHop>>;
    }
    let ret = unsafe {
        nw_relay_hop_create(
            http3_relay_endpoint,
            http2_relay_endpoint,
            relay_tls_options,
        )
    };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWRelayHop::add_additional_http_header_field`"]
    pub fn nw_relay_hop_add_additional_http_header_field(
        relay_hop: &NWRelayHop,
        field_name: NonNull<c_char>,
        field_value: NonNull<c_char>,
    );
}

#[deprecated = "renamed to `NWProxyConfig::new_relay`"]
#[inline]
pub extern "C-unwind" fn nw_proxy_config_create_relay(
    first_hop: &NWRelayHop,
    second_hop: Option<&NWRelayHop>,
) -> NWRetained<NWProxyConfig> {
    extern "C-unwind" {
        fn nw_proxy_config_create_relay(
            first_hop: &NWRelayHop,
            second_hop: Option<&NWRelayHop>,
        ) -> Option<NonNull<NWProxyConfig>>;
    }
    let ret = unsafe { nw_proxy_config_create_relay(first_hop, second_hop) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWProxyConfig::new_oblivious_http`"]
#[inline]
pub unsafe extern "C-unwind" fn nw_proxy_config_create_oblivious_http(
    relay: &NWRelayHop,
    relay_resource_path: NonNull<c_char>,
    gateway_key_config: NonNull<u8>,
    gateway_key_config_length: usize,
) -> NWRetained<NWProxyConfig> {
    extern "C-unwind" {
        fn nw_proxy_config_create_oblivious_http(
            relay: &NWRelayHop,
            relay_resource_path: NonNull<c_char>,
            gateway_key_config: NonNull<u8>,
            gateway_key_config_length: usize,
        ) -> Option<NonNull<NWProxyConfig>>;
    }
    let ret = unsafe {
        nw_proxy_config_create_oblivious_http(
            relay,
            relay_resource_path,
            gateway_key_config,
            gateway_key_config_length,
        )
    };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWProxyConfig::new_http_connect`"]
#[inline]
pub extern "C-unwind" fn nw_proxy_config_create_http_connect(
    proxy_endpoint: &NWEndpoint,
    proxy_tls_options: Option<&NWProtocolOptions>,
) -> NWRetained<NWProxyConfig> {
    extern "C-unwind" {
        fn nw_proxy_config_create_http_connect(
            proxy_endpoint: &NWEndpoint,
            proxy_tls_options: Option<&NWProtocolOptions>,
        ) -> Option<NonNull<NWProxyConfig>>;
    }
    let ret = unsafe { nw_proxy_config_create_http_connect(proxy_endpoint, proxy_tls_options) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWProxyConfig::new_socksv5`"]
#[inline]
pub extern "C-unwind" fn nw_proxy_config_create_socksv5(
    proxy_endpoint: &NWEndpoint,
) -> NWRetained<NWProxyConfig> {
    extern "C-unwind" {
        fn nw_proxy_config_create_socksv5(
            proxy_endpoint: &NWEndpoint,
        ) -> Option<NonNull<NWProxyConfig>>;
    }
    let ret = unsafe { nw_proxy_config_create_socksv5(proxy_endpoint) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWProxyConfig::set_username_and_password`"]
    pub fn nw_proxy_config_set_username_and_password(
        proxy_config: &NWProxyConfig,
        username: NonNull<c_char>,
        password: *const c_char,
    );
}

#[deprecated = "renamed to `NWProxyConfig::set_failover_allowed`"]
#[inline]
pub extern "C-unwind" fn nw_proxy_config_set_failover_allowed(&self, failover_allowed: bool) {
    extern "C-unwind" {
        fn nw_proxy_config_set_failover_allowed(
            proxy_config: &NWProxyConfig,
            failover_allowed: bool,
        );
    }
    unsafe { nw_proxy_config_set_failover_allowed(self, failover_allowed) }
}

#[deprecated = "renamed to `NWProxyConfig::failover_allowed`"]
#[inline]
pub extern "C-unwind" fn nw_proxy_config_get_failover_allowed(&self) -> bool {
    extern "C-unwind" {
        fn nw_proxy_config_get_failover_allowed(proxy_config: &NWProxyConfig) -> bool;
    }
    unsafe { nw_proxy_config_get_failover_allowed(self) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWProxyConfig::add_match_domain`"]
    pub fn nw_proxy_config_add_match_domain(config: &NWProxyConfig, match_domain: NonNull<c_char>);
}

#[deprecated = "renamed to `NWProxyConfig::clear_match_domains`"]
#[inline]
pub extern "C-unwind" fn nw_proxy_config_clear_match_domains(&self) {
    extern "C-unwind" {
        fn nw_proxy_config_clear_match_domains(config: &NWProxyConfig);
    }
    unsafe { nw_proxy_config_clear_match_domains(self) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWProxyConfig::add_excluded_domain`"]
    pub fn nw_proxy_config_add_excluded_domain(
        config: &NWProxyConfig,
        excluded_domain: NonNull<c_char>,
    );
}

#[deprecated = "renamed to `NWProxyConfig::clear_excluded_domains`"]
#[inline]
pub extern "C-unwind" fn nw_proxy_config_clear_excluded_domains(&self) {
    extern "C-unwind" {
        fn nw_proxy_config_clear_excluded_domains(config: &NWProxyConfig);
    }
    unsafe { nw_proxy_config_clear_excluded_domains(self) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWProxyConfig::enumerate_match_domains`"]
    pub fn nw_proxy_config_enumerate_match_domains(
        config: &NWProxyConfig,
        enumerator: nw_proxy_domain_enumerator_t,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWProxyConfig::enumerate_excluded_domains`"]
    pub fn nw_proxy_config_enumerate_excluded_domains(
        config: &NWProxyConfig,
        enumerator: nw_proxy_domain_enumerator_t,
    );
}

#[deprecated = "renamed to `NWPrivacyContext::new`"]
#[inline]
pub unsafe extern "C-unwind" fn nw_privacy_context_create(
    description: NonNull<c_char>,
) -> NWRetained<NWPrivacyContext> {
    extern "C-unwind" {
        fn nw_privacy_context_create(
            description: NonNull<c_char>,
        ) -> Option<NonNull<NWPrivacyContext>>;
    }
    let ret = unsafe { nw_privacy_context_create(description) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWPrivacyContext::flush_cache`"]
#[inline]
pub extern "C-unwind" fn nw_privacy_context_flush_cache(&self) {
    extern "C-unwind" {
        fn nw_privacy_context_flush_cache(privacy_context: &NWPrivacyContext);
    }
    unsafe { nw_privacy_context_flush_cache(self) }
}

#[deprecated = "renamed to `NWPrivacyContext::disable_logging`"]
#[inline]
pub extern "C-unwind" fn nw_privacy_context_disable_logging(&self) {
    extern "C-unwind" {
        fn nw_privacy_context_disable_logging(privacy_context: &NWPrivacyContext);
    }
    unsafe { nw_privacy_context_disable_logging(self) }
}

#[deprecated = "renamed to `NWPrivacyContext::require_encrypted_name_resolution`"]
#[inline]
pub extern "C-unwind" fn nw_privacy_context_require_encrypted_name_resolution(
    &self,
    require_encrypted_name_resolution: bool,
    fallback_resolver_config: Option<&NWResolverConfig>,
) {
    extern "C-unwind" {
        fn nw_privacy_context_require_encrypted_name_resolution(
            privacy_context: &NWPrivacyContext,
            require_encrypted_name_resolution: bool,
            fallback_resolver_config: Option<&NWResolverConfig>,
        );
    }
    unsafe {
        nw_privacy_context_require_encrypted_name_resolution(
            self,
            require_encrypted_name_resolution,
            fallback_resolver_config,
        )
    }
}

#[deprecated = "renamed to `NWPrivacyContext::add_proxy`"]
#[inline]
pub extern "C-unwind" fn nw_privacy_context_add_proxy(&self, proxy_config: &NWProxyConfig) {
    extern "C-unwind" {
        fn nw_privacy_context_add_proxy(
            privacy_context: &NWPrivacyContext,
            proxy_config: &NWProxyConfig,
        );
    }
    unsafe { nw_privacy_context_add_proxy(self, proxy_config) }
}

#[deprecated = "renamed to `NWPrivacyContext::clear_proxies`"]
#[inline]
pub extern "C-unwind" fn nw_privacy_context_clear_proxies(&self) {
    extern "C-unwind" {
        fn nw_privacy_context_clear_proxies(privacy_context: &NWPrivacyContext);
    }
    unsafe { nw_privacy_context_clear_proxies(self) }
}

#[deprecated = "renamed to `NWParameters::new_secure_tcp`"]
#[inline]
pub unsafe extern "C-unwind" fn nw_parameters_create_secure_tcp(
    configure_tls: nw_parameters_configure_protocol_block_t,
    configure_tcp: nw_parameters_configure_protocol_block_t,
) -> NWRetained<NWParameters> {
    extern "C-unwind" {
        fn nw_parameters_create_secure_tcp(
            configure_tls: nw_parameters_configure_protocol_block_t,
            configure_tcp: nw_parameters_configure_protocol_block_t,
        ) -> Option<NonNull<NWParameters>>;
    }
    let ret = unsafe { nw_parameters_create_secure_tcp(configure_tls, configure_tcp) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWParameters::new_secure_udp`"]
#[inline]
pub unsafe extern "C-unwind" fn nw_parameters_create_secure_udp(
    configure_dtls: nw_parameters_configure_protocol_block_t,
    configure_udp: nw_parameters_configure_protocol_block_t,
) -> NWRetained<NWParameters> {
    extern "C-unwind" {
        fn nw_parameters_create_secure_udp(
            configure_dtls: nw_parameters_configure_protocol_block_t,
            configure_udp: nw_parameters_configure_protocol_block_t,
        ) -> Option<NonNull<NWParameters>>;
    }
    let ret = unsafe { nw_parameters_create_secure_udp(configure_dtls, configure_udp) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWParameters::new_custom_ip`"]
#[inline]
pub unsafe extern "C-unwind" fn nw_parameters_create_custom_ip(
    custom_ip_protocol_number: u8,
    configure_ip: nw_parameters_configure_protocol_block_t,
) -> NWRetained<NWParameters> {
    extern "C-unwind" {
        fn nw_parameters_create_custom_ip(
            custom_ip_protocol_number: u8,
            configure_ip: nw_parameters_configure_protocol_block_t,
        ) -> Option<NonNull<NWParameters>>;
    }
    let ret = unsafe { nw_parameters_create_custom_ip(custom_ip_protocol_number, configure_ip) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWParameters::new_quic`"]
#[inline]
pub unsafe extern "C-unwind" fn nw_parameters_create_quic(
    configure_quic: nw_parameters_configure_protocol_block_t,
) -> NWRetained<NWParameters> {
    extern "C-unwind" {
        fn nw_parameters_create_quic(
            configure_quic: nw_parameters_configure_protocol_block_t,
        ) -> Option<NonNull<NWParameters>>;
    }
    let ret = unsafe { nw_parameters_create_quic(configure_quic) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWParameters::new_application_service`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_create_application_service() -> NWRetained<NWParameters> {
    extern "C-unwind" {
        fn nw_parameters_create_application_service() -> Option<NonNull<NWParameters>>;
    }
    let ret = unsafe { nw_parameters_create_application_service() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWParameters::new`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_create() -> NWRetained<NWParameters> {
    extern "C-unwind" {
        fn nw_parameters_create() -> Option<NonNull<NWParameters>>;
    }
    let ret = unsafe { nw_parameters_create() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWParameters::copy`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_copy(&self) -> NWRetained<NWParameters> {
    extern "C-unwind" {
        fn nw_parameters_copy(parameters: &NWParameters) -> Option<NonNull<NWParameters>>;
    }
    let ret = unsafe { nw_parameters_copy(self) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWParameters::set_privacy_context`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_set_privacy_context(
    &self,
    privacy_context: &NWPrivacyContext,
) {
    extern "C-unwind" {
        fn nw_parameters_set_privacy_context(
            parameters: &NWParameters,
            privacy_context: &NWPrivacyContext,
        );
    }
    unsafe { nw_parameters_set_privacy_context(self, privacy_context) }
}

#[deprecated = "renamed to `NWParameters::set_attribution`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_set_attribution(
    &self,
    attribution: nw_parameters_attribution_t,
) {
    extern "C-unwind" {
        fn nw_parameters_set_attribution(
            parameters: &NWParameters,
            attribution: nw_parameters_attribution_t,
        );
    }
    unsafe { nw_parameters_set_attribution(self, attribution) }
}

#[deprecated = "renamed to `NWParameters::attribution`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_get_attribution(&self) -> nw_parameters_attribution_t {
    extern "C-unwind" {
        fn nw_parameters_get_attribution(parameters: &NWParameters) -> nw_parameters_attribution_t;
    }
    unsafe { nw_parameters_get_attribution(self) }
}

#[deprecated = "renamed to `NWParameters::require_interface`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_require_interface(&self, interface: Option<&NWInterface>) {
    extern "C-unwind" {
        fn nw_parameters_require_interface(
            parameters: &NWParameters,
            interface: Option<&NWInterface>,
        );
    }
    unsafe { nw_parameters_require_interface(self, interface) }
}

#[deprecated = "renamed to `NWParameters::required_interface`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_copy_required_interface(
    &self,
) -> Option<NWRetained<NWInterface>> {
    extern "C-unwind" {
        fn nw_parameters_copy_required_interface(
            parameters: &NWParameters,
        ) -> Option<NonNull<NWInterface>>;
    }
    let ret = unsafe { nw_parameters_copy_required_interface(self) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

#[deprecated = "renamed to `NWParameters::prohibit_interface`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_prohibit_interface(&self, interface: &NWInterface) {
    extern "C-unwind" {
        fn nw_parameters_prohibit_interface(parameters: &NWParameters, interface: &NWInterface);
    }
    unsafe { nw_parameters_prohibit_interface(self, interface) }
}

#[deprecated = "renamed to `NWParameters::clear_prohibited_interfaces`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_clear_prohibited_interfaces(&self) {
    extern "C-unwind" {
        fn nw_parameters_clear_prohibited_interfaces(parameters: &NWParameters);
    }
    unsafe { nw_parameters_clear_prohibited_interfaces(self) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWParameters::iterate_prohibited_interfaces`"]
    pub fn nw_parameters_iterate_prohibited_interfaces(
        parameters: &NWParameters,
        iterate_block: nw_parameters_iterate_interfaces_block_t,
    );
}

#[deprecated = "renamed to `NWParameters::set_required_interface_type`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_set_required_interface_type(
    &self,
    interface_type: nw_interface_type_t,
) {
    extern "C-unwind" {
        fn nw_parameters_set_required_interface_type(
            parameters: &NWParameters,
            interface_type: nw_interface_type_t,
        );
    }
    unsafe { nw_parameters_set_required_interface_type(self, interface_type) }
}

#[deprecated = "renamed to `NWParameters::required_interface_type`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_get_required_interface_type(&self) -> nw_interface_type_t {
    extern "C-unwind" {
        fn nw_parameters_get_required_interface_type(
            parameters: &NWParameters,
        ) -> nw_interface_type_t;
    }
    unsafe { nw_parameters_get_required_interface_type(self) }
}

#[deprecated = "renamed to `NWParameters::prohibit_interface_type`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_prohibit_interface_type(
    &self,
    interface_type: nw_interface_type_t,
) {
    extern "C-unwind" {
        fn nw_parameters_prohibit_interface_type(
            parameters: &NWParameters,
            interface_type: nw_interface_type_t,
        );
    }
    unsafe { nw_parameters_prohibit_interface_type(self, interface_type) }
}

#[deprecated = "renamed to `NWParameters::clear_prohibited_interface_types`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_clear_prohibited_interface_types(&self) {
    extern "C-unwind" {
        fn nw_parameters_clear_prohibited_interface_types(parameters: &NWParameters);
    }
    unsafe { nw_parameters_clear_prohibited_interface_types(self) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWParameters::iterate_prohibited_interface_types`"]
    pub fn nw_parameters_iterate_prohibited_interface_types(
        parameters: &NWParameters,
        iterate_block: nw_parameters_iterate_interface_types_block_t,
    );
}

#[deprecated = "renamed to `NWParameters::set_prohibit_expensive`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_set_prohibit_expensive(&self, prohibit_expensive: bool) {
    extern "C-unwind" {
        fn nw_parameters_set_prohibit_expensive(
            parameters: &NWParameters,
            prohibit_expensive: bool,
        );
    }
    unsafe { nw_parameters_set_prohibit_expensive(self, prohibit_expensive) }
}

#[deprecated = "renamed to `NWParameters::prohibit_expensive`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_get_prohibit_expensive(&self) -> bool {
    extern "C-unwind" {
        fn nw_parameters_get_prohibit_expensive(parameters: &NWParameters) -> bool;
    }
    unsafe { nw_parameters_get_prohibit_expensive(self) }
}

#[deprecated = "renamed to `NWParameters::set_prohibit_constrained`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_set_prohibit_constrained(&self, prohibit_constrained: bool) {
    extern "C-unwind" {
        fn nw_parameters_set_prohibit_constrained(
            parameters: &NWParameters,
            prohibit_constrained: bool,
        );
    }
    unsafe { nw_parameters_set_prohibit_constrained(self, prohibit_constrained) }
}

#[deprecated = "renamed to `NWParameters::prohibit_constrained`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_get_prohibit_constrained(&self) -> bool {
    extern "C-unwind" {
        fn nw_parameters_get_prohibit_constrained(parameters: &NWParameters) -> bool;
    }
    unsafe { nw_parameters_get_prohibit_constrained(self) }
}

#[deprecated = "renamed to `NWParameters::set_allow_ultra_constrained`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_set_allow_ultra_constrained(
    &self,
    allow_ultra_constrained: bool,
) {
    extern "C-unwind" {
        fn nw_parameters_set_allow_ultra_constrained(
            parameters: &NWParameters,
            allow_ultra_constrained: bool,
        );
    }
    unsafe { nw_parameters_set_allow_ultra_constrained(self, allow_ultra_constrained) }
}

#[deprecated = "renamed to `NWParameters::allow_ultra_constrained`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_get_allow_ultra_constrained(&self) -> bool {
    extern "C-unwind" {
        fn nw_parameters_get_allow_ultra_constrained(parameters: &NWParameters) -> bool;
    }
    unsafe { nw_parameters_get_allow_ultra_constrained(self) }
}

#[deprecated = "renamed to `NWParameters::set_reuse_local_address`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_set_reuse_local_address(&self, reuse_local_address: bool) {
    extern "C-unwind" {
        fn nw_parameters_set_reuse_local_address(
            parameters: &NWParameters,
            reuse_local_address: bool,
        );
    }
    unsafe { nw_parameters_set_reuse_local_address(self, reuse_local_address) }
}

#[deprecated = "renamed to `NWParameters::reuse_local_address`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_get_reuse_local_address(&self) -> bool {
    extern "C-unwind" {
        fn nw_parameters_get_reuse_local_address(parameters: &NWParameters) -> bool;
    }
    unsafe { nw_parameters_get_reuse_local_address(self) }
}

#[deprecated = "renamed to `NWParameters::set_local_endpoint`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_set_local_endpoint(
    &self,
    local_endpoint: Option<&NWEndpoint>,
) {
    extern "C-unwind" {
        fn nw_parameters_set_local_endpoint(
            parameters: &NWParameters,
            local_endpoint: Option<&NWEndpoint>,
        );
    }
    unsafe { nw_parameters_set_local_endpoint(self, local_endpoint) }
}

#[deprecated = "renamed to `NWParameters::local_endpoint`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_copy_local_endpoint(
    &self,
) -> Option<NWRetained<NWEndpoint>> {
    extern "C-unwind" {
        fn nw_parameters_copy_local_endpoint(
            parameters: &NWParameters,
        ) -> Option<NonNull<NWEndpoint>>;
    }
    let ret = unsafe { nw_parameters_copy_local_endpoint(self) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

#[deprecated = "renamed to `NWParameters::set_include_peer_to_peer`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_set_include_peer_to_peer(&self, include_peer_to_peer: bool) {
    extern "C-unwind" {
        fn nw_parameters_set_include_peer_to_peer(
            parameters: &NWParameters,
            include_peer_to_peer: bool,
        );
    }
    unsafe { nw_parameters_set_include_peer_to_peer(self, include_peer_to_peer) }
}

#[deprecated = "renamed to `NWParameters::include_peer_to_peer`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_get_include_peer_to_peer(&self) -> bool {
    extern "C-unwind" {
        fn nw_parameters_get_include_peer_to_peer(parameters: &NWParameters) -> bool;
    }
    unsafe { nw_parameters_get_include_peer_to_peer(self) }
}

#[deprecated = "renamed to `NWParameters::set_fast_open_enabled`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_set_fast_open_enabled(&self, fast_open_enabled: bool) {
    extern "C-unwind" {
        fn nw_parameters_set_fast_open_enabled(parameters: &NWParameters, fast_open_enabled: bool);
    }
    unsafe { nw_parameters_set_fast_open_enabled(self, fast_open_enabled) }
}

#[deprecated = "renamed to `NWParameters::fast_open_enabled`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_get_fast_open_enabled(&self) -> bool {
    extern "C-unwind" {
        fn nw_parameters_get_fast_open_enabled(parameters: &NWParameters) -> bool;
    }
    unsafe { nw_parameters_get_fast_open_enabled(self) }
}

#[deprecated = "renamed to `NWParameters::set_service_class`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_set_service_class(&self, service_class: nw_service_class_t) {
    extern "C-unwind" {
        fn nw_parameters_set_service_class(
            parameters: &NWParameters,
            service_class: nw_service_class_t,
        );
    }
    unsafe { nw_parameters_set_service_class(self, service_class) }
}

#[deprecated = "renamed to `NWParameters::service_class`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_get_service_class(&self) -> nw_service_class_t {
    extern "C-unwind" {
        fn nw_parameters_get_service_class(parameters: &NWParameters) -> nw_service_class_t;
    }
    unsafe { nw_parameters_get_service_class(self) }
}

#[deprecated = "renamed to `NWParameters::set_multipath_service`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_set_multipath_service(
    &self,
    multipath_service: nw_multipath_service_t,
) {
    extern "C-unwind" {
        fn nw_parameters_set_multipath_service(
            parameters: &NWParameters,
            multipath_service: nw_multipath_service_t,
        );
    }
    unsafe { nw_parameters_set_multipath_service(self, multipath_service) }
}

#[deprecated = "renamed to `NWParameters::multipath_service`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_get_multipath_service(&self) -> nw_multipath_service_t {
    extern "C-unwind" {
        fn nw_parameters_get_multipath_service(parameters: &NWParameters)
            -> nw_multipath_service_t;
    }
    unsafe { nw_parameters_get_multipath_service(self) }
}

#[deprecated = "renamed to `NWParameters::default_protocol_stack`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_copy_default_protocol_stack(
    &self,
) -> NWRetained<NWProtocolStack> {
    extern "C-unwind" {
        fn nw_parameters_copy_default_protocol_stack(
            parameters: &NWParameters,
        ) -> Option<NonNull<NWProtocolStack>>;
    }
    let ret = unsafe { nw_parameters_copy_default_protocol_stack(self) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWProtocolStack::prepend_application_protocol`"]
#[inline]
pub extern "C-unwind" fn nw_protocol_stack_prepend_application_protocol(
    &self,
    protocol: &NWProtocolOptions,
) {
    extern "C-unwind" {
        fn nw_protocol_stack_prepend_application_protocol(
            stack: &NWProtocolStack,
            protocol: &NWProtocolOptions,
        );
    }
    unsafe { nw_protocol_stack_prepend_application_protocol(self, protocol) }
}

#[deprecated = "renamed to `NWProtocolStack::clear_application_protocols`"]
#[inline]
pub extern "C-unwind" fn nw_protocol_stack_clear_application_protocols(&self) {
    extern "C-unwind" {
        fn nw_protocol_stack_clear_application_protocols(stack: &NWProtocolStack);
    }
    unsafe { nw_protocol_stack_clear_application_protocols(self) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWProtocolStack::iterate_application_protocols`"]
    pub fn nw_protocol_stack_iterate_application_protocols(
        stack: &NWProtocolStack,
        iterate_block: nw_protocol_stack_iterate_protocols_block_t,
    );
}

#[deprecated = "renamed to `NWProtocolStack::transport_protocol`"]
#[inline]
pub extern "C-unwind" fn nw_protocol_stack_copy_transport_protocol(
    &self,
) -> Option<NWRetained<NWProtocolOptions>> {
    extern "C-unwind" {
        fn nw_protocol_stack_copy_transport_protocol(
            stack: &NWProtocolStack,
        ) -> Option<NonNull<NWProtocolOptions>>;
    }
    let ret = unsafe { nw_protocol_stack_copy_transport_protocol(self) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

#[deprecated = "renamed to `NWProtocolStack::set_transport_protocol`"]
#[inline]
pub extern "C-unwind" fn nw_protocol_stack_set_transport_protocol(
    &self,
    protocol: &NWProtocolOptions,
) {
    extern "C-unwind" {
        fn nw_protocol_stack_set_transport_protocol(
            stack: &NWProtocolStack,
            protocol: &NWProtocolOptions,
        );
    }
    unsafe { nw_protocol_stack_set_transport_protocol(self, protocol) }
}

#[deprecated = "renamed to `NWProtocolStack::internet_protocol`"]
#[inline]
pub extern "C-unwind" fn nw_protocol_stack_copy_internet_protocol(
    &self,
) -> Option<NWRetained<NWProtocolOptions>> {
    extern "C-unwind" {
        fn nw_protocol_stack_copy_internet_protocol(
            stack: &NWProtocolStack,
        ) -> Option<NonNull<NWProtocolOptions>>;
    }
    let ret = unsafe { nw_protocol_stack_copy_internet_protocol(self) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

#[deprecated = "renamed to `NWParameters::set_local_only`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_set_local_only(&self, local_only: bool) {
    extern "C-unwind" {
        fn nw_parameters_set_local_only(parameters: &NWParameters, local_only: bool);
    }
    unsafe { nw_parameters_set_local_only(self, local_only) }
}

#[deprecated = "renamed to `NWParameters::local_only`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_get_local_only(&self) -> bool {
    extern "C-unwind" {
        fn nw_parameters_get_local_only(parameters: &NWParameters) -> bool;
    }
    unsafe { nw_parameters_get_local_only(self) }
}

#[deprecated = "renamed to `NWParameters::set_prefer_no_proxy`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_set_prefer_no_proxy(&self, prefer_no_proxy: bool) {
    extern "C-unwind" {
        fn nw_parameters_set_prefer_no_proxy(parameters: &NWParameters, prefer_no_proxy: bool);
    }
    unsafe { nw_parameters_set_prefer_no_proxy(self, prefer_no_proxy) }
}

#[deprecated = "renamed to `NWParameters::prefer_no_proxy`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_get_prefer_no_proxy(&self) -> bool {
    extern "C-unwind" {
        fn nw_parameters_get_prefer_no_proxy(parameters: &NWParameters) -> bool;
    }
    unsafe { nw_parameters_get_prefer_no_proxy(self) }
}

#[deprecated = "renamed to `NWParameters::set_expired_dns_behavior`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_set_expired_dns_behavior(
    &self,
    expired_dns_behavior: nw_parameters_expired_dns_behavior_t,
) {
    extern "C-unwind" {
        fn nw_parameters_set_expired_dns_behavior(
            parameters: &NWParameters,
            expired_dns_behavior: nw_parameters_expired_dns_behavior_t,
        );
    }
    unsafe { nw_parameters_set_expired_dns_behavior(self, expired_dns_behavior) }
}

#[deprecated = "renamed to `NWParameters::expired_dns_behavior`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_get_expired_dns_behavior(
    &self,
) -> nw_parameters_expired_dns_behavior_t {
    extern "C-unwind" {
        fn nw_parameters_get_expired_dns_behavior(
            parameters: &NWParameters,
        ) -> nw_parameters_expired_dns_behavior_t;
    }
    unsafe { nw_parameters_get_expired_dns_behavior(self) }
}

#[deprecated = "renamed to `NWParameters::set_requires_dnssec_validation`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_set_requires_dnssec_validation(
    &self,
    requires_dnssec_validation: bool,
) {
    extern "C-unwind" {
        fn nw_parameters_set_requires_dnssec_validation(
            parameters: &NWParameters,
            requires_dnssec_validation: bool,
        );
    }
    unsafe { nw_parameters_set_requires_dnssec_validation(self, requires_dnssec_validation) }
}

#[deprecated = "renamed to `NWParameters::requires_dnssec_validation`"]
#[inline]
pub extern "C-unwind" fn nw_parameters_requires_dnssec_validation(&self) -> bool {
    extern "C-unwind" {
        fn nw_parameters_requires_dnssec_validation(parameters: &NWParameters) -> bool;
    }
    unsafe { nw_parameters_requires_dnssec_validation(self) }
}

#[deprecated = "renamed to `NWBrowseDescriptor::new_bonjour_service`"]
#[inline]
pub unsafe extern "C-unwind" fn nw_browse_descriptor_create_bonjour_service(
    r#type: NonNull<c_char>,
    domain: *const c_char,
) -> NWRetained<NWBrowseDescriptor> {
    extern "C-unwind" {
        fn nw_browse_descriptor_create_bonjour_service(
            r#type: NonNull<c_char>,
            domain: *const c_char,
        ) -> Option<NonNull<NWBrowseDescriptor>>;
    }
    let ret = unsafe { nw_browse_descriptor_create_bonjour_service(r#type, domain) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWBrowseDescriptor::bonjour_service_type`"]
#[inline]
pub extern "C-unwind" fn nw_browse_descriptor_get_bonjour_service_type(&self) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_browse_descriptor_get_bonjour_service_type(
            descriptor: &NWBrowseDescriptor,
        ) -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_browse_descriptor_get_bonjour_service_type(self) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

#[deprecated = "renamed to `NWBrowseDescriptor::bonjour_service_domain`"]
#[inline]
pub extern "C-unwind" fn nw_browse_descriptor_get_bonjour_service_domain(&self) -> *const c_char {
    extern "C-unwind" {
        fn nw_browse_descriptor_get_bonjour_service_domain(
            descriptor: &NWBrowseDescriptor,
        ) -> *const c_char;
    }
    unsafe { nw_browse_descriptor_get_bonjour_service_domain(self) }
}

#[deprecated = "renamed to `NWBrowseDescriptor::set_include_txt_record`"]
#[inline]
pub extern "C-unwind" fn nw_browse_descriptor_set_include_txt_record(
    &self,
    include_txt_record: bool,
) {
    extern "C-unwind" {
        fn nw_browse_descriptor_set_include_txt_record(
            descriptor: &NWBrowseDescriptor,
            include_txt_record: bool,
        );
    }
    unsafe { nw_browse_descriptor_set_include_txt_record(self, include_txt_record) }
}

#[deprecated = "renamed to `NWBrowseDescriptor::include_txt_record`"]
#[inline]
pub extern "C-unwind" fn nw_browse_descriptor_get_include_txt_record(&self) -> bool {
    extern "C-unwind" {
        fn nw_browse_descriptor_get_include_txt_record(descriptor: &NWBrowseDescriptor) -> bool;
    }
    unsafe { nw_browse_descriptor_get_include_txt_record(self) }
}

#[deprecated = "renamed to `NWBrowseDescriptor::new_application_service`"]
#[inline]
pub unsafe extern "C-unwind" fn nw_browse_descriptor_create_application_service(
    application_service_name: NonNull<c_char>,
) -> NWRetained<NWBrowseDescriptor> {
    extern "C-unwind" {
        fn nw_browse_descriptor_create_application_service(
            application_service_name: NonNull<c_char>,
        ) -> Option<NonNull<NWBrowseDescriptor>>;
    }
    let ret = unsafe { nw_browse_descriptor_create_application_service(application_service_name) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWBrowseDescriptor::application_service_name`"]
#[inline]
pub extern "C-unwind" fn nw_browse_descriptor_get_application_service_name(&self) -> *const c_char {
    extern "C-unwind" {
        fn nw_browse_descriptor_get_application_service_name(
            descriptor: &NWBrowseDescriptor,
        ) -> *const c_char;
    }
    unsafe { nw_browse_descriptor_get_application_service_name(self) }
}

#[deprecated = "renamed to `NWBrowseResult::endpoint`"]
#[inline]
pub extern "C-unwind" fn nw_browse_result_copy_endpoint(&self) -> NWRetained<NWEndpoint> {
    extern "C-unwind" {
        fn nw_browse_result_copy_endpoint(result: &NWBrowseResult) -> Option<NonNull<NWEndpoint>>;
    }
    let ret = unsafe { nw_browse_result_copy_endpoint(self) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWBrowseResult::changes`"]
#[inline]
pub extern "C-unwind" fn nw_browse_result_get_changes(
    &self,
    new_result: Option<&NWBrowseResult>,
) -> nw_browse_result_change_t {
    extern "C-unwind" {
        fn nw_browse_result_get_changes(
            old_result: Option<&NWBrowseResult>,
            new_result: Option<&NWBrowseResult>,
        ) -> nw_browse_result_change_t;
    }
    unsafe { nw_browse_result_get_changes(self, new_result) }
}

#[deprecated = "renamed to `NWBrowseResult::interfaces_count`"]
#[inline]
pub extern "C-unwind" fn nw_browse_result_get_interfaces_count(&self) -> usize {
    extern "C-unwind" {
        fn nw_browse_result_get_interfaces_count(result: &NWBrowseResult) -> usize;
    }
    unsafe { nw_browse_result_get_interfaces_count(self) }
}

#[deprecated = "renamed to `NWBrowseResult::txt_record_object`"]
#[inline]
pub extern "C-unwind" fn nw_browse_result_copy_txt_record_object(
    &self,
) -> Option<NWRetained<NWTxtRecord>> {
    extern "C-unwind" {
        fn nw_browse_result_copy_txt_record_object(
            result: &NWBrowseResult,
        ) -> Option<NonNull<NWTxtRecord>>;
    }
    let ret = unsafe { nw_browse_result_copy_txt_record_object(self) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWBrowseResult::enumerate_interfaces`"]
    pub fn nw_browse_result_enumerate_interfaces(
        result: &NWBrowseResult,
        enumerator: nw_browse_result_enumerate_interface_t,
    );
}

#[deprecated = "renamed to `NWError::error_domain`"]
#[inline]
pub extern "C-unwind" fn nw_error_get_error_domain(&self) -> nw_error_domain_t {
    extern "C-unwind" {
        fn nw_error_get_error_domain(error: &NWError) -> nw_error_domain_t;
    }
    unsafe { nw_error_get_error_domain(self) }
}

#[deprecated = "renamed to `NWError::error_code`"]
#[inline]
pub extern "C-unwind" fn nw_error_get_error_code(&self) -> c_int {
    extern "C-unwind" {
        fn nw_error_get_error_code(error: &NWError) -> c_int;
    }
    unsafe { nw_error_get_error_code(self) }
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `NWError::cf_error`"]
#[inline]
pub extern "C-unwind" fn nw_error_copy_cf_error(&self) -> CFRetained<CFError> {
    extern "C-unwind" {
        fn nw_error_copy_cf_error(error: &NWError) -> Option<NonNull<CFError>>;
    }
    let ret = unsafe { nw_error_copy_cf_error(self) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWBrowser::new`"]
#[inline]
pub extern "C-unwind" fn nw_browser_create(
    descriptor: &NWBrowseDescriptor,
    parameters: Option<&NWParameters>,
) -> NWRetained<NWBrowser> {
    extern "C-unwind" {
        fn nw_browser_create(
            descriptor: &NWBrowseDescriptor,
            parameters: Option<&NWParameters>,
        ) -> Option<NonNull<NWBrowser>>;
    }
    let ret = unsafe { nw_browser_create(descriptor, parameters) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWBrowser::set_queue`"]
#[inline]
pub extern "C-unwind" fn nw_browser_set_queue(&self, queue: &DispatchQueue) {
    extern "C-unwind" {
        fn nw_browser_set_queue(browser: &NWBrowser, queue: &DispatchQueue);
    }
    unsafe { nw_browser_set_queue(self, queue) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWBrowser::set_browse_results_changed_handler`"]
    pub fn nw_browser_set_browse_results_changed_handler(
        browser: &NWBrowser,
        handler: nw_browser_browse_results_changed_handler_t,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWBrowser::set_state_changed_handler`"]
    pub fn nw_browser_set_state_changed_handler(
        browser: &NWBrowser,
        state_changed_handler: nw_browser_state_changed_handler_t,
    );
}

#[deprecated = "renamed to `NWBrowser::start`"]
#[inline]
pub extern "C-unwind" fn nw_browser_start(&self) {
    extern "C-unwind" {
        fn nw_browser_start(browser: &NWBrowser);
    }
    unsafe { nw_browser_start(self) }
}

#[deprecated = "renamed to `NWBrowser::cancel`"]
#[inline]
pub extern "C-unwind" fn nw_browser_cancel(&self) {
    extern "C-unwind" {
        fn nw_browser_cancel(browser: &NWBrowser);
    }
    unsafe { nw_browser_cancel(self) }
}

#[deprecated = "renamed to `NWBrowser::parameters`"]
#[inline]
pub extern "C-unwind" fn nw_browser_copy_parameters(&self) -> NWRetained<NWParameters> {
    extern "C-unwind" {
        fn nw_browser_copy_parameters(browser: &NWBrowser) -> Option<NonNull<NWParameters>>;
    }
    let ret = unsafe { nw_browser_copy_parameters(self) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWBrowser::browse_descriptor`"]
#[inline]
pub extern "C-unwind" fn nw_browser_copy_browse_descriptor(
    &self,
) -> NWRetained<NWBrowseDescriptor> {
    extern "C-unwind" {
        fn nw_browser_copy_browse_descriptor(
            browser: &NWBrowser,
        ) -> Option<NonNull<NWBrowseDescriptor>>;
    }
    let ret = unsafe { nw_browser_copy_browse_descriptor(self) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWPath::status`"]
#[inline]
pub extern "C-unwind" fn nw_path_get_status(&self) -> nw_path_status_t {
    extern "C-unwind" {
        fn nw_path_get_status(path: &NWPath) -> nw_path_status_t;
    }
    unsafe { nw_path_get_status(self) }
}

#[deprecated = "renamed to `NWPath::unsatisfied_reason`"]
#[inline]
pub extern "C-unwind" fn nw_path_get_unsatisfied_reason(&self) -> nw_path_unsatisfied_reason_t {
    extern "C-unwind" {
        fn nw_path_get_unsatisfied_reason(path: &NWPath) -> nw_path_unsatisfied_reason_t;
    }
    unsafe { nw_path_get_unsatisfied_reason(self) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWPath::enumerate_interfaces`"]
    pub fn nw_path_enumerate_interfaces(
        path: &NWPath,
        enumerate_block: nw_path_enumerate_interfaces_block_t,
    );
}

#[deprecated = "renamed to `NWPath::is_equal`"]
#[inline]
pub extern "C-unwind" fn nw_path_is_equal(&self, other_path: &NWPath) -> bool {
    extern "C-unwind" {
        fn nw_path_is_equal(path: &NWPath, other_path: &NWPath) -> bool;
    }
    unsafe { nw_path_is_equal(self, other_path) }
}

#[deprecated = "renamed to `NWPath::is_expensive`"]
#[inline]
pub extern "C-unwind" fn nw_path_is_expensive(&self) -> bool {
    extern "C-unwind" {
        fn nw_path_is_expensive(path: &NWPath) -> bool;
    }
    unsafe { nw_path_is_expensive(self) }
}

#[deprecated = "renamed to `NWPath::is_constrained`"]
#[inline]
pub extern "C-unwind" fn nw_path_is_constrained(&self) -> bool {
    extern "C-unwind" {
        fn nw_path_is_constrained(path: &NWPath) -> bool;
    }
    unsafe { nw_path_is_constrained(self) }
}

#[deprecated = "renamed to `NWPath::is_ultra_constrained`"]
#[inline]
pub extern "C-unwind" fn nw_path_is_ultra_constrained(&self) -> bool {
    extern "C-unwind" {
        fn nw_path_is_ultra_constrained(path: &NWPath) -> bool;
    }
    unsafe { nw_path_is_ultra_constrained(self) }
}

#[deprecated = "renamed to `NWPath::has_ipv4`"]
#[inline]
pub extern "C-unwind" fn nw_path_has_ipv4(&self) -> bool {
    extern "C-unwind" {
        fn nw_path_has_ipv4(path: &NWPath) -> bool;
    }
    unsafe { nw_path_has_ipv4(self) }
}

#[deprecated = "renamed to `NWPath::has_ipv6`"]
#[inline]
pub extern "C-unwind" fn nw_path_has_ipv6(&self) -> bool {
    extern "C-unwind" {
        fn nw_path_has_ipv6(path: &NWPath) -> bool;
    }
    unsafe { nw_path_has_ipv6(self) }
}

#[deprecated = "renamed to `NWPath::has_dns`"]
#[inline]
pub extern "C-unwind" fn nw_path_has_dns(&self) -> bool {
    extern "C-unwind" {
        fn nw_path_has_dns(path: &NWPath) -> bool;
    }
    unsafe { nw_path_has_dns(self) }
}

#[deprecated = "renamed to `NWPath::uses_interface_type`"]
#[inline]
pub extern "C-unwind" fn nw_path_uses_interface_type(
    &self,
    interface_type: nw_interface_type_t,
) -> bool {
    extern "C-unwind" {
        fn nw_path_uses_interface_type(path: &NWPath, interface_type: nw_interface_type_t) -> bool;
    }
    unsafe { nw_path_uses_interface_type(self, interface_type) }
}

#[deprecated = "renamed to `NWPath::effective_local_endpoint`"]
#[inline]
pub extern "C-unwind" fn nw_path_copy_effective_local_endpoint(
    &self,
) -> Option<NWRetained<NWEndpoint>> {
    extern "C-unwind" {
        fn nw_path_copy_effective_local_endpoint(path: &NWPath) -> Option<NonNull<NWEndpoint>>;
    }
    let ret = unsafe { nw_path_copy_effective_local_endpoint(self) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

#[deprecated = "renamed to `NWPath::effective_remote_endpoint`"]
#[inline]
pub extern "C-unwind" fn nw_path_copy_effective_remote_endpoint(
    &self,
) -> Option<NWRetained<NWEndpoint>> {
    extern "C-unwind" {
        fn nw_path_copy_effective_remote_endpoint(path: &NWPath) -> Option<NonNull<NWEndpoint>>;
    }
    let ret = unsafe { nw_path_copy_effective_remote_endpoint(self) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWPath::enumerate_gateways`"]
    pub fn nw_path_enumerate_gateways(
        path: &NWPath,
        enumerate_block: nw_path_enumerate_gateways_block_t,
    );
}

#[deprecated = "renamed to `NWPath::link_quality`"]
#[inline]
pub extern "C-unwind" fn nw_path_get_link_quality(&self) -> nw_link_quality_t {
    extern "C-unwind" {
        fn nw_path_get_link_quality(path: &NWPath) -> nw_link_quality_t;
    }
    unsafe { nw_path_get_link_quality(self) }
}

#[deprecated = "renamed to `NWContentContext::new`"]
#[inline]
pub unsafe extern "C-unwind" fn nw_content_context_create(
    context_identifier: NonNull<c_char>,
) -> NWRetained<NWContentContext> {
    extern "C-unwind" {
        fn nw_content_context_create(
            context_identifier: NonNull<c_char>,
        ) -> Option<NonNull<NWContentContext>>;
    }
    let ret = unsafe { nw_content_context_create(context_identifier) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWContentContext::identifier`"]
#[inline]
pub extern "C-unwind" fn nw_content_context_get_identifier(&self) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_content_context_get_identifier(context: &NWContentContext)
            -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_content_context_get_identifier(self) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

#[deprecated = "renamed to `NWContentContext::is_final`"]
#[inline]
pub extern "C-unwind" fn nw_content_context_get_is_final(&self) -> bool {
    extern "C-unwind" {
        fn nw_content_context_get_is_final(context: &NWContentContext) -> bool;
    }
    unsafe { nw_content_context_get_is_final(self) }
}

#[deprecated = "renamed to `NWContentContext::set_is_final`"]
#[inline]
pub extern "C-unwind" fn nw_content_context_set_is_final(&self, is_final: bool) {
    extern "C-unwind" {
        fn nw_content_context_set_is_final(context: &NWContentContext, is_final: bool);
    }
    unsafe { nw_content_context_set_is_final(self, is_final) }
}

#[deprecated = "renamed to `NWContentContext::expiration_milliseconds`"]
#[inline]
pub extern "C-unwind" fn nw_content_context_get_expiration_milliseconds(&self) -> u64 {
    extern "C-unwind" {
        fn nw_content_context_get_expiration_milliseconds(context: &NWContentContext) -> u64;
    }
    unsafe { nw_content_context_get_expiration_milliseconds(self) }
}

#[deprecated = "renamed to `NWContentContext::set_expiration_milliseconds`"]
#[inline]
pub extern "C-unwind" fn nw_content_context_set_expiration_milliseconds(
    &self,
    expiration_milliseconds: u64,
) {
    extern "C-unwind" {
        fn nw_content_context_set_expiration_milliseconds(
            context: &NWContentContext,
            expiration_milliseconds: u64,
        );
    }
    unsafe { nw_content_context_set_expiration_milliseconds(self, expiration_milliseconds) }
}

#[deprecated = "renamed to `NWContentContext::relative_priority`"]
#[inline]
pub extern "C-unwind" fn nw_content_context_get_relative_priority(&self) -> c_double {
    extern "C-unwind" {
        fn nw_content_context_get_relative_priority(context: &NWContentContext) -> c_double;
    }
    unsafe { nw_content_context_get_relative_priority(self) }
}

#[deprecated = "renamed to `NWContentContext::set_relative_priority`"]
#[inline]
pub extern "C-unwind" fn nw_content_context_set_relative_priority(
    &self,
    relative_priority: c_double,
) {
    extern "C-unwind" {
        fn nw_content_context_set_relative_priority(
            context: &NWContentContext,
            relative_priority: c_double,
        );
    }
    unsafe { nw_content_context_set_relative_priority(self, relative_priority) }
}

#[deprecated = "renamed to `NWContentContext::set_antecedent`"]
#[inline]
pub extern "C-unwind" fn nw_content_context_set_antecedent(
    &self,
    antecedent_context: Option<&NWContentContext>,
) {
    extern "C-unwind" {
        fn nw_content_context_set_antecedent(
            context: &NWContentContext,
            antecedent_context: Option<&NWContentContext>,
        );
    }
    unsafe { nw_content_context_set_antecedent(self, antecedent_context) }
}

#[deprecated = "renamed to `NWContentContext::antecedent`"]
#[inline]
pub extern "C-unwind" fn nw_content_context_copy_antecedent(
    &self,
) -> Option<NWRetained<NWContentContext>> {
    extern "C-unwind" {
        fn nw_content_context_copy_antecedent(
            context: &NWContentContext,
        ) -> Option<NonNull<NWContentContext>>;
    }
    let ret = unsafe { nw_content_context_copy_antecedent(self) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

#[deprecated = "renamed to `NWContentContext::set_metadata_for_protocol`"]
#[inline]
pub extern "C-unwind" fn nw_content_context_set_metadata_for_protocol(
    &self,
    protocol_metadata: &NWProtocolMetadata,
) {
    extern "C-unwind" {
        fn nw_content_context_set_metadata_for_protocol(
            context: &NWContentContext,
            protocol_metadata: &NWProtocolMetadata,
        );
    }
    unsafe { nw_content_context_set_metadata_for_protocol(self, protocol_metadata) }
}

#[deprecated = "renamed to `NWContentContext::protocol_metadata`"]
#[inline]
pub extern "C-unwind" fn nw_content_context_copy_protocol_metadata(
    &self,
    protocol: &NWProtocolDefinition,
) -> Option<NWRetained<NWProtocolMetadata>> {
    extern "C-unwind" {
        fn nw_content_context_copy_protocol_metadata(
            context: &NWContentContext,
            protocol: &NWProtocolDefinition,
        ) -> Option<NonNull<NWProtocolMetadata>>;
    }
    let ret = unsafe { nw_content_context_copy_protocol_metadata(self, protocol) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

#[deprecated = "renamed to `NWContentContext::foreach_protocol_metadata`"]
#[inline]
pub extern "C-unwind" fn nw_content_context_foreach_protocol_metadata(
    &self,
    foreach_block: &block2::DynBlock<
        dyn Fn(NonNull<NWProtocolDefinition>, NonNull<NWProtocolMetadata>),
    >,
) {
    extern "C-unwind" {
        fn nw_content_context_foreach_protocol_metadata(
            context: &NWContentContext,
            foreach_block: &block2::DynBlock<
                dyn Fn(NonNull<NWProtocolDefinition>, NonNull<NWProtocolMetadata>),
            >,
        );
    }
    unsafe { nw_content_context_foreach_protocol_metadata(self, foreach_block) }
}

#[deprecated = "renamed to `NWConnection::new`"]
#[inline]
pub extern "C-unwind" fn nw_connection_create(
    endpoint: &NWEndpoint,
    parameters: &NWParameters,
) -> NWRetained<NWConnection> {
    extern "C-unwind" {
        fn nw_connection_create(
            endpoint: &NWEndpoint,
            parameters: &NWParameters,
        ) -> Option<NonNull<NWConnection>>;
    }
    let ret = unsafe { nw_connection_create(endpoint, parameters) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWConnection::endpoint`"]
#[inline]
pub extern "C-unwind" fn nw_connection_copy_endpoint(&self) -> NWRetained<NWEndpoint> {
    extern "C-unwind" {
        fn nw_connection_copy_endpoint(connection: &NWConnection) -> Option<NonNull<NWEndpoint>>;
    }
    let ret = unsafe { nw_connection_copy_endpoint(self) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWConnection::parameters`"]
#[inline]
pub extern "C-unwind" fn nw_connection_copy_parameters(&self) -> NWRetained<NWParameters> {
    extern "C-unwind" {
        fn nw_connection_copy_parameters(
            connection: &NWConnection,
        ) -> Option<NonNull<NWParameters>>;
    }
    let ret = unsafe { nw_connection_copy_parameters(self) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWConnection::set_state_changed_handler`"]
    pub fn nw_connection_set_state_changed_handler(
        connection: &NWConnection,
        handler: nw_connection_state_changed_handler_t,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWConnection::set_viability_changed_handler`"]
    pub fn nw_connection_set_viability_changed_handler(
        connection: &NWConnection,
        handler: nw_connection_boolean_event_handler_t,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWConnection::set_better_path_available_handler`"]
    pub fn nw_connection_set_better_path_available_handler(
        connection: &NWConnection,
        handler: nw_connection_boolean_event_handler_t,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWConnection::set_path_changed_handler`"]
    pub fn nw_connection_set_path_changed_handler(
        connection: &NWConnection,
        handler: nw_connection_path_event_handler_t,
    );
}

#[deprecated = "renamed to `NWConnection::set_queue`"]
#[inline]
pub extern "C-unwind" fn nw_connection_set_queue(&self, queue: &DispatchQueue) {
    extern "C-unwind" {
        fn nw_connection_set_queue(connection: &NWConnection, queue: &DispatchQueue);
    }
    unsafe { nw_connection_set_queue(self, queue) }
}

#[deprecated = "renamed to `NWConnection::start`"]
#[inline]
pub extern "C-unwind" fn nw_connection_start(&self) {
    extern "C-unwind" {
        fn nw_connection_start(connection: &NWConnection);
    }
    unsafe { nw_connection_start(self) }
}

#[deprecated = "renamed to `NWConnection::restart`"]
#[inline]
pub extern "C-unwind" fn nw_connection_restart(&self) {
    extern "C-unwind" {
        fn nw_connection_restart(connection: &NWConnection);
    }
    unsafe { nw_connection_restart(self) }
}

#[deprecated = "renamed to `NWConnection::cancel`"]
#[inline]
pub extern "C-unwind" fn nw_connection_cancel(&self) {
    extern "C-unwind" {
        fn nw_connection_cancel(connection: &NWConnection);
    }
    unsafe { nw_connection_cancel(self) }
}

#[deprecated = "renamed to `NWConnection::force_cancel`"]
#[inline]
pub extern "C-unwind" fn nw_connection_force_cancel(&self) {
    extern "C-unwind" {
        fn nw_connection_force_cancel(connection: &NWConnection);
    }
    unsafe { nw_connection_force_cancel(self) }
}

#[deprecated = "renamed to `NWConnection::cancel_current_endpoint`"]
#[inline]
pub extern "C-unwind" fn nw_connection_cancel_current_endpoint(&self) {
    extern "C-unwind" {
        fn nw_connection_cancel_current_endpoint(connection: &NWConnection);
    }
    unsafe { nw_connection_cancel_current_endpoint(self) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWConnection::receive`"]
    pub fn nw_connection_receive(
        connection: &NWConnection,
        minimum_incomplete_length: u32,
        maximum_length: u32,
        completion: nw_connection_receive_completion_t,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWConnection::receive_message`"]
    pub fn nw_connection_receive_message(
        connection: &NWConnection,
        completion: nw_connection_receive_completion_t,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWConnection::send`"]
    pub fn nw_connection_send(
        connection: &NWConnection,
        content: Option<&DispatchData>,
        context: &NWContentContext,
        is_complete: bool,
        completion: nw_connection_send_completion_t,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWConnection::batch`"]
    pub fn nw_connection_batch(connection: &NWConnection, batch_block: dispatch_block_t);
}

#[deprecated = "renamed to `NWConnection::description`"]
#[inline]
pub extern "C-unwind" fn nw_connection_copy_description(&self) -> NonNull<c_char> {
    extern "C-unwind" {
        fn nw_connection_copy_description(connection: &NWConnection) -> Option<NonNull<c_char>>;
    }
    let ret = unsafe { nw_connection_copy_description(self) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

#[deprecated = "renamed to `NWConnection::current_path`"]
#[inline]
pub extern "C-unwind" fn nw_connection_copy_current_path(&self) -> Option<NWRetained<NWPath>> {
    extern "C-unwind" {
        fn nw_connection_copy_current_path(connection: &NWConnection) -> Option<NonNull<NWPath>>;
    }
    let ret = unsafe { nw_connection_copy_current_path(self) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

#[deprecated = "renamed to `NWConnection::protocol_metadata`"]
#[inline]
pub extern "C-unwind" fn nw_connection_copy_protocol_metadata(
    &self,
    definition: &NWProtocolDefinition,
) -> Option<NWRetained<NWProtocolMetadata>> {
    extern "C-unwind" {
        fn nw_connection_copy_protocol_metadata(
            connection: &NWConnection,
            definition: &NWProtocolDefinition,
        ) -> Option<NonNull<NWProtocolMetadata>>;
    }
    let ret = unsafe { nw_connection_copy_protocol_metadata(self, definition) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

#[deprecated = "renamed to `NWConnection::maximum_datagram_size`"]
#[inline]
pub extern "C-unwind" fn nw_connection_get_maximum_datagram_size(&self) -> u32 {
    extern "C-unwind" {
        fn nw_connection_get_maximum_datagram_size(connection: &NWConnection) -> u32;
    }
    unsafe { nw_connection_get_maximum_datagram_size(self) }
}

#[deprecated = "renamed to `NWGroupDescriptor::new_multiplex`"]
#[inline]
pub extern "C-unwind" fn nw_group_descriptor_create_multiplex(
    remote_endpoint: &NWEndpoint,
) -> NWRetained<NWGroupDescriptor> {
    extern "C-unwind" {
        fn nw_group_descriptor_create_multiplex(
            remote_endpoint: &NWEndpoint,
        ) -> Option<NonNull<NWGroupDescriptor>>;
    }
    let ret = unsafe { nw_group_descriptor_create_multiplex(remote_endpoint) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWGroupDescriptor::new_multicast`"]
#[inline]
pub extern "C-unwind" fn nw_group_descriptor_create_multicast(
    multicast_group: &NWEndpoint,
) -> NWRetained<NWGroupDescriptor> {
    extern "C-unwind" {
        fn nw_group_descriptor_create_multicast(
            multicast_group: &NWEndpoint,
        ) -> Option<NonNull<NWGroupDescriptor>>;
    }
    let ret = unsafe { nw_group_descriptor_create_multicast(multicast_group) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWGroupDescriptor::add_endpoint`"]
#[inline]
pub extern "C-unwind" fn nw_group_descriptor_add_endpoint(&self, endpoint: &NWEndpoint) -> bool {
    extern "C-unwind" {
        fn nw_group_descriptor_add_endpoint(
            descriptor: &NWGroupDescriptor,
            endpoint: &NWEndpoint,
        ) -> bool;
    }
    unsafe { nw_group_descriptor_add_endpoint(self, endpoint) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWGroupDescriptor::enumerate_endpoints`"]
    pub fn nw_group_descriptor_enumerate_endpoints(
        descriptor: &NWGroupDescriptor,
        enumerate_block: nw_group_descriptor_enumerate_endpoints_block_t,
    );
}

#[deprecated = "renamed to `NWConnectionGroup::new`"]
#[inline]
pub extern "C-unwind" fn nw_connection_group_create(
    group_descriptor: &NWGroupDescriptor,
    parameters: &NWParameters,
) -> NWRetained<NWConnectionGroup> {
    extern "C-unwind" {
        fn nw_connection_group_create(
            group_descriptor: &NWGroupDescriptor,
            parameters: &NWParameters,
        ) -> Option<NonNull<NWConnectionGroup>>;
    }
    let ret = unsafe { nw_connection_group_create(group_descriptor, parameters) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWConnectionGroup::descriptor`"]
#[inline]
pub extern "C-unwind" fn nw_connection_group_copy_descriptor(
    &self,
) -> NWRetained<NWGroupDescriptor> {
    extern "C-unwind" {
        fn nw_connection_group_copy_descriptor(
            group: &NWConnectionGroup,
        ) -> Option<NonNull<NWGroupDescriptor>>;
    }
    let ret = unsafe { nw_connection_group_copy_descriptor(self) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWConnectionGroup::parameters`"]
#[inline]
pub extern "C-unwind" fn nw_connection_group_copy_parameters(&self) -> NWRetained<NWParameters> {
    extern "C-unwind" {
        fn nw_connection_group_copy_parameters(
            group: &NWConnectionGroup,
        ) -> Option<NonNull<NWParameters>>;
    }
    let ret = unsafe { nw_connection_group_copy_parameters(self) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWConnectionGroup::set_queue`"]
#[inline]
pub extern "C-unwind" fn nw_connection_group_set_queue(&self, queue: &DispatchQueue) {
    extern "C-unwind" {
        fn nw_connection_group_set_queue(group: &NWConnectionGroup, queue: &DispatchQueue);
    }
    unsafe { nw_connection_group_set_queue(self, queue) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWConnectionGroup::set_state_changed_handler`"]
    pub fn nw_connection_group_set_state_changed_handler(
        group: &NWConnectionGroup,
        state_changed_handler: nw_connection_group_state_changed_handler_t,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWConnectionGroup::set_receive_handler`"]
    pub fn nw_connection_group_set_receive_handler(
        group: &NWConnectionGroup,
        maximum_message_size: u32,
        reject_oversized_messages: bool,
        receive_handler: nw_connection_group_receive_handler_t,
    );
}

#[deprecated = "renamed to `NWConnectionGroup::start`"]
#[inline]
pub extern "C-unwind" fn nw_connection_group_start(&self) {
    extern "C-unwind" {
        fn nw_connection_group_start(group: &NWConnectionGroup);
    }
    unsafe { nw_connection_group_start(self) }
}

#[deprecated = "renamed to `NWConnectionGroup::cancel`"]
#[inline]
pub extern "C-unwind" fn nw_connection_group_cancel(&self) {
    extern "C-unwind" {
        fn nw_connection_group_cancel(group: &NWConnectionGroup);
    }
    unsafe { nw_connection_group_cancel(self) }
}

#[deprecated = "renamed to `NWConnectionGroup::remote_endpoint_for_message`"]
#[inline]
pub extern "C-unwind" fn nw_connection_group_copy_remote_endpoint_for_message(
    &self,
    context: &NWContentContext,
) -> Option<NWRetained<NWEndpoint>> {
    extern "C-unwind" {
        fn nw_connection_group_copy_remote_endpoint_for_message(
            group: &NWConnectionGroup,
            context: &NWContentContext,
        ) -> Option<NonNull<NWEndpoint>>;
    }
    let ret = unsafe { nw_connection_group_copy_remote_endpoint_for_message(self, context) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

#[deprecated = "renamed to `NWConnectionGroup::local_endpoint_for_message`"]
#[inline]
pub extern "C-unwind" fn nw_connection_group_copy_local_endpoint_for_message(
    &self,
    context: &NWContentContext,
) -> Option<NWRetained<NWEndpoint>> {
    extern "C-unwind" {
        fn nw_connection_group_copy_local_endpoint_for_message(
            group: &NWConnectionGroup,
            context: &NWContentContext,
        ) -> Option<NonNull<NWEndpoint>>;
    }
    let ret = unsafe { nw_connection_group_copy_local_endpoint_for_message(self, context) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

#[deprecated = "renamed to `NWConnectionGroup::path_for_message`"]
#[inline]
pub extern "C-unwind" fn nw_connection_group_copy_path_for_message(
    &self,
    context: &NWContentContext,
) -> Option<NWRetained<NWPath>> {
    extern "C-unwind" {
        fn nw_connection_group_copy_path_for_message(
            group: &NWConnectionGroup,
            context: &NWContentContext,
        ) -> Option<NonNull<NWPath>>;
    }
    let ret = unsafe { nw_connection_group_copy_path_for_message(self, context) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

#[deprecated = "renamed to `NWConnectionGroup::protocol_metadata_for_message`"]
#[inline]
pub extern "C-unwind" fn nw_connection_group_copy_protocol_metadata_for_message(
    &self,
    context: &NWContentContext,
    definition: &NWProtocolDefinition,
) -> Option<NWRetained<NWProtocolMetadata>> {
    extern "C-unwind" {
        fn nw_connection_group_copy_protocol_metadata_for_message(
            group: &NWConnectionGroup,
            context: &NWContentContext,
            definition: &NWProtocolDefinition,
        ) -> Option<NonNull<NWProtocolMetadata>>;
    }
    let ret = unsafe {
        nw_connection_group_copy_protocol_metadata_for_message(self, context, definition)
    };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

#[deprecated = "renamed to `NWConnectionGroup::extract_connection_for_message`"]
#[inline]
pub extern "C-unwind" fn nw_connection_group_extract_connection_for_message(
    &self,
    context: &NWContentContext,
) -> Option<NWRetained<NWConnection>> {
    extern "C-unwind" {
        fn nw_connection_group_extract_connection_for_message(
            group: &NWConnectionGroup,
            context: &NWContentContext,
        ) -> Option<NonNull<NWConnection>>;
    }
    let ret = unsafe { nw_connection_group_extract_connection_for_message(self, context) };
    ret.map(|ret| unsafe { NWRetained::retain(ret) })
}

#[deprecated = "renamed to `NWConnectionGroup::reply`"]
#[inline]
pub extern "C-unwind" fn nw_connection_group_reply(
    &self,
    inbound_message: &NWContentContext,
    outbound_message: &NWContentContext,
    content: Option<&DispatchData>,
) {
    extern "C-unwind" {
        fn nw_connection_group_reply(
            group: &NWConnectionGroup,
            inbound_message: &NWContentContext,
            outbound_message: &NWContentContext,
            content: Option<&DispatchData>,
        );
    }
    unsafe { nw_connection_group_reply(self, inbound_message, outbound_message, content) }
}

#[deprecated = "renamed to `NWConnectionGroup::extract_connection`"]
#[inline]
pub extern "C-unwind" fn nw_connection_group_extract_connection(
    &self,
    endpoint: Option<&NWEndpoint>,
    protocol_options: Option<&NWProtocolOptions>,
) -> Option<NWRetained<NWConnection>> {
    extern "C-unwind" {
        fn nw_connection_group_extract_connection(
            group: &NWConnectionGroup,
            endpoint: Option<&NWEndpoint>,
            protocol_options: Option<&NWProtocolOptions>,
        ) -> Option<NonNull<NWConnection>>;
    }
    let ret = unsafe { nw_connection_group_extract_connection(self, endpoint, protocol_options) };
    ret.map(|ret| unsafe { NWRetained::retain(ret) })
}

#[deprecated = "renamed to `NWConnectionGroup::reinsert_extracted_connection`"]
#[inline]
pub extern "C-unwind" fn nw_connection_group_reinsert_extracted_connection(
    &self,
    connection: &NWConnection,
) -> bool {
    extern "C-unwind" {
        fn nw_connection_group_reinsert_extracted_connection(
            group: &NWConnectionGroup,
            connection: &NWConnection,
        ) -> bool;
    }
    unsafe { nw_connection_group_reinsert_extracted_connection(self, connection) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWConnectionGroup::send_message`"]
    pub fn nw_connection_group_send_message(
        group: &NWConnectionGroup,
        content: Option<&DispatchData>,
        endpoint: Option<&NWEndpoint>,
        context: &NWContentContext,
        completion: nw_connection_group_send_completion_t,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWConnectionGroup::set_new_connection_handler`"]
    pub fn nw_connection_group_set_new_connection_handler(
        group: &NWConnectionGroup,
        new_connection_handler: nw_connection_group_new_connection_handler_t,
    );
}

#[deprecated = "renamed to `NWConnectionGroup::protocol_metadata`"]
#[inline]
pub extern "C-unwind" fn nw_connection_group_copy_protocol_metadata(
    &self,
    definition: &NWProtocolDefinition,
) -> Option<NWRetained<NWProtocolMetadata>> {
    extern "C-unwind" {
        fn nw_connection_group_copy_protocol_metadata(
            group: &NWConnectionGroup,
            definition: &NWProtocolDefinition,
        ) -> Option<NonNull<NWProtocolMetadata>>;
    }
    let ret = unsafe { nw_connection_group_copy_protocol_metadata(self, definition) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWConnection::access_establishment_report`"]
    pub fn nw_connection_access_establishment_report(
        connection: &NWConnection,
        queue: &DispatchQueue,
        access_block: nw_establishment_report_access_block_t,
    );
}

#[deprecated = "renamed to `NWEstablishmentReport::duration_milliseconds`"]
#[inline]
pub extern "C-unwind" fn nw_establishment_report_get_duration_milliseconds(&self) -> u64 {
    extern "C-unwind" {
        fn nw_establishment_report_get_duration_milliseconds(report: &NWEstablishmentReport)
            -> u64;
    }
    unsafe { nw_establishment_report_get_duration_milliseconds(self) }
}

#[deprecated = "renamed to `NWEstablishmentReport::attempt_started_after_milliseconds`"]
#[inline]
pub extern "C-unwind" fn nw_establishment_report_get_attempt_started_after_milliseconds(
    &self,
) -> u64 {
    extern "C-unwind" {
        fn nw_establishment_report_get_attempt_started_after_milliseconds(
            report: &NWEstablishmentReport,
        ) -> u64;
    }
    unsafe { nw_establishment_report_get_attempt_started_after_milliseconds(self) }
}

#[deprecated = "renamed to `NWEstablishmentReport::previous_attempt_count`"]
#[inline]
pub extern "C-unwind" fn nw_establishment_report_get_previous_attempt_count(&self) -> u32 {
    extern "C-unwind" {
        fn nw_establishment_report_get_previous_attempt_count(
            report: &NWEstablishmentReport,
        ) -> u32;
    }
    unsafe { nw_establishment_report_get_previous_attempt_count(self) }
}

#[deprecated = "renamed to `NWEstablishmentReport::used_proxy`"]
#[inline]
pub extern "C-unwind" fn nw_establishment_report_get_used_proxy(&self) -> bool {
    extern "C-unwind" {
        fn nw_establishment_report_get_used_proxy(report: &NWEstablishmentReport) -> bool;
    }
    unsafe { nw_establishment_report_get_used_proxy(self) }
}

#[deprecated = "renamed to `NWEstablishmentReport::proxy_configured`"]
#[inline]
pub extern "C-unwind" fn nw_establishment_report_get_proxy_configured(&self) -> bool {
    extern "C-unwind" {
        fn nw_establishment_report_get_proxy_configured(report: &NWEstablishmentReport) -> bool;
    }
    unsafe { nw_establishment_report_get_proxy_configured(self) }
}

#[deprecated = "renamed to `NWEstablishmentReport::proxy_endpoint`"]
#[inline]
pub extern "C-unwind" fn nw_establishment_report_copy_proxy_endpoint(
    &self,
) -> Option<NWRetained<NWEndpoint>> {
    extern "C-unwind" {
        fn nw_establishment_report_copy_proxy_endpoint(
            report: &NWEstablishmentReport,
        ) -> Option<NonNull<NWEndpoint>>;
    }
    let ret = unsafe { nw_establishment_report_copy_proxy_endpoint(self) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

#[deprecated = "renamed to `NWResolutionReport::source`"]
#[inline]
pub extern "C-unwind" fn nw_resolution_report_get_source(&self) -> nw_report_resolution_source_t {
    extern "C-unwind" {
        fn nw_resolution_report_get_source(
            resolution_report: &NWResolutionReport,
        ) -> nw_report_resolution_source_t;
    }
    unsafe { nw_resolution_report_get_source(self) }
}

#[deprecated = "renamed to `NWResolutionReport::milliseconds`"]
#[inline]
pub extern "C-unwind" fn nw_resolution_report_get_milliseconds(&self) -> u64 {
    extern "C-unwind" {
        fn nw_resolution_report_get_milliseconds(resolution_report: &NWResolutionReport) -> u64;
    }
    unsafe { nw_resolution_report_get_milliseconds(self) }
}

#[deprecated = "renamed to `NWResolutionReport::endpoint_count`"]
#[inline]
pub extern "C-unwind" fn nw_resolution_report_get_endpoint_count(&self) -> u32 {
    extern "C-unwind" {
        fn nw_resolution_report_get_endpoint_count(resolution_report: &NWResolutionReport) -> u32;
    }
    unsafe { nw_resolution_report_get_endpoint_count(self) }
}

#[deprecated = "renamed to `NWResolutionReport::successful_endpoint`"]
#[inline]
pub extern "C-unwind" fn nw_resolution_report_copy_successful_endpoint(
    &self,
) -> NWRetained<NWEndpoint> {
    extern "C-unwind" {
        fn nw_resolution_report_copy_successful_endpoint(
            resolution_report: &NWResolutionReport,
        ) -> Option<NonNull<NWEndpoint>>;
    }
    let ret = unsafe { nw_resolution_report_copy_successful_endpoint(self) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWResolutionReport::preferred_endpoint`"]
#[inline]
pub extern "C-unwind" fn nw_resolution_report_copy_preferred_endpoint(
    &self,
) -> NWRetained<NWEndpoint> {
    extern "C-unwind" {
        fn nw_resolution_report_copy_preferred_endpoint(
            resolution_report: &NWResolutionReport,
        ) -> Option<NonNull<NWEndpoint>>;
    }
    let ret = unsafe { nw_resolution_report_copy_preferred_endpoint(self) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWResolutionReport::protocol`"]
#[inline]
pub extern "C-unwind" fn nw_resolution_report_get_protocol(
    &self,
) -> nw_report_resolution_protocol_t {
    extern "C-unwind" {
        fn nw_resolution_report_get_protocol(
            resolution_report: &NWResolutionReport,
        ) -> nw_report_resolution_protocol_t;
    }
    unsafe { nw_resolution_report_get_protocol(self) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWEstablishmentReport::enumerate_resolutions`"]
    pub fn nw_establishment_report_enumerate_resolutions(
        report: &NWEstablishmentReport,
        enumerate_block: nw_report_resolution_enumerator_t,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWEstablishmentReport::enumerate_resolution_reports`"]
    pub fn nw_establishment_report_enumerate_resolution_reports(
        report: &NWEstablishmentReport,
        enumerate_block: nw_report_resolution_report_enumerator_t,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWEstablishmentReport::enumerate_protocols`"]
    pub fn nw_establishment_report_enumerate_protocols(
        report: &NWEstablishmentReport,
        enumerate_block: nw_report_protocol_enumerator_t,
    );
}

#[deprecated = "renamed to `NWConnection::new_data_transfer_report`"]
#[inline]
pub extern "C-unwind" fn nw_connection_create_new_data_transfer_report(
    &self,
) -> NWRetained<NWDataTransferReport> {
    extern "C-unwind" {
        fn nw_connection_create_new_data_transfer_report(
            connection: &NWConnection,
        ) -> Option<NonNull<NWDataTransferReport>>;
    }
    let ret = unsafe { nw_connection_create_new_data_transfer_report(self) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWDataTransferReport::state`"]
#[inline]
pub extern "C-unwind" fn nw_data_transfer_report_get_state(
    &self,
) -> nw_data_transfer_report_state_t {
    extern "C-unwind" {
        fn nw_data_transfer_report_get_state(
            report: &NWDataTransferReport,
        ) -> nw_data_transfer_report_state_t;
    }
    unsafe { nw_data_transfer_report_get_state(self) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWDataTransferReport::collect`"]
    pub fn nw_data_transfer_report_collect(
        report: &NWDataTransferReport,
        queue: &DispatchQueue,
        collect_block: nw_data_transfer_report_collect_block_t,
    );
}

#[deprecated = "renamed to `NWDataTransferReport::duration_milliseconds`"]
#[inline]
pub extern "C-unwind" fn nw_data_transfer_report_get_duration_milliseconds(&self) -> u64 {
    extern "C-unwind" {
        fn nw_data_transfer_report_get_duration_milliseconds(report: &NWDataTransferReport) -> u64;
    }
    unsafe { nw_data_transfer_report_get_duration_milliseconds(self) }
}

#[deprecated = "renamed to `NWDataTransferReport::path_count`"]
#[inline]
pub extern "C-unwind" fn nw_data_transfer_report_get_path_count(&self) -> u32 {
    extern "C-unwind" {
        fn nw_data_transfer_report_get_path_count(report: &NWDataTransferReport) -> u32;
    }
    unsafe { nw_data_transfer_report_get_path_count(self) }
}

#[deprecated = "renamed to `NWDataTransferReport::received_ip_packet_count`"]
#[inline]
pub extern "C-unwind" fn nw_data_transfer_report_get_received_ip_packet_count(
    &self,
    path_index: u32,
) -> u64 {
    extern "C-unwind" {
        fn nw_data_transfer_report_get_received_ip_packet_count(
            report: &NWDataTransferReport,
            path_index: u32,
        ) -> u64;
    }
    unsafe { nw_data_transfer_report_get_received_ip_packet_count(self, path_index) }
}

#[deprecated = "renamed to `NWDataTransferReport::sent_ip_packet_count`"]
#[inline]
pub extern "C-unwind" fn nw_data_transfer_report_get_sent_ip_packet_count(
    &self,
    path_index: u32,
) -> u64 {
    extern "C-unwind" {
        fn nw_data_transfer_report_get_sent_ip_packet_count(
            report: &NWDataTransferReport,
            path_index: u32,
        ) -> u64;
    }
    unsafe { nw_data_transfer_report_get_sent_ip_packet_count(self, path_index) }
}

#[deprecated = "renamed to `NWDataTransferReport::received_transport_byte_count`"]
#[inline]
pub extern "C-unwind" fn nw_data_transfer_report_get_received_transport_byte_count(
    &self,
    path_index: u32,
) -> u64 {
    extern "C-unwind" {
        fn nw_data_transfer_report_get_received_transport_byte_count(
            report: &NWDataTransferReport,
            path_index: u32,
        ) -> u64;
    }
    unsafe { nw_data_transfer_report_get_received_transport_byte_count(self, path_index) }
}

#[deprecated = "renamed to `NWDataTransferReport::received_transport_duplicate_byte_count`"]
#[inline]
pub extern "C-unwind" fn nw_data_transfer_report_get_received_transport_duplicate_byte_count(
    &self,
    path_index: u32,
) -> u64 {
    extern "C-unwind" {
        fn nw_data_transfer_report_get_received_transport_duplicate_byte_count(
            report: &NWDataTransferReport,
            path_index: u32,
        ) -> u64;
    }
    unsafe { nw_data_transfer_report_get_received_transport_duplicate_byte_count(self, path_index) }
}

#[deprecated = "renamed to `NWDataTransferReport::received_transport_out_of_order_byte_count`"]
#[inline]
pub extern "C-unwind" fn nw_data_transfer_report_get_received_transport_out_of_order_byte_count(
    &self,
    path_index: u32,
) -> u64 {
    extern "C-unwind" {
        fn nw_data_transfer_report_get_received_transport_out_of_order_byte_count(
            report: &NWDataTransferReport,
            path_index: u32,
        ) -> u64;
    }
    unsafe {
        nw_data_transfer_report_get_received_transport_out_of_order_byte_count(self, path_index)
    }
}

#[deprecated = "renamed to `NWDataTransferReport::sent_transport_byte_count`"]
#[inline]
pub extern "C-unwind" fn nw_data_transfer_report_get_sent_transport_byte_count(
    &self,
    path_index: u32,
) -> u64 {
    extern "C-unwind" {
        fn nw_data_transfer_report_get_sent_transport_byte_count(
            report: &NWDataTransferReport,
            path_index: u32,
        ) -> u64;
    }
    unsafe { nw_data_transfer_report_get_sent_transport_byte_count(self, path_index) }
}

#[deprecated = "renamed to `NWDataTransferReport::sent_transport_retransmitted_byte_count`"]
#[inline]
pub extern "C-unwind" fn nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(
    &self,
    path_index: u32,
) -> u64 {
    extern "C-unwind" {
        fn nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(
            report: &NWDataTransferReport,
            path_index: u32,
        ) -> u64;
    }
    unsafe { nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(self, path_index) }
}

#[deprecated = "renamed to `NWDataTransferReport::transport_smoothed_rtt_milliseconds`"]
#[inline]
pub extern "C-unwind" fn nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds(
    &self,
    path_index: u32,
) -> u64 {
    extern "C-unwind" {
        fn nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds(
            report: &NWDataTransferReport,
            path_index: u32,
        ) -> u64;
    }
    unsafe { nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds(self, path_index) }
}

#[deprecated = "renamed to `NWDataTransferReport::transport_minimum_rtt_milliseconds`"]
#[inline]
pub extern "C-unwind" fn nw_data_transfer_report_get_transport_minimum_rtt_milliseconds(
    &self,
    path_index: u32,
) -> u64 {
    extern "C-unwind" {
        fn nw_data_transfer_report_get_transport_minimum_rtt_milliseconds(
            report: &NWDataTransferReport,
            path_index: u32,
        ) -> u64;
    }
    unsafe { nw_data_transfer_report_get_transport_minimum_rtt_milliseconds(self, path_index) }
}

#[deprecated = "renamed to `NWDataTransferReport::transport_rtt_variance`"]
#[inline]
pub extern "C-unwind" fn nw_data_transfer_report_get_transport_rtt_variance(
    &self,
    path_index: u32,
) -> u64 {
    extern "C-unwind" {
        fn nw_data_transfer_report_get_transport_rtt_variance(
            report: &NWDataTransferReport,
            path_index: u32,
        ) -> u64;
    }
    unsafe { nw_data_transfer_report_get_transport_rtt_variance(self, path_index) }
}

#[deprecated = "renamed to `NWDataTransferReport::received_application_byte_count`"]
#[inline]
pub extern "C-unwind" fn nw_data_transfer_report_get_received_application_byte_count(
    &self,
    path_index: u32,
) -> u64 {
    extern "C-unwind" {
        fn nw_data_transfer_report_get_received_application_byte_count(
            report: &NWDataTransferReport,
            path_index: u32,
        ) -> u64;
    }
    unsafe { nw_data_transfer_report_get_received_application_byte_count(self, path_index) }
}

#[deprecated = "renamed to `NWDataTransferReport::sent_application_byte_count`"]
#[inline]
pub extern "C-unwind" fn nw_data_transfer_report_get_sent_application_byte_count(
    &self,
    path_index: u32,
) -> u64 {
    extern "C-unwind" {
        fn nw_data_transfer_report_get_sent_application_byte_count(
            report: &NWDataTransferReport,
            path_index: u32,
        ) -> u64;
    }
    unsafe { nw_data_transfer_report_get_sent_application_byte_count(self, path_index) }
}

#[deprecated = "renamed to `NWDataTransferReport::path_interface`"]
#[inline]
pub extern "C-unwind" fn nw_data_transfer_report_copy_path_interface(
    &self,
    path_index: u32,
) -> NWRetained<NWInterface> {
    extern "C-unwind" {
        fn nw_data_transfer_report_copy_path_interface(
            report: &NWDataTransferReport,
            path_index: u32,
        ) -> Option<NonNull<NWInterface>>;
    }
    let ret = unsafe { nw_data_transfer_report_copy_path_interface(self, path_index) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWDataTransferReport::path_radio_type`"]
#[inline]
pub extern "C-unwind" fn nw_data_transfer_report_get_path_radio_type(
    &self,
    path_index: u32,
) -> nw_interface_radio_type_t {
    extern "C-unwind" {
        fn nw_data_transfer_report_get_path_radio_type(
            report: &NWDataTransferReport,
            path_index: u32,
        ) -> nw_interface_radio_type_t;
    }
    unsafe { nw_data_transfer_report_get_path_radio_type(self, path_index) }
}

#[deprecated = "renamed to `NWEthernetChannel::new`"]
#[inline]
pub extern "C-unwind" fn nw_ethernet_channel_create(
    ether_type: u16,
    interface: &NWInterface,
) -> NWRetained<NWEthernetChannel> {
    extern "C-unwind" {
        fn nw_ethernet_channel_create(
            ether_type: u16,
            interface: &NWInterface,
        ) -> Option<NonNull<NWEthernetChannel>>;
    }
    let ret = unsafe { nw_ethernet_channel_create(ether_type, interface) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWEthernetChannel::with_parameters`"]
#[inline]
pub extern "C-unwind" fn nw_ethernet_channel_create_with_parameters(
    ether_type: u16,
    interface: &NWInterface,
    parameters: &NWParameters,
) -> NWRetained<NWEthernetChannel> {
    extern "C-unwind" {
        fn nw_ethernet_channel_create_with_parameters(
            ether_type: u16,
            interface: &NWInterface,
            parameters: &NWParameters,
        ) -> Option<NonNull<NWEthernetChannel>>;
    }
    let ret =
        unsafe { nw_ethernet_channel_create_with_parameters(ether_type, interface, parameters) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWEthernetChannel::set_state_changed_handler`"]
    pub fn nw_ethernet_channel_set_state_changed_handler(
        ethernet_channel: &NWEthernetChannel,
        handler: nw_ethernet_channel_state_changed_handler_t,
    );
}

#[deprecated = "renamed to `NWEthernetChannel::set_queue`"]
#[inline]
pub extern "C-unwind" fn nw_ethernet_channel_set_queue(&self, queue: &DispatchQueue) {
    extern "C-unwind" {
        fn nw_ethernet_channel_set_queue(
            ethernet_channel: &NWEthernetChannel,
            queue: &DispatchQueue,
        );
    }
    unsafe { nw_ethernet_channel_set_queue(self, queue) }
}

#[deprecated = "renamed to `NWEthernetChannel::maximum_payload_size`"]
#[inline]
pub extern "C-unwind" fn nw_ethernet_channel_get_maximum_payload_size(&self) -> u32 {
    extern "C-unwind" {
        fn nw_ethernet_channel_get_maximum_payload_size(
            ethernet_channel: &NWEthernetChannel,
        ) -> u32;
    }
    unsafe { nw_ethernet_channel_get_maximum_payload_size(self) }
}

#[deprecated = "renamed to `NWEthernetChannel::start`"]
#[inline]
pub extern "C-unwind" fn nw_ethernet_channel_start(&self) {
    extern "C-unwind" {
        fn nw_ethernet_channel_start(ethernet_channel: &NWEthernetChannel);
    }
    unsafe { nw_ethernet_channel_start(self) }
}

#[deprecated = "renamed to `NWEthernetChannel::cancel`"]
#[inline]
pub extern "C-unwind" fn nw_ethernet_channel_cancel(&self) {
    extern "C-unwind" {
        fn nw_ethernet_channel_cancel(ethernet_channel: &NWEthernetChannel);
    }
    unsafe { nw_ethernet_channel_cancel(self) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWEthernetChannel::set_receive_handler`"]
    pub fn nw_ethernet_channel_set_receive_handler(
        ethernet_channel: &NWEthernetChannel,
        handler: nw_ethernet_channel_receive_handler_t,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWEthernetChannel::send`"]
    pub fn nw_ethernet_channel_send(
        ethernet_channel: &NWEthernetChannel,
        content: &DispatchData,
        vlan_tag: u16,
        remote_address: nw_ethernet_address_t,
        completion: nw_ethernet_channel_send_completion_t,
    );
}

#[deprecated = "renamed to `NWProtocolMetadata::is_framer_message`"]
#[inline]
pub extern "C-unwind" fn nw_protocol_metadata_is_framer_message(&self) -> bool {
    extern "C-unwind" {
        fn nw_protocol_metadata_is_framer_message(metadata: &NWProtocolMetadata) -> bool;
    }
    unsafe { nw_protocol_metadata_is_framer_message(self) }
}

#[deprecated = "renamed to `NWFramer::message_create`"]
#[inline]
pub extern "C-unwind" fn nw_framer_message_create(&self) -> NWRetained<NWFramerMessage> {
    extern "C-unwind" {
        fn nw_framer_message_create(framer: &NWFramer) -> Option<NonNull<NWFramerMessage>>;
    }
    let ret = unsafe { nw_framer_message_create(self) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWFramer::set_input_handler`"]
    pub fn nw_framer_set_input_handler(framer: &NWFramer, input_handler: nw_framer_input_handler_t);
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWFramer::set_output_handler`"]
    pub fn nw_framer_set_output_handler(
        framer: &NWFramer,
        output_handler: nw_framer_output_handler_t,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWFramer::set_wakeup_handler`"]
    pub fn nw_framer_set_wakeup_handler(
        framer: &NWFramer,
        wakeup_handler: nw_framer_wakeup_handler_t,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWFramer::set_stop_handler`"]
    pub fn nw_framer_set_stop_handler(framer: &NWFramer, stop_handler: nw_framer_stop_handler_t);
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWFramer::set_cleanup_handler`"]
    pub fn nw_framer_set_cleanup_handler(
        framer: &NWFramer,
        cleanup_handler: nw_framer_cleanup_handler_t,
    );
}

#[deprecated = "renamed to `NWFramer::mark_ready`"]
#[inline]
pub extern "C-unwind" fn nw_framer_mark_ready(&self) {
    extern "C-unwind" {
        fn nw_framer_mark_ready(framer: &NWFramer);
    }
    unsafe { nw_framer_mark_ready(self) }
}

#[deprecated = "renamed to `NWFramer::prepend_application_protocol`"]
#[inline]
pub extern "C-unwind" fn nw_framer_prepend_application_protocol(
    &self,
    protocol_options: &NWProtocolOptions,
) -> bool {
    extern "C-unwind" {
        fn nw_framer_prepend_application_protocol(
            framer: &NWFramer,
            protocol_options: &NWProtocolOptions,
        ) -> bool;
    }
    unsafe { nw_framer_prepend_application_protocol(self, protocol_options) }
}

#[deprecated = "renamed to `NWFramer::mark_failed_with_error`"]
#[inline]
pub extern "C-unwind" fn nw_framer_mark_failed_with_error(&self, error_code: c_int) {
    extern "C-unwind" {
        fn nw_framer_mark_failed_with_error(framer: &NWFramer, error_code: c_int);
    }
    unsafe { nw_framer_mark_failed_with_error(self, error_code) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWFramer::parse_input`"]
    pub fn nw_framer_parse_input(
        framer: &NWFramer,
        minimum_incomplete_length: usize,
        maximum_length: usize,
        temp_buffer: *mut u8,
        parse: nw_framer_parse_completion_t,
    ) -> bool;
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWFramer::deliver_input`"]
    pub fn nw_framer_deliver_input(
        framer: &NWFramer,
        input_buffer: NonNull<u8>,
        input_length: usize,
        message: &NWFramerMessage,
        is_complete: bool,
    );
}

#[deprecated = "renamed to `NWFramer::deliver_input_no_copy`"]
#[inline]
pub extern "C-unwind" fn nw_framer_deliver_input_no_copy(
    &self,
    input_length: usize,
    message: &NWFramerMessage,
    is_complete: bool,
) -> bool {
    extern "C-unwind" {
        fn nw_framer_deliver_input_no_copy(
            framer: &NWFramer,
            input_length: usize,
            message: &NWFramerMessage,
            is_complete: bool,
        ) -> bool;
    }
    unsafe { nw_framer_deliver_input_no_copy(self, input_length, message, is_complete) }
}

#[deprecated = "renamed to `NWFramer::pass_through_input`"]
#[inline]
pub extern "C-unwind" fn nw_framer_pass_through_input(&self) {
    extern "C-unwind" {
        fn nw_framer_pass_through_input(framer: &NWFramer);
    }
    unsafe { nw_framer_pass_through_input(self) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWFramer::parse_output`"]
    pub fn nw_framer_parse_output(
        framer: &NWFramer,
        minimum_incomplete_length: usize,
        maximum_length: usize,
        temp_buffer: *mut u8,
        parse: nw_framer_parse_completion_t,
    ) -> bool;
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWFramer::write_output`"]
    pub fn nw_framer_write_output(
        framer: &NWFramer,
        output_buffer: NonNull<u8>,
        output_length: usize,
    );
}

#[deprecated = "renamed to `NWFramer::write_output_data`"]
#[inline]
pub extern "C-unwind" fn nw_framer_write_output_data(&self, output_data: &DispatchData) {
    extern "C-unwind" {
        fn nw_framer_write_output_data(framer: &NWFramer, output_data: &DispatchData);
    }
    unsafe { nw_framer_write_output_data(self, output_data) }
}

#[deprecated = "renamed to `NWFramer::write_output_no_copy`"]
#[inline]
pub extern "C-unwind" fn nw_framer_write_output_no_copy(&self, output_length: usize) -> bool {
    extern "C-unwind" {
        fn nw_framer_write_output_no_copy(framer: &NWFramer, output_length: usize) -> bool;
    }
    unsafe { nw_framer_write_output_no_copy(self, output_length) }
}

#[deprecated = "renamed to `NWFramer::pass_through_output`"]
#[inline]
pub extern "C-unwind" fn nw_framer_pass_through_output(&self) {
    extern "C-unwind" {
        fn nw_framer_pass_through_output(framer: &NWFramer);
    }
    unsafe { nw_framer_pass_through_output(self) }
}

#[deprecated = "renamed to `NWFramer::schedule_wakeup`"]
#[inline]
pub extern "C-unwind" fn nw_framer_schedule_wakeup(&self, milliseconds: u64) {
    extern "C-unwind" {
        fn nw_framer_schedule_wakeup(framer: &NWFramer, milliseconds: u64);
    }
    unsafe { nw_framer_schedule_wakeup(self, milliseconds) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWFramer::async`"]
    pub fn nw_framer_async(framer: &NWFramer, async_block: nw_framer_block_t);
}

#[deprecated = "renamed to `NWFramer::remote_endpoint`"]
#[inline]
pub extern "C-unwind" fn nw_framer_copy_remote_endpoint(&self) -> NWRetained<NWEndpoint> {
    extern "C-unwind" {
        fn nw_framer_copy_remote_endpoint(framer: &NWFramer) -> Option<NonNull<NWEndpoint>>;
    }
    let ret = unsafe { nw_framer_copy_remote_endpoint(self) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWFramer::local_endpoint`"]
#[inline]
pub extern "C-unwind" fn nw_framer_copy_local_endpoint(&self) -> NWRetained<NWEndpoint> {
    extern "C-unwind" {
        fn nw_framer_copy_local_endpoint(framer: &NWFramer) -> Option<NonNull<NWEndpoint>>;
    }
    let ret = unsafe { nw_framer_copy_local_endpoint(self) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWFramer::parameters`"]
#[inline]
pub extern "C-unwind" fn nw_framer_copy_parameters(&self) -> NWRetained<NWParameters> {
    extern "C-unwind" {
        fn nw_framer_copy_parameters(framer: &NWFramer) -> Option<NonNull<NWParameters>>;
    }
    let ret = unsafe { nw_framer_copy_parameters(self) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWFramer::options`"]
#[inline]
pub extern "C-unwind" fn nw_framer_copy_options(&self) -> NWRetained<NWProtocolOptions> {
    extern "C-unwind" {
        fn nw_framer_copy_options(framer: &NWFramer) -> Option<NonNull<NWProtocolOptions>>;
    }
    let ret = unsafe { nw_framer_copy_options(self) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWProtocolMetadata::is_ip`"]
#[inline]
pub extern "C-unwind" fn nw_protocol_metadata_is_ip(&self) -> bool {
    extern "C-unwind" {
        fn nw_protocol_metadata_is_ip(metadata: &NWProtocolMetadata) -> bool;
    }
    unsafe { nw_protocol_metadata_is_ip(self) }
}

#[deprecated = "renamed to `NWListener::with_port`"]
#[inline]
pub unsafe extern "C-unwind" fn nw_listener_create_with_port(
    port: NonNull<c_char>,
    parameters: &NWParameters,
) -> Option<NWRetained<NWListener>> {
    extern "C-unwind" {
        fn nw_listener_create_with_port(
            port: NonNull<c_char>,
            parameters: &NWParameters,
        ) -> Option<NonNull<NWListener>>;
    }
    let ret = unsafe { nw_listener_create_with_port(port, parameters) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

#[deprecated = "renamed to `NWListener::with_launchd_key`"]
#[inline]
pub unsafe extern "C-unwind" fn nw_listener_create_with_launchd_key(
    parameters: &NWParameters,
    launchd_key: NonNull<c_char>,
) -> NWRetained<NWListener> {
    extern "C-unwind" {
        fn nw_listener_create_with_launchd_key(
            parameters: &NWParameters,
            launchd_key: NonNull<c_char>,
        ) -> Option<NonNull<NWListener>>;
    }
    let ret = unsafe { nw_listener_create_with_launchd_key(parameters, launchd_key) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWListener::new`"]
#[inline]
pub extern "C-unwind" fn nw_listener_create(
    parameters: &NWParameters,
) -> Option<NWRetained<NWListener>> {
    extern "C-unwind" {
        fn nw_listener_create(parameters: &NWParameters) -> Option<NonNull<NWListener>>;
    }
    let ret = unsafe { nw_listener_create(parameters) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

#[deprecated = "renamed to `NWListener::with_connection`"]
#[inline]
pub extern "C-unwind" fn nw_listener_create_with_connection(
    connection: &NWConnection,
    parameters: &NWParameters,
) -> Option<NWRetained<NWListener>> {
    extern "C-unwind" {
        fn nw_listener_create_with_connection(
            connection: &NWConnection,
            parameters: &NWParameters,
        ) -> Option<NonNull<NWListener>>;
    }
    let ret = unsafe { nw_listener_create_with_connection(connection, parameters) };
    ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
}

#[deprecated = "renamed to `NWListener::set_queue`"]
#[inline]
pub extern "C-unwind" fn nw_listener_set_queue(&self, queue: &DispatchQueue) {
    extern "C-unwind" {
        fn nw_listener_set_queue(listener: &NWListener, queue: &DispatchQueue);
    }
    unsafe { nw_listener_set_queue(self, queue) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWListener::set_state_changed_handler`"]
    pub fn nw_listener_set_state_changed_handler(
        listener: &NWListener,
        handler: nw_listener_state_changed_handler_t,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWListener::set_new_connection_handler`"]
    pub fn nw_listener_set_new_connection_handler(
        listener: &NWListener,
        handler: nw_listener_new_connection_handler_t,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWListener::set_new_connection_group_handler`"]
    pub fn nw_listener_set_new_connection_group_handler(
        listener: &NWListener,
        handler: nw_listener_new_connection_group_handler_t,
    );
}

#[deprecated = "renamed to `NWListener::new_connection_limit`"]
#[inline]
pub extern "C-unwind" fn nw_listener_get_new_connection_limit(&self) -> u32 {
    extern "C-unwind" {
        fn nw_listener_get_new_connection_limit(listener: &NWListener) -> u32;
    }
    unsafe { nw_listener_get_new_connection_limit(self) }
}

#[deprecated = "renamed to `NWListener::set_new_connection_limit`"]
#[inline]
pub extern "C-unwind" fn nw_listener_set_new_connection_limit(&self, new_connection_limit: u32) {
    extern "C-unwind" {
        fn nw_listener_set_new_connection_limit(listener: &NWListener, new_connection_limit: u32);
    }
    unsafe { nw_listener_set_new_connection_limit(self, new_connection_limit) }
}

#[deprecated = "renamed to `NWListener::set_advertise_descriptor`"]
#[inline]
pub extern "C-unwind" fn nw_listener_set_advertise_descriptor(
    &self,
    advertise_descriptor: Option<&NWAdvertiseDescriptor>,
) {
    extern "C-unwind" {
        fn nw_listener_set_advertise_descriptor(
            listener: &NWListener,
            advertise_descriptor: Option<&NWAdvertiseDescriptor>,
        );
    }
    unsafe { nw_listener_set_advertise_descriptor(self, advertise_descriptor) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWListener::set_advertised_endpoint_changed_handler`"]
    pub fn nw_listener_set_advertised_endpoint_changed_handler(
        listener: &NWListener,
        handler: nw_listener_advertised_endpoint_changed_handler_t,
    );
}

#[deprecated = "renamed to `NWListener::port`"]
#[inline]
pub extern "C-unwind" fn nw_listener_get_port(&self) -> u16 {
    extern "C-unwind" {
        fn nw_listener_get_port(listener: &NWListener) -> u16;
    }
    unsafe { nw_listener_get_port(self) }
}

#[deprecated = "renamed to `NWListener::start`"]
#[inline]
pub extern "C-unwind" fn nw_listener_start(&self) {
    extern "C-unwind" {
        fn nw_listener_start(listener: &NWListener);
    }
    unsafe { nw_listener_start(self) }
}

#[deprecated = "renamed to `NWListener::cancel`"]
#[inline]
pub extern "C-unwind" fn nw_listener_cancel(&self) {
    extern "C-unwind" {
        fn nw_listener_cancel(listener: &NWListener);
    }
    unsafe { nw_listener_cancel(self) }
}

#[deprecated = "renamed to `NWPathMonitor::new`"]
#[inline]
pub extern "C-unwind" fn nw_path_monitor_create() -> NWRetained<NWPathMonitor> {
    extern "C-unwind" {
        fn nw_path_monitor_create() -> Option<NonNull<NWPathMonitor>>;
    }
    let ret = unsafe { nw_path_monitor_create() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWPathMonitor::with_type`"]
#[inline]
pub extern "C-unwind" fn nw_path_monitor_create_with_type(
    required_interface_type: nw_interface_type_t,
) -> NWRetained<NWPathMonitor> {
    extern "C-unwind" {
        fn nw_path_monitor_create_with_type(
            required_interface_type: nw_interface_type_t,
        ) -> Option<NonNull<NWPathMonitor>>;
    }
    let ret = unsafe { nw_path_monitor_create_with_type(required_interface_type) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWPathMonitor::new_for_ethernet_channel`"]
#[inline]
pub extern "C-unwind" fn nw_path_monitor_create_for_ethernet_channel() -> NWRetained<NWPathMonitor>
{
    extern "C-unwind" {
        fn nw_path_monitor_create_for_ethernet_channel() -> Option<NonNull<NWPathMonitor>>;
    }
    let ret = unsafe { nw_path_monitor_create_for_ethernet_channel() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { NWRetained::from_raw(ret) }
}

#[deprecated = "renamed to `NWPathMonitor::prohibit_interface_type`"]
#[inline]
pub extern "C-unwind" fn nw_path_monitor_prohibit_interface_type(
    &self,
    interface_type: nw_interface_type_t,
) {
    extern "C-unwind" {
        fn nw_path_monitor_prohibit_interface_type(
            monitor: &NWPathMonitor,
            interface_type: nw_interface_type_t,
        );
    }
    unsafe { nw_path_monitor_prohibit_interface_type(self, interface_type) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWPathMonitor::set_cancel_handler`"]
    pub fn nw_path_monitor_set_cancel_handler(
        monitor: &NWPathMonitor,
        cancel_handler: nw_path_monitor_cancel_handler_t,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `NWPathMonitor::set_update_handler`"]
    pub fn nw_path_monitor_set_update_handler(
        monitor: &NWPathMonitor,
        update_handler: nw_path_monitor_update_handler_t,
    );
}

#[deprecated = "renamed to `NWPathMonitor::set_queue`"]
#[inline]
pub extern "C-unwind" fn nw_path_monitor_set_queue(&self, queue: &DispatchQueue) {
    extern "C-unwind" {
        fn nw_path_monitor_set_queue(monitor: &NWPathMonitor, queue: &DispatchQueue);
    }
    unsafe { nw_path_monitor_set_queue(self, queue) }
}

#[deprecated = "renamed to `NWPathMonitor::start`"]
#[inline]
pub extern "C-unwind" fn nw_path_monitor_start(&self) {
    extern "C-unwind" {
        fn nw_path_monitor_start(monitor: &NWPathMonitor);
    }
    unsafe { nw_path_monitor_start(self) }
}

#[deprecated = "renamed to `NWPathMonitor::cancel`"]
#[inline]
pub extern "C-unwind" fn nw_path_monitor_cancel(&self) {
    extern "C-unwind" {
        fn nw_path_monitor_cancel(monitor: &NWPathMonitor);
    }
    unsafe { nw_path_monitor_cancel(self) }
}

#[deprecated = "renamed to `NWProtocolOptions::is_quic`"]
#[inline]
pub extern "C-unwind" fn nw_protocol_options_is_quic(&self) -> bool {
    extern "C-unwind" {
        fn nw_protocol_options_is_quic(options: &NWProtocolOptions) -> bool;
    }
    unsafe { nw_protocol_options_is_quic(self) }
}

#[deprecated = "renamed to `NWProtocolMetadata::is_quic`"]
#[inline]
pub extern "C-unwind" fn nw_protocol_metadata_is_quic(&self) -> bool {
    extern "C-unwind" {
        fn nw_protocol_metadata_is_quic(metadata: &NWProtocolMetadata) -> bool;
    }
    unsafe { nw_protocol_metadata_is_quic(self) }
}

#[deprecated = "renamed to `NWProtocolMetadata::is_tcp`"]
#[inline]
pub extern "C-unwind" fn nw_protocol_metadata_is_tcp(&self) -> bool {
    extern "C-unwind" {
        fn nw_protocol_metadata_is_tcp(metadata: &NWProtocolMetadata) -> bool;
    }
    unsafe { nw_protocol_metadata_is_tcp(self) }
}

#[deprecated = "renamed to `NWProtocolMetadata::is_tls`"]
#[inline]
pub extern "C-unwind" fn nw_protocol_metadata_is_tls(&self) -> bool {
    extern "C-unwind" {
        fn nw_protocol_metadata_is_tls(metadata: &NWProtocolMetadata) -> bool;
    }
    unsafe { nw_protocol_metadata_is_tls(self) }
}

#[deprecated = "renamed to `NWProtocolMetadata::is_udp`"]
#[inline]
pub extern "C-unwind" fn nw_protocol_metadata_is_udp(&self) -> bool {
    extern "C-unwind" {
        fn nw_protocol_metadata_is_udp(metadata: &NWProtocolMetadata) -> bool;
    }
    unsafe { nw_protocol_metadata_is_udp(self) }
}

#[deprecated = "renamed to `NWProtocolMetadata::is_ws`"]
#[inline]
pub extern "C-unwind" fn nw_protocol_metadata_is_ws(&self) -> bool {
    extern "C-unwind" {
        fn nw_protocol_metadata_is_ws(metadata: &NWProtocolMetadata) -> bool;
    }
    unsafe { nw_protocol_metadata_is_ws(self) }
}
